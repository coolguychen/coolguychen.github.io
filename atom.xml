<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Cool Chen&#39;s blog</title>
  
  <subtitle>record just for fun.</subtitle>
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2023-08-04T08:23:07.791Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>cyh</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Hello World</title>
    <link href="http://example.com/2023/08/04/hello-world/"/>
    <id>http://example.com/2023/08/04/hello-world/</id>
    <published>2023-08-04T08:23:07.791Z</published>
    <updated>2023-08-04T08:23:07.791Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.io/docs/&quot;&gt;documentation&lt;/a&gt; for</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>深度学习进阶</title>
    <link href="http://example.com/2023/06/12/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E8%BF%9B%E9%98%B6/"/>
    <id>http://example.com/2023/06/12/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E8%BF%9B%E9%98%B6/</id>
    <published>2023-06-12T09:55:04.000Z</published>
    <updated>2023-08-01T13:08:18.616Z</updated>
    
    <content type="html"><![CDATA[<p>基于《深度学习进阶——自然语言处理》</p><h1 id="第五章-RNN"><a href="#第五章-RNN" class="headerlink" title="第五章 RNN"></a>第五章 RNN</h1><h1 id="第六章-Gated-RNN"><a href="#第六章-Gated-RNN" class="headerlink" title="第六章 Gated RNN"></a>第六章 Gated RNN</h1><h1 id="第七章-基于RNN生成文本"><a href="#第七章-基于RNN生成文本" class="headerlink" title="第七章 基于RNN生成文本"></a>第七章 基于RNN生成文本</h1><p>seq2seq  编码器和解码器</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;基于《深度学习进阶——自然语言处理》&lt;/p&gt;
&lt;h1 id=&quot;第五章-RNN&quot;&gt;&lt;a href=&quot;#第五章-RNN&quot; class=&quot;headerlink&quot; title=&quot;第五章 RNN&quot;&gt;&lt;/a&gt;第五章 RNN&lt;/h1&gt;&lt;h1 id=&quot;第六章-Gated-RNN&quot;&gt;&lt;a h</summary>
      
    
    
    
    <category term="Study" scheme="http://example.com/categories/Study/"/>
    
    
    <category term="Deep Learning" scheme="http://example.com/tags/Deep-Learning/"/>
    
  </entry>
  
  <entry>
    <title>latex学习</title>
    <link href="http://example.com/2023/03/21/latex%E5%AD%A6%E4%B9%A0/"/>
    <id>http://example.com/2023/03/21/latex%E5%AD%A6%E4%B9%A0/</id>
    <published>2023-03-21T07:18:12.000Z</published>
    <updated>2023-07-09T18:50:28.033Z</updated>
    
    <content type="html"><![CDATA[<p>写在前面：LaTeX（LATEX，音译“拉泰赫”）是一种基于ΤΕΧ的排版系统。LaTeX遵循呈现与内容分离的设计理念，以便作者可以专注于他们正在编写的内容，而不必同时注视其外观。因此它非常适用于生成高印刷质量的科技和数学、物理文档。</p><p>因为本科论文是用latex写的，就把在写论文时遇到的一些问题&#x2F;一些常用代码放在这里。</p><p>使用的是overleaf在线编译器。优点是不需要自己在本地进行一些环境配置；缺点是有点卡，服务器是时不时会down。</p><p><a href="https://flowus.cn/latex/share/66110e84-b24a-4cd5-b8a7-2ba2afb35a30">常用LaTeX代码</a></p><h1 id="字体与符号"><a href="#字体与符号" class="headerlink" title="字体与符号"></a>字体与符号</h1><h2 id="字体格式"><a href="#字体格式" class="headerlink" title="字体格式"></a>字体格式</h2><p>\CJKfamily{song}：设置为宋体。</p><p>\CJKfamily{hei}：设置为黑体。</p><p>\CJKfamily{kai}：设置为楷体。</p><h2 id="字体颜色"><a href="#字体颜色" class="headerlink" title="字体颜色"></a>字体颜色</h2><p>\usepackage{color}</p><p>\textcolor[rgb]{r,g,b}{text}</p><p>其中{r,g,b}代表red、green和blue三种颜色的组合，取值范围为[0-1]</p><p>\textcolor[RGB]{R,G,B}{text}</p><p>其中{R,G,B}代表red、green和blue三种颜色的组合，取值范围为[0-255]</p><h1 id="换行、分页"><a href="#换行、分页" class="headerlink" title="换行、分页"></a>换行、分页</h1><h2 id="空格"><a href="#空格" class="headerlink" title="空格"></a>空格</h2><ul><li>文本中空格起到分隔单词的作用，连续多个空格并不会增大间距，也只会被解释为一个空格。</li><li>只有字符后面的空格才是有效的，每行最前面的空格会被LaTeX忽略（段前缩紧的工作由LaTeX自动完成）。</li><li>在正文中，单个回车也会被解释为空格</li><li>对于以字母命名的命令，后面需要加空格以和其他文本分开。<code>Happy \TeX ing</code>——正确，<code>Happy \TeX ing</code>——编译器报错。</li></ul><h2 id="换行"><a href="#换行" class="headerlink" title="换行"></a>换行</h2><ul><li>连续两个回车</li><li>\\</li><li>\newline</li></ul><h2 id="分页"><a href="#分页" class="headerlink" title="分页"></a>分页</h2><p>\newpage</p><h1 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h1><p>\setcounter{tocdepth}{2} 设置目录显示深度为2（只显示1、2级标题）</p><h2 id="LaTex-解决目录红框"><a href="#LaTex-解决目录红框" class="headerlink" title="LaTex 解决目录红框"></a>LaTex 解决目录红框</h2><p><a href="https://blog.csdn.net/z_feng12489/article/details/90522718">https://blog.csdn.net/z_feng12489/article/details/90522718</a></p><p>使用到宏包：</p><p><code>\usepackage&#123;hyperref&#125;</code></p><p>在文档的前面（通常是package_and_settings.tex里面）加上如下代码就解决了，意思是设置链接的颜色：</p><figure class="highlight latex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">\hypersetup</span>&#123;</span><br><span class="line">colorlinks=true,</span><br><span class="line">linkcolor=black</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><h2 id="伪代码——基于Algorithm2e"><a href="#伪代码——基于Algorithm2e" class="headerlink" title="伪代码——基于Algorithm2e"></a>伪代码——基于Algorithm2e</h2><p>latex 书写伪代码主要有三种排版格式：algorithm+algorithmic、algorithm+algorithmicx 以及 algorithm2e<a href="https://shuzang.github.io/2021/pseudocode-specification/#fn:3">3</a>。我们使用 <a href="https://www.ctan.org/pkg/algorithm2e">algorithm2e</a>，它提供了垂直连接线，可以去掉 end 关键字，而且写起来更像编程语言，用着非常舒服。</p><ol><li>导入 algorithm2e 宏包：</li></ol><p>在 LaTeX 文档的导言区中，添加以下代码来导入 algorithm2e 宏包：</p><figure class="highlight latex"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">\usepackage</span>[ruled,vlined,commentsnumbered,algosection]&#123;algorithm2e&#125;</span><br></pre></td></tr></table></figure><ul><li>参数 “ruled”(让标题显示在最上面) 和 “vlined”(垂直连接线) 用于指定算法的外观样式</li><li>参数linesnumbered表示为代码行号</li><li>参数 “commentsnumbered” 则表示要为注释编号</li><li>参数algosection表示伪代码按照章节编号。</li></ul><ol start="2"><li>定义注释样式：</li></ol><p>在导言区中，添加以下代码来定义注释样式：</p><figure class="highlight latex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">\SetCommentSty</span>&#123;myCommentStyle&#125;</span><br><span class="line"><span class="keyword">\newcommand</span><span class="keyword">\myCommentStyle</span>[1]&#123;<span class="keyword">\footnotesize</span><span class="keyword">\ttfamily</span><span class="keyword">\textcolor</span>&#123;blue&#125;&#123;<span class="params">#1</span>&#125;&#125;</span><br></pre></td></tr></table></figure><p>其中，\SetCommentSty 用于设置注释样式，\myCommentStyle 定义了注释样式的具体格式。在这个例子中，我们将注释的字体大小设置为 \footnotesize，字体设置为等宽字体 \ttfamily，颜色设置为蓝色 \textcolor{blue}，并将注释内容包裹在大括号内作为参数</p><p>注意：</p><blockquote><p>vlined 和 lined</p><img src="/.com//03/21/latex%E5%AD%A6%E4%B9%A0/image-20230321164711726.png" class title="image-20230321164711726"></blockquote><p><a href="https://zhuanlan.zhihu.com/p/166418214">用LaTeX优雅地书写伪代码——Algorithm2e简明指南</a></p><p><a href="https://shuzang.github.io/2021/pseudocode-specification/">伪代码规范</a></p><figure class="highlight latex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">\usepackage</span>[ruled,lined,linesnumbered,algosection]&#123;algorithm2e&#125; </span><br><span class="line"><span class="comment">% 让标题显示在上面；垂直连接线；行号；按章节编号</span></span><br></pre></td></tr></table></figure><h3 id="修改标题编号"><a href="#修改标题编号" class="headerlink" title="修改标题编号"></a>修改标题编号</h3><p>将x.x &#x3D;&gt; x-x</p><figure class="highlight latex"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">\renewcommand</span>*&#123;<span class="keyword">\thealgocf</span>&#125;&#123;<span class="keyword">\arabic</span>&#123;section&#125;-<span class="keyword">\arabic</span>&#123;algocf&#125;&#125;</span><br></pre></td></tr></table></figure><h2 id="插入代码——基于minted"><a href="#插入代码——基于minted" class="headerlink" title="插入代码——基于minted"></a>插入代码——基于minted</h2><p>minted宏包</p><p><a href="https://www.jianshu.com/p/370b8c34cb41">在LaTeX中插入程序代码</a></p><p>fontfamily &#x3D; new times roman 修改字体格式</p><h2 id="插入算法索引"><a href="#插入算法索引" class="headerlink" title="插入算法索引"></a>插入算法索引</h2><figure class="highlight latex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">\listofalgorithms</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">\renewcommand</span>&#123;<span class="keyword">\listalgorithmcfname</span>&#125;&#123;算<span class="keyword">\ </span>法<span class="keyword">\ </span>目<span class="keyword">\ </span>录&#125; <span class="comment">% 重命名已存在的命令行</span></span><br></pre></td></tr></table></figure><p>想要标题居中的话：</p><img src="/.com//03/21/latex%E5%AD%A6%E4%B9%A0/image-20230401230402038.png" class title="image-20230401230402038"><h1 id="插入图表"><a href="#插入图表" class="headerlink" title="插入图表"></a>插入图表</h1><h2 id="图"><a href="#图" class="headerlink" title="图"></a>图</h2><figure class="highlight latex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">\begin</span>&#123;figure&#125;[ht] <span class="comment">% 对图片进行浮动显示，h-here，t-top；图片会自动生成编号</span></span><br><span class="line"><span class="keyword">\centering</span> <span class="comment">% 图片居中显示</span></span><br><span class="line"> <span class="keyword">\includegraphics</span>[scale=0.6]&#123;xiantu.pdf&#125; <span class="comment">% 导入图片（当前目录的相对路径）</span></span><br><span class="line"> <span class="keyword">\caption</span>&#123;&#125; <span class="comment">% 为图片生成标题以及编号</span></span><br><span class="line"> <span class="keyword">\label</span>&#123;fig:xiantu&#125; <span class="comment">% 为图片赋予标号，方便后期引用</span></span><br><span class="line"><span class="keyword">\end</span>&#123;figure&#125;</span><br></pre></td></tr></table></figure><h3 id="插入图索引"><a href="#插入图索引" class="headerlink" title="插入图索引"></a>插入图索引</h3><figure class="highlight latex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">\listoffigures</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">\renewcommand</span><span class="keyword">\listfigurename</span>&#123;插<span class="keyword">\ </span>图<span class="keyword">\ </span>目<span class="keyword">\ </span>录&#125;</span><br></pre></td></tr></table></figure><h2 id="表"><a href="#表" class="headerlink" title="表"></a>表</h2><p><code>\begin&#123;table&#125;</code>环境+<code>\begin&#123;tabular&#125;</code>导入表格</p><figure class="highlight latex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">\begin</span>&#123;table&#125;[ht] <span class="comment">% 设置浮动环境</span></span><br><span class="line">  <span class="keyword">\begin</span>&#123;tabular&#125;&#123;|rrr|&#125; <span class="comment">% 产生表格，r：右对齐，三个r：总共三列，|：在两边生成竖线</span></span><br><span class="line">    <span class="keyword">\hline</span> <span class="comment">% 生成直线</span></span><br><span class="line">    直角边<span class="built_in">$</span>a<span class="built_in">$</span> <span class="built_in">&amp;</span> 直角边<span class="built_in">$</span>b<span class="built_in">$</span> <span class="built_in">&amp;</span> 斜边<span class="built_in">$</span>c<span class="built_in">$</span> <span class="keyword">\\</span> <span class="comment">% \\表示换行</span></span><br><span class="line">    <span class="keyword">\hline</span> </span><br><span class="line">    3 <span class="built_in">&amp;</span> 4 <span class="built_in">&amp;</span> 5 <span class="keyword">\\</span></span><br><span class="line">    5 <span class="built_in">&amp;</span> 12 <span class="built_in">&amp;</span> 13 <span class="keyword">\\</span></span><br><span class="line">    <span class="keyword">\hline</span></span><br><span class="line">  <span class="keyword">\end</span>&#123;tabular&#125;</span><br><span class="line">  <span class="keyword">\qquad</span> <span class="comment">% \qquad：产生2em宽的空格</span></span><br><span class="line">  (<span class="built_in">$</span>a<span class="built_in">^</span>2 + b<span class="built_in">^</span>2 = c<span class="built_in">^</span>2<span class="built_in">$</span>)  </span><br><span class="line"><span class="keyword">\end</span>&#123;table&#125;</span><br></pre></td></tr></table></figure><p><a href="https://zhuanlan.zhihu.com/p/22576629">如何快速在线生成latex表格</a></p><h2 id="按章节编号"><a href="#按章节编号" class="headerlink" title="按章节编号"></a>按章节编号</h2><p>通过引入<code>\usepackage&#123;amsmath&#125;</code>包中的<code>\numberwithin&#123;figure&#125;&#123;section&#125;</code>命令，我们可以将Latex中Figure的编号和所在的章节关联起来。</p><p>参考：<a href="https://blog.csdn.net/Canhui_WANG/article/details/87364800">关于Latex的Figure图像编号关联所在章节编号之问题的解决方案</a></p><h1 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h1><p>BibTex格式写在ref.bib。</p><p>正文中通过\cite{}进行引用。</p><p><a href="https://blog.csdn.net/Ryan_lee9410/article/details/106055787?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522161416641916780262556059%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=161416641916780262556059&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduend~default-1-106055787.pc_search_result_before_js&utm_term=LaTeX%E5%BC%95%E7%94%A8%E5%8F%82%E8%80%83%E6%96%87%E7%8C%AE%E2%80%94%E2%80%94BibTex%E5%8F%82%E8%80%83%E6%96%87%E7%8C%AE%E6%A0%BC%E5%BC%8F%E5%A4%A7%E5%85%A8">LaTeX引用参考文献——BibTex参考文献格式大全</a></p><h2 id="字体大小"><a href="#字体大小" class="headerlink" title="字体大小"></a>字体大小</h2><figure class="highlight latex"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">\renewcommand</span>&#123;<span class="keyword">\bibfont</span>&#125;&#123;<span class="keyword">\songti</span> <span class="keyword">\zihao</span>&#123;5&#125;&#125;</span><br></pre></td></tr></table></figure><p>网址想要显示为：Title[E], url, Date的格式</p><h1 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h1><h3 id="超链接"><a href="#超链接" class="headerlink" title="超链接"></a>超链接</h3><ul><li>超链接用于页面的跳转，常用的宏包为<code>hyperref</code>，只需导入其就会在文献引用、目录跳转、交叉引用等处自动生成可跳转的超链接。</li><li>设置命令：<code>\hypersetup&#123;colorlinks=true&#125;</code>，超链接用红色表示（否则会在其外面加边框）。</li></ul><p>关于ECNU Latex 模板：</p><ul><li>main.tex 文章的主体 tex，<strong>直接编译 main.tex 即可</strong></li><li>packages_and_settings.tex 引入包和环境定义（<del>不要动</del>）</li><li>inner-cover.tex 封面（<del>不要动</del>）</li><li>paper_info.tex <strong>完善基本信息</strong></li><li>sign.tex 信息确认页面（不要动）</li><li>abstract.tex <strong>论文摘要部分</strong></li><li>figures 文件夹中存放论文所需要的图片</li><li>algorithm相关的所有 sty 用于支持伪代码</li><li>intros&#x2F;preli.tex 正文部分的示例</li><li>simsun.ttc 宋体字体</li></ul><p>若要加附录 和 致谢，新建.tex文件</p><p>并在main.tex中加入\input{acknowledge.tex}</p><p>\clearpage用于新起一页</p><p>若要将其加入目录</p><p>\addcontentline{标题名}</p><p>给标题加下划线：</p><p>标题在paper_info中已声明，在  前加、\underline。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;写在前面：LaTeX（LATEX，音译“拉泰赫”）是一种基于ΤΕΧ的排版系统。LaTeX遵循呈现与内容分离的设计理念，以便作者可以专注于他们正在编写的内容，而不必同时注视其外观。因此它非常适用于生成高印刷质量的科技和数学、物理文档。&lt;/p&gt;
&lt;p&gt;因为本科论文是用latex</summary>
      
    
    
    
    <category term="Study" scheme="http://example.com/categories/Study/"/>
    
    
    <category term="论文写作" scheme="http://example.com/tags/%E8%AE%BA%E6%96%87%E5%86%99%E4%BD%9C/"/>
    
    <category term="Latex" scheme="http://example.com/tags/Latex/"/>
    
  </entry>
  
  <entry>
    <title>React</title>
    <link href="http://example.com/2023/03/03/React/"/>
    <id>http://example.com/2023/03/03/React/</id>
    <published>2023-03-03T07:02:47.000Z</published>
    <updated>2023-07-09T16:08:29.329Z</updated>
    
    <content type="html"><![CDATA[<p>React：用于构建用户界面的JavaScript库。</p><p>是一个将数据渲染为HTML视图的开源JavaScript库。</p><h1 id="参考教程"><a href="#参考教程" class="headerlink" title="参考教程"></a>参考教程</h1><p><a href="https://www.bilibili.com/video/BV1FV4y157Zx?p=4&vd_source=377f414c018b3730dbce13ba666c5776">【2022最新】React项目实战(React后台管理系统、TypeScript+React18)</a></p><p><a href="https://xuzhixiong.gitlab.io/blog/2019/06/10/react-typescript-one/">https://xuzhixiong.gitlab.io/blog/2019/06/10/react-typescript-one/</a></p><p><a href="https://tsejx.github.io/react-guidebook">https://tsejx.github.io/react-guidebook</a></p><h1 id="React安装"><a href="#React安装" class="headerlink" title="React安装"></a>React安装</h1><p>首先，确保已经安装了node，如果没有安装node可先去node.js中文网下载安装。</p><p>使用命令 <code>npm i -g create-react-app</code> 全局安装create-react-app。</p><p>检测create-react-app是否安装成功 ：<code>create-react-app -V</code>。</p><p>注意，V是大写。如果出现版本号，则表示安装成功，不过如果你当前安装的node版本不支持你安装的create-react-app版本，这一步会出现红色的报错信息。</p><p>在命令提示窗口 cd 切换到你需要初始化脚手架的地址，使用命令 <code>create-react-app demo</code> 命令初始化react项目脚手架。</p><p>npm下载React-app 安装脚手架</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install -g create-react-app</span><br></pre></td></tr></table></figure><p>使用npm安装yarn安装</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i yarn -g</span><br></pre></td></tr></table></figure><p><code>$ create-react-app react-app</code></p><p>然后我们进入项目并启动。</p><p><code>$ cd react-app</code></p><p><code>$ yarn start</code></p><p>yarn start时遇到：</p><blockquote><p>‘react-scripts’ 不是内部或外部命令，也不是可运行的程序 或批处理文件。</p></blockquote><ul><li>原因：create-react-app创建项目时有时会丢包</li><li>解决方案：重新   npm install    或    npm install react-scripts</li><li>然后再启动项目</li></ul><p>链接：<a href="https://www.jianshu.com/p/778f92b75f3e">https://www.jianshu.com/p/778f92b75f3e</a></p><img src="/.com//03/03/React/image-20230303155335388.png" class title="image-20230303155335388"><p>开启本地端口3030.</p><p>运行<code>yarn add react-bootstrap bootstrap@4.6.0</code>        </p><p><code>yarn add typescript</code></p><p>UI组件库：<a href="https://ant.design/">https://ant.design/</a></p><p>引入antd组件库 <code>yarn add antd</code></p><p>React 应用程序是由 <strong>组件</strong> 组成的。一个组件是 UI（用户界面）的一部分，它拥有自己的逻辑和外观。组件可以小到一个按钮，也可以大到整个页面。</p><p>React 组件是返回标记的 JavaScript 函数：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">function MyButton() &#123;</span><br><span class="line">  return (</span><br><span class="line">    &lt;button&gt;I&#x27;m a button&lt;/button&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>至此，你已经声明了 <code>MyButton</code>，你可以把它嵌套到另一个组件中：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">export default function MyApp() &#123;</span><br><span class="line">  return (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;h1&gt;Welcome to my app&lt;/h1&gt;</span><br><span class="line">      &lt;MyButton /&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>你可能已经注意到 <code>&lt;MyButton /&gt;</code> 是以大写字母开头的。你可以根据此来区分 React 组件。<strong>React 组件必须以大写字母开头</strong>，而 HTML 标签则必须是小写字母。</p><p><code>export default</code> 关键字指定了<strong>文件中的主要组件</strong>。</p><h1 id="JSX语法"><a href="#JSX语法" class="headerlink" title="JSX语法"></a>JSX语法</h1><p>JavaScript + XML</p><h2 id="JSX样式处理"><a href="#JSX样式处理" class="headerlink" title="JSX样式处理"></a>JSX样式处理</h2><ul><li>行内style</li></ul><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">App</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&quot;App&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">&#123;&#123;</span> <span class="attr">color:</span> &#x27;<span class="attr">red</span>&#x27; &#125;&#125;&gt;</span>this is a div<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  )</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title class_">App</span></span><br></pre></td></tr></table></figure><ul><li><p>更优写法</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> styleObj = &#123;</span><br><span class="line">    <span class="attr">color</span>:red</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">App</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&quot;App&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">&#123;</span> <span class="attr">styleObj</span> &#125;&gt;</span>this is a div<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  )</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title class_">App</span></span><br></pre></td></tr></table></figure></li></ul><h1 id="函数式组件和类组件"><a href="#函数式组件和类组件" class="headerlink" title="函数式组件和类组件"></a>函数式组件和类组件</h1><p><a href="https://blog.csdn.net/weixin_45014444/article/details/99695723">React之组件介绍及用法详解</a></p><p><strong>（1）函数式组件（ 无状态组件 PureComponent）</strong><br>由于元素没有办法传递参数，所以我们就需要把之前定义的变量改为一个方法，让这个方法去return一个元素:</p><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">React</span> <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">ReactDOM</span> <span class="keyword">from</span> <span class="string">&#x27;react-dom&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 特别注意这里的写法，如果要在JSX里写js表达式(只能是表达式，不能流程控制)，就需要加 &#123;&#125;，包括注释也是一样，并且可以多层嵌套</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">app</span> = (<span class="params">props</span>) =&gt; <span class="language-xml"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>欢迎进入&#123;props.name&#125;的世界<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="title class_">ReactDOM</span>.<span class="title function_">render</span>(</span><br><span class="line">  <span class="title function_">app</span>(&#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;react&#x27;</span></span><br><span class="line">  &#125;),</span><br><span class="line">  <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;root&#x27;</span>)</span><br><span class="line">)</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="React的React-FC与React-Component的初步认识"><a href="#React的React-FC与React-Component的初步认识" class="headerlink" title="React的React.FC与React.Component的初步认识"></a>React的React.FC与React.Component的初步认识</h2><ol><li>React.FC是函数式组件，是在TypeScript使用的一个泛型，FC就是FunctionComponent的缩写，事实上React.FC可以写成React.FunctionComponent：</li></ol><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title class_">App</span>: <span class="title class_">React</span>.<span class="property">FunctionComponent</span>&lt;&#123; <span class="attr">message</span>: <span class="built_in">string</span> &#125;&gt; = <span class="function">(<span class="params">&#123; message &#125;</span>) =&gt;</span> (</span><br><span class="line"></span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>&#123;message&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line">);</span><br></pre></td></tr></table></figure><ol start="2"><li><p>React.FC 包含了 PropsWithChildren 的泛型，不用显式的声明 props.children 的类型。React.FC&lt;&gt; 对于返回类型是显式的，而普通函数版本是隐式的（否则需要附加注释）。</p></li><li><p>React.FC提供了类型检查和自动完成的静态属性：displayName，propTypes和defaultProps（注意：defaultProps与React.FC结合使用会存在一些问题）。</p></li><li><p>我们使用React.FC来写 React 组件的时候，是不能用setState的，取而代之的是useState()、useEffect等 Hook API。</p></li></ol><p>例子（这里使用阿里的Ant Desgin Pro框架来演示）：</p><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title class_">SampleModel</span>: <span class="title class_">React</span>.<span class="property">FC</span>&lt;&#123;&#125;&gt; = <span class="function">() =&gt;</span>&#123;   <span class="comment">//React.FC&lt;&gt;为typescript使用的泛型</span></span><br><span class="line">  <span class="keyword">const</span> [createModalVisible, handleModalVisible] = useState&lt;<span class="built_in">boolean</span>&gt;(<span class="literal">false</span>); </span><br><span class="line">  <span class="keyword">return</span>&#123;</span><br><span class="line">  &#123;<span class="comment">/** 触发模态框**/</span>&#125;</span><br><span class="line">  &lt;<span class="title class_">Button</span> style=&#123;&#123;<span class="attr">fontSize</span>:<span class="string">&#x27;25px&#x27;</span>&#125;&#125;  onClick=&#123;<span class="function">()=&gt;</span><span class="title function_">handleModalVisible</span>(<span class="literal">true</span>)&#125; &gt;样例&lt;/<span class="title class_">Button</span>&gt;</span><br><span class="line">  &#123;<span class="comment">/** 模态框组件**/</span>&#125;</span><br><span class="line">  &lt;<span class="title class_">Model</span> onCancel=&#123;<span class="function">() =&gt;</span> <span class="title function_">handleModalVisible</span>(<span class="literal">false</span>)&#125; <span class="title class_">ModalVisible</span>=&#123;createModalVisible&#125; /&gt; </span><br><span class="line">  &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>二、class xx extends React.Component<br>如需定义 class 组件，需要继承 React.Component。React.Component是类组件，在TypeScript中，React.Component是通用类型（aka React.Component&lt;PropType, StateType&gt;），因此要为其提供（可选）prop和state类型参数：</p><p>例子（这里使用阿里的Ant Desgin Pro框架来演示）：：</p><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">SampleModel</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.Component</span> &#123;</span><br><span class="line">  state = &#123;</span><br><span class="line">    <span class="attr">createModalVisible</span>:<span class="literal">false</span>,</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  handleModalVisible =<span class="function">(<span class="params">cVisible:<span class="built_in">boolean</span></span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">setState</span>(&#123;<span class="attr">createModalVisible</span>:cVisible&#125;);</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">  &#123;<span class="comment">/** 触发模态框**/</span>&#125;</span><br><span class="line">  &lt;<span class="title class_">Button</span> onClick=&#123;<span class="function">()=&gt;</span><span class="variable language_">this</span>.<span class="title function_">handleModalVisible</span>(<span class="literal">true</span>)&#125; &gt;样例&lt;/<span class="title class_">Button</span>&gt;</span><br><span class="line">  &#123;<span class="comment">/** 模态框组件**/</span>&#125;</span><br><span class="line">  &lt;<span class="title class_">Model</span> onCancel=&#123;<span class="function">() =&gt;</span> <span class="title function_">handleModalVisible</span>(<span class="literal">false</span>)&#125; <span class="title class_">ModalVisible</span>=&#123;<span class="variable language_">this</span>.<span class="property">state</span>.<span class="property">createModalVisible</span>&#125; /&gt; </span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>ps：简单来说，不知道用什么组件类型时，就用 React.FC。</p><h2 id="使用-Hook"><a href="#使用-Hook" class="headerlink" title="使用 Hook"></a>使用 Hook</h2><p>React Hooks 要解决的问题是<strong>状态共享</strong>。</p><p>以 <code>use</code> 开头的函数被称为 <strong>Hook</strong>。<code>useState</code> 是 React 提供的一个内置 Hook。</p><p>这个状态指的是状态逻辑，所以称为<strong>状态逻辑复用</strong>会更恰当，因为只共享数据处理逻辑，不会共享数据本身。</p><img src="/.com//03/03/React/image-20230325000052354.png" class title="image-20230325000052354"><p><strong>数据状态 + 修改状态的方法</strong></p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> [count, setCount] = <span class="title function_">useState</span>(<span class="number">0</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><a href="https://www.jianshu.com/p/d575271ad4b2">https://www.jianshu.com/p/d575271ad4b2</a></p><p><code>useState</code>是一个Hook函数，让你在函数组件中拥有state变量。它接收一个初始化的state，返回是一个数组，数组里有两个元素，第一个元素是当前状态值和另一个更新该值的方法。<br> 本教程主要是针对于React中的<code>useState</code>做一个详细的描述，它等同于函数组件中的<code>this.state</code>&#x2F;<code>this.setState</code>，我们将会围绕下面的问题逐一解析</p><h1 id="遇到的问题"><a href="#遇到的问题" class="headerlink" title="遇到的问题"></a>遇到的问题</h1><h2 id="Uncaught-Invariant-Violation-Too-many-re-renders-React-limits-the-number-of-renders-to-prevent-an-infinite-loop"><a href="#Uncaught-Invariant-Violation-Too-many-re-renders-React-limits-the-number-of-renders-to-prevent-an-infinite-loop" class="headerlink" title="Uncaught Invariant Violation: Too many re-renders. React limits the number of renders to prevent an infinite loop"></a>Uncaught Invariant Violation: Too many re-renders. React limits the number of renders to prevent an infinite loop</h2><p>出现无限循环的原因是事件回调中触发了重新呈现，最常见setState触发的，这将再次调用事件回调，并导致React停止并抛出“太多的重新呈现”的错误</p><img src="/.com//03/03/React/image-20230327221736292.png" class title="image-20230327221736292"><img src="/.com//03/03/React/image-20230327221806824.png" class title="image-20230327221806824"><h3 id="Props-和-State-本质"><a href="#Props-和-State-本质" class="headerlink" title="Props 和 State 本质"></a>Props 和 State 本质</h3><p><strong>props 是组件对外的接口，state 是组件对内的接口。</strong>组件内可以引用其他组件，组件之间的引用形成了一个树状结构（组件树），如果下层组件需要使用上层组件的数据或方法，上层组件就可以通过下层组件的props属性进行传递，因此props是组件对外的接口。组件除了使用上层组件传递的数据外，自身也可能需要维护管理数据，这就是组件对内的接口state。根据对外接口props 和对内接口state，组件计算出对应界面的UI。</p><p>组件的props 和 state都和组件最终渲染出的UI直接相关。两者的主要区别是：state是可变的，是组件内部维护的一组用于反映组件UI变化的状态集合；<strong>而props是组件的只读属性，组件内部不能直接修改props，要想修改props，只能在该组件的上层组件中修改。</strong>在组件状态上移的场景中，父组件正是通过子组件的props，传递给子组件其所需要的状态。 </p><h2 id="如何通过state在组件跳转页面时传值？"><a href="#如何通过state在组件跳转页面时传值？" class="headerlink" title="如何通过state在组件跳转页面时传值？"></a>如何通过state在组件跳转页面时传值？</h2><p>使用useLocation()</p><p> const { state } &#x3D; useLocation();</p><p>Link to 里面填写pathName &amp; state</p><p>另一个页面使用state &#x3D; useLocation()接收传过来的数据。</p><h1 id="路由配置"><a href="#路由配置" class="headerlink" title="路由配置"></a>路由配置</h1><p>import react-router-dom</p><p>App.tsx中：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// app.tsx</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">App</span> <span class="keyword">from</span> <span class="string">&quot;../App&quot;</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">Home</span> <span class="keyword">from</span> <span class="string">&quot;../views/Home&quot;</span> <span class="comment">//引入组件</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">About</span> <span class="keyword">from</span> <span class="string">&quot;../views/About&quot;</span></span><br><span class="line"><span class="keyword">import</span> &#123;<span class="title class_">BrowserRouter</span>, <span class="title class_">Routes</span>, <span class="title class_">Route</span>&#125; <span class="keyword">from</span> <span class="string">&quot;react-router-dom&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">baseRouter</span> = (<span class="params"></span>) =&gt; (</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">BrowserRouter</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">Routes</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">Route</span> <span class="attr">path</span> =  <span class="string">&quot;/&quot;</span> <span class="attr">element</span> = <span class="string">&#123;</span>&lt;<span class="attr">App</span> /&gt;</span>&#125;&gt;</span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">Route</span> <span class="attr">path</span> = <span class="string">&quot;/home&quot;</span> <span class="attr">element</span> = <span class="string">&#123;</span>&lt;<span class="attr">Home</span> /&gt;</span>&#125;&gt;<span class="tag">&lt;/<span class="name">Route</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">Route</span> <span class="attr">path</span> = <span class="string">&quot;/about&quot;</span> <span class="attr">element</span> = <span class="string">&#123;</span>&lt;<span class="attr">About</span> /&gt;</span>&#125;&gt;<span class="tag">&lt;/<span class="name">Route</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">Route</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">Routes</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">BrowserRouter</span>&gt;</span></span></span><br><span class="line">    </span><br><span class="line">)</span><br></pre></td></tr></table></figure><h1 id="Antd组件库使用"><a href="#Antd组件库使用" class="headerlink" title="Antd组件库使用"></a>Antd组件库使用</h1><h2 id="Table表格"><a href="#Table表格" class="headerlink" title="Table表格"></a>Table表格</h2><p>Ant design的Table组件报错TypeError: rawData.some is not a function。</p><p>dataSource存储的数据是数组，当dataSource赋值的数据不是数组时就会报出这样的错误。所以我们要继续向内部取到数组层。我的问题是后台没有给数组的类型，而是对象类型。为了统一数据，就让后台改成了数组。【链接：<a href="https://www.jianshu.com/p/4736ab0c300f%E3%80%91">https://www.jianshu.com/p/4736ab0c300f】</a></p><p>一定要指定rowkey，它是区分每一条记录的唯一标识。否则控制台会报各种错误，xxx should have a unique “key” props 大意就是说每一行要有唯一key。<br>它的取值可以是列名，也可以是record的某一个属性。<br>例如：<br>rowkey&#x3D;{id}（id是列名，或数据源里面每一条数据都有的属性）；<br>rowkey&#x3D;{(record)&#x3D;&gt;record.primaryKey}(primaryKey是后台返回的能代表唯一key的字段名)</p><p><a href="https://blog.csdn.net/aaqingying/article/details/118971186">https://blog.csdn.net/aaqingying/article/details/118971186</a></p><h2 id="Layout-布局"><a href="#Layout-布局" class="headerlink" title="Layout 布局"></a>Layout 布局</h2><img src="/.com//03/03/React/image-20230322195034128.png" class title="image-20230322195034128"><h2 id="侧边布局"><a href="#侧边布局" class="headerlink" title="侧边布局"></a>侧边布局</h2><p>侧边两列式布局。页面横向空间有限时，侧边导航可收起。</p><p>侧边导航在页面布局上采用的是左右的结构，一般主导航放置于页面的左侧固定位置，辅助菜单放置于工作区顶部。内容根据浏览器终端进行自适应，能提高横向空间的使用率，但是整个页面排版不稳定。侧边导航的模式层级扩展性强，一、二、三级导航项目可以更为顺畅且具关联性的被展示，同时侧边导航可以固定，使得用户在操作和浏览中可以快速的定位和切换当前位置，有很高的操作效率。但这类导航横向页面内容的空间会被牺牲一部份。</p><h2 id="Menu-导航菜单"><a href="#Menu-导航菜单" class="headerlink" title="Menu 导航菜单"></a>Menu 导航菜单</h2><h2 id="点击侧边栏跳转"><a href="#点击侧边栏跳转" class="headerlink" title="点击侧边栏跳转"></a>点击侧边栏跳转</h2><p>MenuItem: [label, key, icon, children]</p><p>添加onClick事件，菜单栏目的key写成路径。</p><h3 id="嵌套路由"><a href="#嵌套路由" class="headerlink" title="嵌套路由"></a>嵌套路由</h3><p>以systemMenu.tsx为例：</p><p>Layout + Content + Routes + Outlet</p><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">React</span>, &#123; useState &#125; <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; <span class="title class_">Col</span>, <span class="title class_">Layout</span>, <span class="title class_">MenuProps</span>, <span class="title class_">Row</span> &#125; <span class="keyword">from</span> <span class="string">&#x27;antd&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; <span class="title class_">Menu</span> &#125; <span class="keyword">from</span> <span class="string">&#x27;antd&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; <span class="title class_">Container</span> &#125; <span class="keyword">from</span> <span class="string">&#x27;react-bootstrap&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; <span class="title class_">Link</span>, <span class="title class_">Navigate</span>, <span class="title class_">Outlet</span>, <span class="title class_">Route</span>, <span class="title class_">Routes</span> &#125; <span class="keyword">from</span> <span class="string">&quot;react-router-dom&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="title class_">UserInfo</span> <span class="keyword">from</span> <span class="string">&#x27;./userManage/userInfo.tsx&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="title class_">CaseInfo</span> <span class="keyword">from</span> <span class="string">&#x27;./caseManage/caseInfo.tsx&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="title class_">DiseaseInfo</span> <span class="keyword">from</span> <span class="string">&#x27;./diseaseManage/diseaseInfo.tsx&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="title class_">ExamQuestion</span> <span class="keyword">from</span> <span class="string">&#x27;./examManage/questionManage/examQuestionInfo.tsx&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="title class_">QuestionInsert</span> <span class="keyword">from</span> <span class="string">&#x27;./examManage/questionManage/questionInsert.tsx&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="title class_">TestInfo</span> <span class="keyword">from</span> <span class="string">&#x27;./examManage/testManage/testInfo.tsx&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="title class_">TestInsert</span> <span class="keyword">from</span> <span class="string">&#x27;./examManage/testManage/testInsert.tsx&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="title class_">TestDetail</span> <span class="keyword">from</span> <span class="string">&#x27;./examManage/testManage/testDetail.tsx&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="title class_">TestUpdate</span> <span class="keyword">from</span> <span class="string">&#x27;./examManage/testManage/testUpdate.tsx&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="title class_">CaseInsert</span> <span class="keyword">from</span> <span class="string">&#x27;./caseManage/caseInsert/caseInsert.tsx&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="title class_">CaseUpdate</span> <span class="keyword">from</span> <span class="string">&#x27;./caseManage/caseUpdate.tsx&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="title class_">CaseDetail</span> <span class="keyword">from</span> <span class="string">&#x27;./caseManage/caseDetail.tsx&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="title class_">PaperInfo</span> <span class="keyword">from</span> <span class="string">&#x27;./examManage/paperManage/paperInfo.tsx&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="title class_">PaperDetail</span> <span class="keyword">from</span> <span class="string">&#x27;./examManage/paperManage/paperDetail.tsx&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="title class_">PaperUpdate</span> <span class="keyword">from</span> <span class="string">&#x27;./examManage/paperManage/paperUpdate.tsx&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="title class_">PaperGenerate</span> <span class="keyword">from</span> <span class="string">&#x27;./examManage/questionManage/generatePaper.tsx&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="title class_">ProcessInfo</span> <span class="keyword">from</span> <span class="string">&#x27;./learnManage/processManage/processInfo.tsx&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="title class_">ProcessDetail</span> <span class="keyword">from</span> <span class="string">&#x27;./learnManage/processManage/processDetail.tsx&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="title class_">ProcessInsert</span> <span class="keyword">from</span> <span class="string">&#x27;./learnManage/processManage/processInsert.tsx&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="title class_">ProcessUpdate</span> <span class="keyword">from</span> <span class="string">&#x27;./learnManage/processManage/processUpdate.tsx&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="title class_">RoleInfo</span> <span class="keyword">from</span> <span class="string">&#x27;./learnManage/roleManage/roleInfo.tsx&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="title class_">RoleDetail</span> <span class="keyword">from</span> <span class="string">&#x27;./learnManage/roleManage/roleDetail.tsx&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="title class_">RoleUpdate</span> <span class="keyword">from</span> <span class="string">&#x27;./learnManage/roleManage/roleUpdate.tsx&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="title class_">RoleInsert</span> <span class="keyword">from</span> <span class="string">&#x27;./learnManage/roleManage/roleInsert.tsx&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="title class_">MedicineInfo</span> <span class="keyword">from</span> <span class="string">&#x27;./hospitalManage/medicineManage/medicineManage.tsx&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="title class_">MedicineDetail</span> <span class="keyword">from</span> <span class="string">&#x27;./hospitalManage/medicineManage/medicineDetail.tsx&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="title class_">DepartmentInfo</span> <span class="keyword">from</span> <span class="string">&#x27;./hospitalManage/departmentManage/departmentManage.tsx&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="title class_">VaccineInfo</span> <span class="keyword">from</span> <span class="string">&#x27;./hospitalManage/vaccineManage/vaccineManage.tsx&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="title class_">QuestionDetail</span> <span class="keyword">from</span> <span class="string">&#x27;./examManage/questionManage/questionDetail.tsx&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="title class_">QuestionUpdate</span> <span class="keyword">from</span> <span class="string">&#x27;./examManage/questionManage/questionUpdate.tsx&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="title class_">InspectionInfo</span> <span class="keyword">from</span> <span class="string">&#x27;./hospitalManage/inspectionItemManage/inspectionItemInfo.tsx&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> &#123;</span><br><span class="line">  <span class="title class_">ContainerOutlined</span>,</span><br><span class="line">  <span class="title class_">PieChartOutlined</span>,</span><br><span class="line">  <span class="title class_">UserOutlined</span>,</span><br><span class="line">  <span class="title class_">AppstoreAddOutlined</span>,</span><br><span class="line">  <span class="title class_">HddOutlined</span>,</span><br><span class="line">  <span class="title class_">ContactsOutlined</span>,</span><br><span class="line">  <span class="title class_">MedicineBoxOutlined</span>,</span><br><span class="line">  <span class="title class_">FileTextOutlined</span>,</span><br><span class="line">  <span class="title class_">ReconciliationOutlined</span>,</span><br><span class="line">  <span class="title class_">FolderOpenOutlined</span>,</span><br><span class="line">  <span class="title class_">IdcardOutlined</span>,</span><br><span class="line">  <span class="title class_">TeamOutlined</span>,</span><br><span class="line">  <span class="title class_">PartitionOutlined</span>,</span><br><span class="line">  <span class="title class_">CalendarOutlined</span>,</span><br><span class="line">  <span class="title class_">ProfileOutlined</span></span><br><span class="line">&#125; <span class="keyword">from</span> <span class="string">&#x27;@ant-design/icons&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">MenuItem</span> = <span class="title class_">Required</span>&lt;<span class="title class_">MenuProps</span>&gt;[<span class="string">&#x27;items&#x27;</span>][<span class="built_in">number</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">getItem</span>(<span class="params"></span></span><br><span class="line"><span class="params">  label: React.ReactNode,</span></span><br><span class="line"><span class="params">  key: React.Key,</span></span><br><span class="line"><span class="params">  icon?: React.ReactNode,</span></span><br><span class="line"><span class="params">  children?: MenuItem[],</span></span><br><span class="line"><span class="params">  <span class="keyword">type</span>?: <span class="string">&#x27;group&#x27;</span>,</span></span><br><span class="line"><span class="params"></span>): <span class="title class_">MenuItem</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    key,</span><br><span class="line">    icon,</span><br><span class="line">    children,</span><br><span class="line">    label,</span><br><span class="line">    <span class="keyword">type</span>,</span><br><span class="line">  &#125; <span class="keyword">as</span> <span class="title class_">MenuItem</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="attr">items</span>: <span class="title class_">MenuItem</span>[] = [</span><br><span class="line">  <span class="comment">// item: label key（写路径） icon children type</span></span><br><span class="line">  <span class="title function_">getItem</span>(<span class="language-xml"><span class="tag">&lt;<span class="name">Link</span> <span class="attr">to</span>=<span class="string">&quot;/systemManage/case&quot;</span> <span class="attr">style</span>=<span class="string">&#123;&#123;</span> <span class="attr">textDecoration:</span> &#x27;<span class="attr">none</span>&#x27;, <span class="attr">fontWeight:</span> &#x27;<span class="attr">bolder</span>&#x27;, <span class="attr">fontSize:</span> &#x27;<span class="attr">18px</span>&#x27; &#125;&#125;&gt;</span>病例管理<span class="tag">&lt;/<span class="name">Link</span>&gt;</span></span>, <span class="string">&#x27;/case&#x27;</span>, <span class="language-xml"><span class="tag">&lt;<span class="name">AppstoreAddOutlined</span> /&gt;</span></span>),</span><br><span class="line">  <span class="title function_">getItem</span>(<span class="language-xml"><span class="tag">&lt;<span class="name">Link</span> <span class="attr">to</span>=<span class="string">&quot;/systemManage/disease&quot;</span> <span class="attr">style</span>=<span class="string">&#123;&#123;</span> <span class="attr">textDecoration:</span> &#x27;<span class="attr">none</span>&#x27;, <span class="attr">fontWeight:</span> &#x27;<span class="attr">bolder</span>&#x27;, <span class="attr">fontSize:</span> &#x27;<span class="attr">18px</span>&#x27; &#125;&#125;&gt;</span>病种管理<span class="tag">&lt;/<span class="name">Link</span>&gt;</span></span>, <span class="string">&#x27;/disease&#x27;</span>, <span class="language-xml"><span class="tag">&lt;<span class="name">ContainerOutlined</span> /&gt;</span></span>),</span><br><span class="line">  <span class="title function_">getItem</span>(<span class="language-xml"><span class="tag">&lt;<span class="name">Link</span> <span class="attr">to</span>=<span class="string">&quot;/systemManage/user&quot;</span> <span class="attr">style</span>=<span class="string">&#123;&#123;</span> <span class="attr">textDecoration:</span> &#x27;<span class="attr">none</span>&#x27;, <span class="attr">fontWeight:</span> &#x27;<span class="attr">bolder</span>&#x27;, <span class="attr">fontSize:</span> &#x27;<span class="attr">18px</span>&#x27; &#125;&#125;&gt;</span>用户管理<span class="tag">&lt;/<span class="name">Link</span>&gt;</span></span>, <span class="string">&#x27;/user&#x27;</span>, <span class="language-xml"><span class="tag">&lt;<span class="name">UserOutlined</span> /&gt;</span></span>),</span><br><span class="line">  <span class="title function_">getItem</span>(<span class="string">&#x27;考试管理&#x27;</span>, <span class="string">&#x27;exam&#x27;</span>, <span class="language-xml"><span class="tag">&lt;<span class="name">ReconciliationOutlined</span> /&gt;</span></span>, [</span><br><span class="line">    <span class="title function_">getItem</span>(<span class="language-xml"><span class="tag">&lt;<span class="name">Link</span> <span class="attr">to</span>=<span class="string">&quot;/systemManage/exercise&quot;</span> <span class="attr">style</span>=<span class="string">&#123;&#123;</span> <span class="attr">textDecoration:</span> &#x27;<span class="attr">none</span>&#x27; &#125;&#125;&gt;</span>考题管理<span class="tag">&lt;/<span class="name">Link</span>&gt;</span></span>, <span class="string">&#x27;/exercise&#x27;</span>, <span class="language-xml"><span class="tag">&lt;<span class="name">FolderOpenOutlined</span> /&gt;</span></span>),</span><br><span class="line">    <span class="title function_">getItem</span>(<span class="language-xml"><span class="tag">&lt;<span class="name">Link</span> <span class="attr">to</span>=<span class="string">&quot;/systemManage/paper&quot;</span> <span class="attr">style</span>=<span class="string">&#123;&#123;</span> <span class="attr">textDecoration:</span> &#x27;<span class="attr">none</span>&#x27; &#125;&#125;&gt;</span>试卷管理<span class="tag">&lt;/<span class="name">Link</span>&gt;</span></span>, <span class="string">&#x27;/paper&#x27;</span>, <span class="language-xml"><span class="tag">&lt;<span class="name">FileTextOutlined</span> /&gt;</span></span>),</span><br><span class="line">    <span class="title function_">getItem</span>(<span class="language-xml"><span class="tag">&lt;<span class="name">Link</span> <span class="attr">to</span>=<span class="string">&quot;/systemManage/test&quot;</span> <span class="attr">style</span>=<span class="string">&#123;&#123;</span> <span class="attr">textDecoration:</span> &#x27;<span class="attr">none</span>&#x27; &#125;&#125;&gt;</span>场次管理<span class="tag">&lt;/<span class="name">Link</span>&gt;</span></span>, <span class="string">&#x27;/test&#x27;</span>, <span class="language-xml"><span class="tag">&lt;<span class="name">CalendarOutlined</span> /&gt;</span></span>)</span><br><span class="line">  ]),</span><br><span class="line">  <span class="title function_">getItem</span>(<span class="string">&#x27;医院管理&#x27;</span>, <span class="string">&#x27;hospital&#x27;</span>, <span class="language-xml"><span class="tag">&lt;<span class="name">PieChartOutlined</span> /&gt;</span></span>, [</span><br><span class="line">    <span class="title function_">getItem</span>(<span class="language-xml"><span class="tag">&lt;<span class="name">Link</span> <span class="attr">to</span>=<span class="string">&quot;/systemManage/department&quot;</span> <span class="attr">style</span>=<span class="string">&#123;&#123;</span> <span class="attr">textDecoration:</span> &#x27;<span class="attr">none</span>&#x27; &#125;&#125;&gt;</span>科室管理<span class="tag">&lt;/<span class="name">Link</span>&gt;</span></span>, <span class="string">&#x27;/department&#x27;</span>, <span class="language-xml"><span class="tag">&lt;<span class="name">ContactsOutlined</span> /&gt;</span></span>),</span><br><span class="line">    <span class="title function_">getItem</span>(<span class="language-xml"><span class="tag">&lt;<span class="name">Link</span> <span class="attr">to</span>=<span class="string">&quot;/systemManage/medicine&quot;</span> <span class="attr">style</span>=<span class="string">&#123;&#123;</span> <span class="attr">textDecoration:</span> &#x27;<span class="attr">none</span>&#x27; &#125;&#125;&gt;</span>药品管理<span class="tag">&lt;/<span class="name">Link</span>&gt;</span></span>, <span class="string">&#x27;/medicine&#x27;</span>, <span class="language-xml"><span class="tag">&lt;<span class="name">HddOutlined</span> /&gt;</span></span>),</span><br><span class="line">    <span class="title function_">getItem</span>(<span class="language-xml"><span class="tag">&lt;<span class="name">Link</span> <span class="attr">to</span>=<span class="string">&quot;/systemManage/vaccine&quot;</span> <span class="attr">style</span>=<span class="string">&#123;&#123;</span> <span class="attr">textDecoration:</span> &#x27;<span class="attr">none</span>&#x27; &#125;&#125;&gt;</span>疫苗管理<span class="tag">&lt;/<span class="name">Link</span>&gt;</span></span>, <span class="string">&#x27;/vaccine&#x27;</span>, <span class="language-xml"><span class="tag">&lt;<span class="name">MedicineBoxOutlined</span> /&gt;</span></span>),</span><br><span class="line">    <span class="title function_">getItem</span>(<span class="language-xml"><span class="tag">&lt;<span class="name">Link</span> <span class="attr">to</span>=<span class="string">&quot;/systemManage/inspection&quot;</span> <span class="attr">style</span>=<span class="string">&#123;&#123;</span> <span class="attr">textDecoration:</span> &#x27;<span class="attr">none</span>&#x27; &#125;&#125;&gt;</span>检查管理<span class="tag">&lt;/<span class="name">Link</span>&gt;</span></span>, <span class="string">&#x27;/inspection&#x27;</span>, <span class="language-xml"><span class="tag">&lt;<span class="name">ProfileOutlined</span> /&gt;</span></span>),</span><br><span class="line"></span><br><span class="line">  ]),</span><br><span class="line">  <span class="title function_">getItem</span>(<span class="string">&#x27;职能学习管理&#x27;</span>, <span class="string">&#x27;study&#x27;</span>, <span class="language-xml"><span class="tag">&lt;<span class="name">IdcardOutlined</span> /&gt;</span></span>, [</span><br><span class="line">    <span class="title function_">getItem</span>(<span class="language-xml"><span class="tag">&lt;<span class="name">Link</span> <span class="attr">to</span>=<span class="string">&quot;/systemManage/role&quot;</span> <span class="attr">style</span>=<span class="string">&#123;&#123;</span> <span class="attr">textDecoration:</span> &#x27;<span class="attr">none</span>&#x27; &#125;&#125;&gt;</span>岗位角色管理<span class="tag">&lt;/<span class="name">Link</span>&gt;</span></span>, <span class="string">&#x27;/role&#x27;</span>, <span class="language-xml"><span class="tag">&lt;<span class="name">TeamOutlined</span> /&gt;</span></span>),</span><br><span class="line">    <span class="title function_">getItem</span>(<span class="language-xml"><span class="tag">&lt;<span class="name">Link</span> <span class="attr">to</span>=<span class="string">&quot;/systemManage/process&quot;</span> <span class="attr">style</span>=<span class="string">&#123;&#123;</span> <span class="attr">textDecoration:</span> &#x27;<span class="attr">none</span>&#x27; &#125;&#125;&gt;</span>流程管理<span class="tag">&lt;/<span class="name">Link</span>&gt;</span></span>, <span class="string">&#x27;/process&#x27;</span>, <span class="language-xml"><span class="tag">&lt;<span class="name">PartitionOutlined</span> /&gt;</span></span>),</span><br><span class="line">  ])</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line"><span class="comment">// submenu keys of first level</span></span><br><span class="line"><span class="keyword">const</span> rootSubmenuKeys = [<span class="string">&#x27;/case&#x27;</span>, <span class="string">&#x27;/disease&#x27;</span>, <span class="string">&#x27;/user&#x27;</span>, <span class="string">&#x27;exam&#x27;</span>, <span class="string">&#x27;hospital&#x27;</span>, <span class="string">&#x27;study&#x27;</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">SystemManage</span>(<span class="params"></span>) &#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 布局相关</span></span><br><span class="line">  <span class="keyword">const</span> &#123; <span class="title class_">Content</span>, <span class="title class_">Sider</span> &#125; = <span class="title class_">Layout</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> [openKeys, setOpenKeys] = <span class="title function_">useState</span>([<span class="string">&#x27;/case&#x27;</span>]);</span><br><span class="line">  <span class="keyword">const</span> <span class="attr">onOpenChange</span>: <span class="title class_">MenuProps</span>[<span class="string">&#x27;onOpenChange&#x27;</span>] = <span class="function">(<span class="params">keys</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> latestOpenKey = keys.<span class="title function_">find</span>(<span class="function">(<span class="params">key</span>) =&gt;</span> openKeys.<span class="title function_">indexOf</span>(key) === -<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span> (rootSubmenuKeys.<span class="title function_">indexOf</span>(latestOpenKey!) === -<span class="number">1</span>) &#123;</span><br><span class="line">      <span class="title function_">setOpenKeys</span>(keys);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="title function_">setOpenKeys</span>(latestOpenKey ? [latestOpenKey] : []);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">Layout</span> <span class="attr">className</span>=<span class="string">&#x27;system-manage&#x27;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">Sider</span> <span class="attr">className</span>=<span class="string">&#x27;system-manage-sider &#x27;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">Menu</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">          <span class="attr">defaultSelectedKeys</span>=<span class="string">&#123;[</span>&#x27;/<span class="attr">case</span>&#x27;]&#125;</span></span></span><br><span class="line"><span class="tag"><span class="language-xml">          <span class="attr">mode</span>=<span class="string">&quot;inline&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">          <span class="attr">items</span>=<span class="string">&#123;items&#125;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">          <span class="attr">openKeys</span>=<span class="string">&#123;openKeys&#125;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">          <span class="attr">onOpenChange</span>=<span class="string">&#123;onOpenChange&#125;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">          <span class="attr">style</span>=<span class="string">&#123;&#123;</span> <span class="attr">width:</span> &#x27;<span class="attr">200px</span>&#x27;, <span class="attr">borderRadius:</span> <span class="attr">10</span>, <span class="attr">opacity:</span> <span class="attr">1</span>, <span class="attr">height:</span> &#x27;<span class="attr">660px</span>&#x27; &#125;&#125;&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;/<span class="name">Menu</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;/<span class="name">Sider</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">Layout</span> <span class="attr">className</span>=<span class="string">&quot;system-manage-right&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">Content</span> &gt;</span></span></span><br><span class="line"><span class="language-xml">          <span class="tag">&lt;<span class="name">Routes</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;<span class="name">Route</span> <span class="attr">path</span>=<span class="string">&quot;case&quot;</span> <span class="attr">element</span>=<span class="string">&#123;</span>&lt;<span class="attr">CaseInfo</span> /&gt;</span>&#125; /&gt;</span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;<span class="name">Route</span> <span class="attr">path</span>=<span class="string">&quot;disease&quot;</span> <span class="attr">element</span>=<span class="string">&#123;</span>&lt;<span class="attr">DiseaseInfo</span> /&gt;</span>&#125; /&gt;</span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;<span class="name">Route</span> <span class="attr">path</span>=<span class="string">&quot;user&quot;</span> <span class="attr">element</span>=<span class="string">&#123;</span>&lt;<span class="attr">UserInfo</span> /&gt;</span>&#125; /&gt;</span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;<span class="name">Route</span> <span class="attr">path</span>=<span class="string">&quot;exercise&quot;</span> <span class="attr">element</span>=<span class="string">&#123;</span>&lt;<span class="attr">ExamQuestion</span> /&gt;</span>&#125; /&gt;</span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;<span class="name">Route</span> <span class="attr">path</span>=<span class="string">&quot;exercise/detail/:questionId&quot;</span> <span class="attr">element</span>=<span class="string">&#123;</span>&lt;<span class="attr">QuestionDetail</span> /&gt;</span>&#125; /&gt;</span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;<span class="name">Route</span> <span class="attr">path</span>=<span class="string">&quot;exercise/update/:questionId&quot;</span> <span class="attr">element</span>=<span class="string">&#123;</span>&lt;<span class="attr">QuestionUpdate</span> /&gt;</span>&#125; /&gt;</span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;<span class="name">Route</span> <span class="attr">path</span>=<span class="string">&quot;exercise/generate&quot;</span> <span class="attr">element</span>=<span class="string">&#123;</span>&lt;<span class="attr">PaperGenerate</span> /&gt;</span>&#125; /&gt;</span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;<span class="name">Route</span> <span class="attr">path</span>=<span class="string">&quot;paper&quot;</span> <span class="attr">element</span>=<span class="string">&#123;</span>&lt;<span class="attr">PaperInfo</span> /&gt;</span>&#125; /&gt;</span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;<span class="name">Route</span> <span class="attr">path</span>=<span class="string">&quot;paper/detail/:paper_id&quot;</span> <span class="attr">element</span>=<span class="string">&#123;</span>&lt;<span class="attr">PaperDetail</span> /&gt;</span>&#125; /&gt;</span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;<span class="name">Route</span> <span class="attr">path</span>=<span class="string">&quot;paper/update/:paper_id&quot;</span> <span class="attr">element</span>=<span class="string">&#123;</span>&lt;<span class="attr">PaperUpdate</span> /&gt;</span>&#125; /&gt;</span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;<span class="name">Route</span> <span class="attr">path</span>=<span class="string">&quot;test&quot;</span> <span class="attr">element</span>=<span class="string">&#123;</span>&lt;<span class="attr">TestInfo</span> /&gt;</span>&#125; /&gt;</span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;<span class="name">Route</span> <span class="attr">path</span>=<span class="string">&quot;test/detail/:testId&quot;</span> <span class="attr">element</span>=<span class="string">&#123;</span>&lt;<span class="attr">TestDetail</span> /&gt;</span>&#125; /&gt;</span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;<span class="name">Route</span> <span class="attr">path</span>=<span class="string">&quot;test/update/:testId&quot;</span> <span class="attr">element</span>=<span class="string">&#123;</span>&lt;<span class="attr">TestUpdate</span> /&gt;</span>&#125; /&gt;</span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;<span class="name">Route</span> <span class="attr">path</span>=<span class="string">&quot;test/insert&quot;</span> <span class="attr">element</span>=<span class="string">&#123;</span>&lt;<span class="attr">TestInsert</span> /&gt;</span>&#125; /&gt;</span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;<span class="name">Route</span> <span class="attr">path</span>=<span class="string">&quot;role&quot;</span> <span class="attr">element</span>=<span class="string">&#123;</span>&lt;<span class="attr">RoleInfo</span> /&gt;</span>&#125; /&gt;</span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;<span class="name">Route</span> <span class="attr">path</span>=<span class="string">&quot;role/insert&quot;</span> <span class="attr">element</span>=<span class="string">&#123;</span>&lt;<span class="attr">RoleInsert</span> /&gt;</span>&#125; /&gt;</span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;<span class="name">Route</span> <span class="attr">path</span>=<span class="string">&quot;role/detail/:actorId&quot;</span> <span class="attr">element</span>=<span class="string">&#123;</span>&lt;<span class="attr">RoleDetail</span> /&gt;</span>&#125; /&gt;</span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;<span class="name">Route</span> <span class="attr">path</span>=<span class="string">&quot;role/update/:actorId&quot;</span> <span class="attr">element</span>=<span class="string">&#123;</span>&lt;<span class="attr">RoleUpdate</span> /&gt;</span>&#125; /&gt;</span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;<span class="name">Route</span> <span class="attr">path</span>=<span class="string">&quot;department&quot;</span> <span class="attr">element</span>=<span class="string">&#123;</span>&lt;<span class="attr">DepartmentInfo</span> /&gt;</span>&#125; /&gt;</span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;<span class="name">Route</span> <span class="attr">path</span>=<span class="string">&quot;medicine&quot;</span> <span class="attr">element</span>=<span class="string">&#123;</span>&lt;<span class="attr">MedicineInfo</span> /&gt;</span>&#125; /&gt;</span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;<span class="name">Route</span> <span class="attr">path</span>=<span class="string">&quot;medicine/detail/:id&quot;</span> <span class="attr">element</span>=<span class="string">&#123;</span>&lt;<span class="attr">MedicineDetail</span> /&gt;</span>&#125; /&gt;</span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;<span class="name">Route</span> <span class="attr">path</span>=<span class="string">&quot;vaccine&quot;</span> <span class="attr">element</span>=<span class="string">&#123;</span>&lt;<span class="attr">VaccineInfo</span> /&gt;</span>&#125; /&gt;</span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;<span class="name">Route</span> <span class="attr">path</span>=<span class="string">&quot;inspection&quot;</span> <span class="attr">element</span>=<span class="string">&#123;</span>&lt;<span class="attr">InspectionInfo</span> /&gt;</span>&#125; /&gt;</span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;<span class="name">Route</span> <span class="attr">path</span>=<span class="string">&quot;process&quot;</span> <span class="attr">element</span>=<span class="string">&#123;</span>&lt;<span class="attr">ProcessInfo</span> /&gt;</span>&#125; /&gt;</span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;<span class="name">Route</span> <span class="attr">path</span>=<span class="string">&quot;process/insert&quot;</span> <span class="attr">element</span>=<span class="string">&#123;</span>&lt;<span class="attr">ProcessInsert</span> /&gt;</span>&#125; /&gt;</span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;<span class="name">Route</span> <span class="attr">path</span>=<span class="string">&quot;process/detail/:processId&quot;</span> <span class="attr">element</span>=<span class="string">&#123;</span>&lt;<span class="attr">ProcessDetail</span> /&gt;</span>&#125; /&gt;</span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;<span class="name">Route</span> <span class="attr">path</span>=<span class="string">&quot;process/update/:processId&quot;</span> <span class="attr">element</span>=<span class="string">&#123;</span>&lt;<span class="attr">ProcessUpdate</span> /&gt;</span>&#125; /&gt;</span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;<span class="name">Route</span> <span class="attr">path</span>=<span class="string">&quot;&quot;</span> <span class="attr">element</span>=<span class="string">&#123;</span>&lt;<span class="attr">Navigate</span> <span class="attr">to</span>=<span class="string">&quot;/systemManage/case&quot;</span> /&gt;</span>&#125; /&gt;</span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;<span class="name">Route</span> <span class="attr">path</span>=<span class="string">&quot;case/insert&quot;</span> <span class="attr">element</span>=<span class="string">&#123;</span>&lt;<span class="attr">CaseInsert</span> /&gt;</span>&#125; /&gt;</span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;<span class="name">Route</span> <span class="attr">path</span>=<span class="string">&quot;case/detail/:case_id&quot;</span> <span class="attr">element</span>=<span class="string">&#123;</span>&lt;<span class="attr">CaseDetail</span> /&gt;</span>&#125; /&gt;</span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;<span class="name">Route</span> <span class="attr">path</span>=<span class="string">&quot;case/update/:case_id&quot;</span> <span class="attr">element</span>=<span class="string">&#123;</span>&lt;<span class="attr">CaseUpdate</span> /&gt;</span>&#125; /&gt;</span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;<span class="name">Route</span> <span class="attr">path</span>=<span class="string">&quot;exercise/insert&quot;</span> <span class="attr">element</span>=<span class="string">&#123;</span>&lt;<span class="attr">QuestionInsert</span> /&gt;</span>&#125; /&gt;</span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;<span class="name">Route</span> <span class="attr">path</span>=<span class="string">&quot;paper/insert&quot;</span> <span class="attr">element</span>=<span class="string">&#123;</span>&lt;<span class="attr">TestInsert</span> /&gt;</span>&#125; /&gt;</span></span><br><span class="line"><span class="language-xml"></span></span><br><span class="line"><span class="language-xml">          <span class="tag">&lt;/<span class="name">Routes</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"></span></span><br><span class="line"><span class="language-xml">          <span class="tag">&lt;<span class="name">Outlet</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml"></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;/<span class="name">Content</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;/<span class="name">Layout</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    &lt;/Layout &gt;</span></span><br><span class="line"><span class="language-xml"></span></span><br><span class="line"><span class="language-xml"></span></span><br><span class="line"><span class="language-xml">  );</span></span><br><span class="line"><span class="language-xml">&#125;;</span></span><br><span class="line"><span class="language-xml"></span></span><br><span class="line"><span class="language-xml">export default SystemManage;</span></span><br></pre></td></tr></table></figure><h2 id="Message全局提示"><a href="#Message全局提示" class="headerlink" title="Message全局提示"></a>Message全局提示</h2><p>全局展示操作反馈信息。</p><ul><li>可提供成功、警告和错误等反馈信息。</li><li>顶部居中显示并自动消失，是一种不打断用户操作的轻量级提示方式。</li></ul><p>可以直接： message.success(‘添加成功！’) </p><p>message.error(‘添加失败’)</p><p>message.warning(‘警告！’)</p><p>原因竟然是忘记放{contextHolder}进return里面了，虽然也不知道原理是啥（。</p><img src="/.com//03/03/React/image-20230328114544726.png" class title="image-20230328114544726"><h2 id="Form表单"><a href="#Form表单" class="headerlink" title="Form表单"></a>Form表单</h2><h3 id="react-antd动态表单以及数组对象示例"><a href="#react-antd动态表单以及数组对象示例" class="headerlink" title="react+antd动态表单以及数组对象示例"></a>react+antd动态表单以及数组对象示例</h3><p><a href="https://blog.csdn.net/feinifi/article/details/107706303">https://blog.csdn.net/feinifi/article/details/107706303</a></p><p>[‘name’, index,]</p><h1 id="React-中使用-REST-API"><a href="#React-中使用-REST-API" class="headerlink" title="React 中使用 REST API"></a>React 中使用 REST API</h1><p>REST是 REpresentational State Transfer（表现层状态转化）</p><p>当通过 REST API 发出请求时，它会将资源的当前状态的表现发送给请求者或者终点。状态表现通常采用 JSON 格式（JSON 即 JavaScript Object Notation），或者 XML 和 HTML 格式。</p><p><a href="https://www.freecodecamp.org/chinese/news/how-to-consume-rest-apis-in-react/">如何在 React 中使用 REST API——初学者指南</a></p><h2 id="GET请求"><a href="#GET请求" class="headerlink" title="GET请求"></a>GET请求</h2><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">React</span>, &#123; useState, useEffect &#125; <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">App</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">   <span class="keyword">const</span> [posts, setPosts] = <span class="title function_">useState</span>([]);</span><br><span class="line">   <span class="title function_">useEffect</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="title function_">fetch</span>(<span class="string">&#x27;https://jsonplaceholder.typicode.com/posts?_limit=10&#x27;</span>)</span><br><span class="line">         .<span class="title function_">then</span>(<span class="function">(<span class="params">response</span>) =&gt;</span> response.<span class="title function_">json</span>())</span><br><span class="line">         .<span class="title function_">then</span>(<span class="function">(<span class="params">data</span>) =&gt;</span> &#123;</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(data);</span><br><span class="line">            <span class="title function_">setPosts</span>(data);</span><br><span class="line">         &#125;)</span><br><span class="line">         .<span class="title function_">catch</span>(<span class="function">(<span class="params">err</span>) =&gt;</span> &#123;</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(err.<span class="property">message</span>);</span><br><span class="line">         &#125;);</span><br><span class="line">   &#125;, []);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> (</span><br><span class="line">   <span class="comment">// ... 在这里使用数据</span></span><br><span class="line">);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="DELETE请求"><a href="#DELETE请求" class="headerlink" title="DELETE请求"></a>DELETE请求</h2><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">deletePost</span> = <span class="keyword">async</span> (<span class="params">id</span>) =&gt; &#123;</span><br><span class="line">    <span class="keyword">await</span> <span class="title function_">fetch</span>(<span class="string">`https://jsonplaceholder.typicode.com/posts/<span class="subst">$&#123;id&#125;</span>`</span>, &#123;</span><br><span class="line">       <span class="attr">method</span>: <span class="string">&#x27;DELETE&#x27;</span>,</span><br><span class="line">    &#125;).<span class="title function_">then</span>(<span class="function">(<span class="params">response</span>) =&gt;</span> &#123;</span><br><span class="line">       <span class="keyword">if</span> (response.<span class="property">status</span> === <span class="number">200</span>) &#123;</span><br><span class="line">          <span class="title function_">setPosts</span>(</span><br><span class="line">             posts.<span class="title function_">filter</span>(<span class="function">(<span class="params">post</span>) =&gt;</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> post.<span class="property">id</span> !== id;</span><br><span class="line">             &#125;)</span><br><span class="line">          );</span><br><span class="line">       &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="keyword">return</span>;</span><br><span class="line">       &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="POST请求"><a href="#POST请求" class="headerlink" title="POST请求"></a>POST请求</h2><p>可以使用HTTP<code>POST</code>方法从终点发送数据。该方法和<code>GET</code>请求类似，主要的区别在于需要<strong>添加方法名称以及两个额外的参数</strong>到选填对象中：</p><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">addPosts</span> = <span class="keyword">async</span> (<span class="params">title, body</span>) =&gt; &#123;</span><br><span class="line"><span class="keyword">await</span> <span class="title function_">fetch</span>(<span class="string">&#x27;https://jsonplaceholder.typicode.com/posts&#x27;</span>, &#123;</span><br><span class="line"><span class="attr">method</span>: <span class="string">&#x27;POST&#x27;</span>,</span><br><span class="line"><span class="attr">body</span>: <span class="title class_">JSON</span>.<span class="title function_">stringify</span>(&#123;</span><br><span class="line">   <span class="attr">title</span>: title,</span><br><span class="line">   <span class="attr">body</span>: body,</span><br><span class="line">   <span class="attr">userId</span>: <span class="title class_">Math</span>.<span class="title function_">random</span>().<span class="title function_">toString</span>(<span class="number">36</span>).<span class="title function_">slice</span>(<span class="number">2</span>),</span><br><span class="line">&#125;),</span><br><span class="line"><span class="attr">headers</span>: &#123;</span><br><span class="line">   <span class="string">&#x27;Content-type&#x27;</span>: <span class="string">&#x27;application/json; charset=UTF-8&#x27;</span>,</span><br><span class="line">&#125;,</span><br><span class="line">&#125;)</span><br><span class="line">.<span class="title function_">then</span>(<span class="function">(<span class="params">response</span>) =&gt;</span> response.<span class="title function_">json</span>())</span><br><span class="line">.<span class="title function_">then</span>(<span class="function">(<span class="params">data</span>) =&gt;</span> &#123;</span><br><span class="line">   <span class="title function_">setPosts</span>(<span class="function">(<span class="params">posts</span>) =&gt;</span> [data, ...posts]);</span><br><span class="line">   <span class="title function_">setTitle</span>(<span class="string">&#x27;&#x27;</span>);</span><br><span class="line">   <span class="title function_">setBody</span>(<span class="string">&#x27;&#x27;</span>);</span><br><span class="line">&#125;)</span><br><span class="line">.<span class="title function_">catch</span>(<span class="function">(<span class="params">err</span>) =&gt;</span> &#123;</span><br><span class="line">   <span class="variable language_">console</span>.<span class="title function_">log</span>(err.<span class="property">message</span>);</span><br><span class="line">&#125;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><code>body</code>部分的数据是我们想要传给 API 的数据，在传输给服务器之前必须先字符串化。</p><p><code>header</code>告知数据类型，通常和我们使用的 REST API 一致的类型。同时我们也使用状态保存新的数据，并将剩下的数据分配到上文所述的循环数组中。</p><h2 id="async-x2F-await"><a href="#async-x2F-await" class="headerlink" title="async&#x2F;await"></a><strong>async&#x2F;await</strong></h2><p>可以以一种方式帮助你像编写同步代码那样的编写异步代码。</p><blockquote><p>这个需要深入学习一下原理。</p></blockquote><h2 id="发送网络请求"><a href="#发送网络请求" class="headerlink" title="发送网络请求"></a>发送网络请求</h2><p>CORS跨域问题</p><p>在 React.js 中使用 Fetch API 发起跨域请求，需要使用 <strong>no-cors 模式</strong>。使用 no-cors 模式时，浏览器会发送一个简单的跨域请求，并允许服务器返回一个简单的响应。如果服务器在响应中包含了一些不允许的内容（例如自定义的头信息），则浏览器会抛出一个错误。因此，在使用 no-cors 模式时，需要注意返回的响应内容必须是简单的，不能包含自定义头信息等复杂内容。</p><p>需要注意的是，<em>在使用 <code>no-cors</code> 模式时，无法访问响应的内容，只能访问响应的基本信息（例如状态码、响应头等）</em>。如果您需要访问响应的内容，可以考虑使用代理或者 JSONP 等其他技术。</p><p>然后<code>重新运行</code>，否则会报如下错误：修改了 package.json 需要重启</p><h1 id="React父子传递参数的三种方式"><a href="#React父子传递参数的三种方式" class="headerlink" title="React父子传递参数的三种方式"></a>React父子传递参数的三种方式</h1><p><a href="https://blog.csdn.net/weixin_44999830/article/details/106096835">https://blog.csdn.net/weixin_44999830/article/details/106096835</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;React：用于构建用户界面的JavaScript库。&lt;/p&gt;
&lt;p&gt;是一个将数据渲染为HTML视图的开源JavaScript库。&lt;/p&gt;
&lt;h1 id=&quot;参考教程&quot;&gt;&lt;a href=&quot;#参考教程&quot; class=&quot;headerlink&quot; title=&quot;参考教程&quot;&gt;&lt;/a&gt;参</summary>
      
    
    
    
    <category term="Study" scheme="http://example.com/categories/Study/"/>
    
    
    <category term="FrontEnd" scheme="http://example.com/tags/FrontEnd/"/>
    
    <category term="React" scheme="http://example.com/tags/React/"/>
    
  </entry>
  
  <entry>
    <title>Vue前端开发</title>
    <link href="http://example.com/2023/03/02/Vue%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/"/>
    <id>http://example.com/2023/03/02/Vue%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/</id>
    <published>2023-03-02T02:37:39.000Z</published>
    <updated>2023-07-09T16:22:45.710Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://www.bmabk.com/index.php/post/44373.html">https://www.bmabk.com/index.php/post/44373.html</a></p><p>使用Vue-CLI构建项目</p><p>npm run dev</p><img src="/.com//03/02/Vue%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/image-20230302111314852.png" class title="image-20230302111314852">]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;a href=&quot;https://www.bmabk.com/index.php/post/44373.html&quot;&gt;https://www.bmabk.com/index.php/post/44373.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;使用Vue-CLI构建项目&lt;/p&gt;
&lt;p</summary>
      
    
    
    
    <category term="Study" scheme="http://example.com/categories/Study/"/>
    
    
    <category term="FrontEnd" scheme="http://example.com/tags/FrontEnd/"/>
    
    <category term="Vue" scheme="http://example.com/tags/Vue/"/>
    
  </entry>
  
  <entry>
    <title>MySQL教程</title>
    <link href="http://example.com/2023/02/12/MySQL%E6%95%99%E7%A8%8B/"/>
    <id>http://example.com/2023/02/12/MySQL%E6%95%99%E7%A8%8B/</id>
    <published>2023-02-12T12:36:19.000Z</published>
    <updated>2023-07-09T16:04:18.999Z</updated>
    
    <content type="html"><![CDATA[<p>MySQL 是最流行的数据库之一，是一个免费开源的关系型数据库管理系统，但也不意味着该数据库是完全免费的。MySQL 由瑞典 MySQL AB 公司开发，目前属于 Oracle 公司。MySQL 适合中小型软件，被个人用户以及中小企业青睐。</p><h1 id="数据库基础"><a href="#数据库基础" class="headerlink" title="数据库基础"></a>数据库基础</h1><p>数据库指的是以一定方式储存在一起、能为多个用户共享、具有尽可能小的冗余度、与应用程序彼此独立的数据集合。简单来说可视为电子化的文件柜——存储电子文件的处所，用户可以对文件中的数据运行新增、截取、更新、删除等操作。</p><p>RDBMS即关系数据库管理系统(Relational Database Management System)的特点：</p><ol><li>数据以<strong>表格</strong>的形式出现</li><li>每行为各种记录名称</li><li>每列为记录名称所对应的数据域</li><li>许多的行和列组成一张表单</li><li>若干的表单组成database</li></ol><h2 id="数据表"><a href="#数据表" class="headerlink" title="数据表"></a>数据表</h2><p>数据表是关系数据库中一个非常重要的对象，是其它对象的基础，也是一系列<strong>二维数组的集合</strong>，用来存储、操作数据的逻辑结构。</p><h3 id="主键"><a href="#主键" class="headerlink" title="主键"></a>主键</h3><p>主键（primary key或unique key），又称主码，数据库表中对储存数据对象予以唯一和完整标识的数据列或属性的组合。一个数据列只能有一个主键，且主键的取值不能缺失，即不能为空值（Null）。unique 可空，可以在一个表里的一个或多个字段定义；primary key 不可空不可重复，在一个表里可以定义联合主键；unique索引和primary索引区别:</p><h2 id="SQL语言"><a href="#SQL语言" class="headerlink" title="SQL语言"></a>SQL语言</h2><p>SQL，(Structured Query Language)即结构化查询语言，数据库管理系统专门通过SQL语言来管理数据库中的数据，与数据库通信。</p><h3 id="SQL的优点"><a href="#SQL的优点" class="headerlink" title="SQL的优点:"></a>SQL的优点:</h3><ul><li>SQL不是某个特定数据库供应商专有的语言。几乎所有重要的DBMS都支持SQL，所以，学习此语言使你几乎能与所有数据库打交道。</li><li>SQL简单易学。它的语句全都是由描述性很强的英语单词组成，而且这些单词的数目不多。</li><li>SQL尽管看上去很简单，但它实际上是一种强有力的语言，灵活使用其语言元素，可以进行非常复杂和高级的数据库操作。</li></ul><h1 id="数据库的基本操作"><a href="#数据库的基本操作" class="headerlink" title="数据库的基本操作"></a>数据库的基本操作</h1><h2 id="连接数据库"><a href="#连接数据库" class="headerlink" title="连接数据库"></a>连接数据库</h2><p>命令行启动</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mysql –u用户名 [–h主机名或者IP地址,-P端口号] –p密码</span><br><span class="line">mysql -uroot -p</span><br></pre></td></tr></table></figure><p>图形化工具 navicat</p><h2 id="查看选择数据库"><a href="#查看选择数据库" class="headerlink" title="查看选择数据库"></a>查看选择数据库</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; SHOW DATABASES;</span><br><span class="line">+--------------------+</span><br><span class="line">| Database           |</span><br><span class="line">|--------------------|</span><br><span class="line">| information_schema |</span><br><span class="line">| mysql              |</span><br><span class="line">| performance_schema |</span><br><span class="line">| sys                |</span><br><span class="line">| test               |</span><br><span class="line">+--------------------+</span><br><span class="line">5 rows in set</span><br><span class="line">Time: 0.031s</span><br><span class="line"></span><br><span class="line">mysql&gt; USE test;</span><br><span class="line">You are now connected to database &quot;test&quot; as user &quot;root&quot;</span><br><span class="line">Time: 0.003s</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="创建数据库"><a href="#创建数据库" class="headerlink" title="创建数据库"></a>创建数据库</h2><h3 id="创建一个已知不存在的数据库"><a href="#创建一个已知不存在的数据库" class="headerlink" title="创建一个已知不存在的数据库"></a>创建一个已知不存在的数据库</h3><p>连接好 MySQL 之后运行下面SQL语句创建数据库：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CREATE DATABASE test;</span><br></pre></td></tr></table></figure><p>查询数据</p><p>WHERE子句</p><p>UPDATE更新</p><p>排序</p><p>分组</p><p>连接</p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="https://wangchujiang.com/mysql-tutorial/">https://wangchujiang.com/mysql-tutorial/</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;MySQL 是最流行的数据库之一，是一个免费开源的关系型数据库管理系统，但也不意味着该数据库是完全免费的。MySQL 由瑞典 MySQL AB 公司开发，目前属于 Oracle 公司。MySQL 适合中小型软件，被个人用户以及中小企业青睐。&lt;/p&gt;
&lt;h1 id=&quot;数据库基</summary>
      
    
    
    
    <category term="Study" scheme="http://example.com/categories/Study/"/>
    
    
    <category term="Database" scheme="http://example.com/tags/Database/"/>
    
    <category term="SQL" scheme="http://example.com/tags/SQL/"/>
    
  </entry>
  
  <entry>
    <title>《Maven实战》阅读笔记</title>
    <link href="http://example.com/2023/01/22/%E3%80%8AMaven%E5%AE%9E%E6%88%98%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/"/>
    <id>http://example.com/2023/01/22/%E3%80%8AMaven%E5%AE%9E%E6%88%98%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/</id>
    <published>2023-01-22T07:40:48.000Z</published>
    <updated>2023-07-09T18:45:20.420Z</updated>
    
    <content type="html"><![CDATA[<h1 id="第一章-Maven简介"><a href="#第一章-Maven简介" class="headerlink" title="第一章 Maven简介"></a>第一章 Maven简介</h1><p>Maven: 跨平台的自动化构建工具</p><h1 id="第五章-坐标和依赖"><a href="#第五章-坐标和依赖" class="headerlink" title="第五章 坐标和依赖"></a>第五章 坐标和依赖</h1><p>Maven坐标为各种构件引入了秩序，任何一个构件都必须明确定义自己的坐标，而一.组Maven坐标是通过一些元素定义的，它们是groupld、artifactId、version、packaging、classifier。坐标定义如下:</p>依赖范围<p>依赖范围就是用来控制依赖与这三种elasspath(编译classpath.测试classpath.运行<br>classpath)的关系，Maven 有以下几种依赖范围:</p><ul><li>compile:编译依赖范围。如果没有指定，就会默认使用该依赖范围。使用此依赖范围的Maven依赖，对于编译、测试、运行三种classpath 都有效。典型的例子是spring-core，<strong>在编译、测试和运行的时候都需要使用该依赖</strong>。</li><li>test:测试依赖范围。使用此依赖范围的Maven依赖，只对于测试classpath有效，在编译主代码或者运行项目的使用时将无法使用此类依赖。典型的例子JUnit,它只有在编译测试代码及运行测试的时候才需要。</li><li>provided:已提供依赖范围。使用此依赖范围的Maven依赖，对于编译和测试classpath有效，但在运行时无效。典型的例子是servlet-api,编译和测试项目的时候需要该依赖，但在运行项目的时候，由于容器已经提供，就不需要Maven重复地引入一遍。</li><li>runtime:运行时依赖范围。使用此依赖范围的Maven依赖，对于测试和运行classpath有效，但在编译主代码时无效。典型的例子是JDBC驱动实现，项目主代码的编译只需要JDK提供的JDBC接口，只有在执行测试或者运行项目的时候才需要实现上述接口的具体JDBC驱动。</li><li>system:系统依赖范围。该依赖与三种classpath的关系，和provided依赖范围完全一致。但是，使用system范围的依赖时必须通过systemPath元素显式地指定依赖文件的路径。由于此类依赖不是通过Maven仓库解析的，而且往往与本机系统绑定，可能造成构建的不可移植，因此应该谨慎使用。<br>![](《Maven实战》阅读笔记\Pasted image 20230202233813.png)</li></ul><h2 id="依赖调解"><a href="#依赖调解" class="headerlink" title="依赖调解"></a>依赖调解</h2><p>Maven引入的传递性依赖机制，一方面大大简化和方便了依赖声明，另一方面，大部分情况下我们只需要关心项目的直接依赖是什么，而不用考虑这些直接依赖会引入什么传递性依赖。但有时候，当传递性依赖造成问题的时候，我们就需要清楚地知道该传递性依赖是从哪条依赖路径引入的。<br>例如，项目A有这样的依赖关系: A-&gt;B-&gt;C-&gt;X(1.0)、A-&gt;D-&gt;X(2.0). X是A的<br>传递性依赖，但是两条依赖路径上有两个版本的X,那么哪个X会被Maven解析使用呢?<br>两个版本都被解析显然是不对的，因为那会造成依赖重复，因此必须选择一个。Maven 依赖调解( Dependency Mediation)的第一原则是: <strong>路径最近者优先</strong>。该例中X(1.0)的路径长度为3，而X(2.0)的路径长度为2，因此X(2. 0)会被解析使用。<br>依赖调解第一原则不能解决所有问题，比如这样的依赖关系: A-&gt;B-&gt; Y(1.0). A-&gt;C-&gt; Y(2.0)，Y(1.0)和Y(2.0)的依赖路径长度是一样的，都为2。那么到底谁会被解析使用呢?在Maven2.0.8及之前的版本中，这是不确定的，但是从Maven2.0.9开始，为了尽可能避免构建的不确定性，Maven 定义了依赖调解的第二原则:<strong>第一声明者优先</strong>。在依赖路径长度相等的前提下，在POM中依赖声明的顺序决定了谁会被解析使用，顺序最靠前的那个依赖优胜。该例中，如果B的依赖声明在C之前，那么Y (1.0)就会被解析使用。</p><blockquote><p>多模块项目，对于整体项目而言，子模块会继承父模块中的依赖。对于子模块之间的依赖关系，</p></blockquote><h2 id="可选依赖"><a href="#可选依赖" class="headerlink" title="可选依赖"></a>可选依赖</h2><p>标签&lt;optional&gt;可标识可选依赖。<br>这样依赖就不会传递进来。</p>排除依赖<p>使用exclusions元素声明排除依赖。exclusions可以包含一个或多个exclusion子元素，因此可以排除一个或多个传递性依赖。需要注意的是，声明exclusion 的时候只需要groupld和artifactld, 而不需要version元素，因为只需要groupID和artifactID就能唯一定位依赖图中的某个依赖。</p><h2 id="优化依赖"><a href="#优化依赖" class="headerlink" title="优化依赖"></a>优化依赖</h2><p>一些命令行：<br><code>mvn dependency:list</code><br><code>mvn dependency:tree</code><br><code>mvn dependency:tree Dverbose</code></p><h1 id="第八章-继承与聚合"><a href="#第八章-继承与聚合" class="headerlink" title="第八章 继承与聚合"></a>第八章 继承与聚合</h1><p>在这个技术飞速发展的时代，各类用户对软件的要求越来越高，软件本身也变得越来越复杂。因此，软件设计人员往往会采用各种方式对软件划分模块，以得到更清晰的设计及更高的重用性。当把Maven应用到实际项目中的时候，也需要将项目分成不同的模块，也就是我们说的多模块项目。</p><h2 id="聚合"><a href="#聚合" class="headerlink" title="聚合"></a>聚合</h2><p>把多个子项目聚合在一起。<br>想要一次构建两个项目，而不是到两个模块的日录下分别执行mvn命令。Maven 聚合(或者称为多模块)这一特性就是为该需求服务的。</p><h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><blockquote><p>聚合的更进一步。</p></blockquote><p>子模块可以继承父模块的配置。<br>”一次声明，多处使用“。</p><h3 id="依赖管理"><a href="#依赖管理" class="headerlink" title="依赖管理"></a>依赖管理</h3><p>Maven提供的dependencyManagement元素既能让子模块继承到父模块的依赖配置，又能保证子模块依赖使用的灵活性。在dependencyManagement元素下的依赖声明不会引入实际的依赖，不过它能够约束dependencies下的依赖使用。</p><p>dependencyManagement配置，完整的依赖声明已经包含在父POM中，子模块只需要配置简单的groupld 和artifactId就能获得对应的依赖信息，从而引人正确的依赖。<br>使用这种依赖管理机制似乎不能减少太多的POM配置，不过笔者还是强烈推荐采用这种方法。其主要原因在于在父POM中使用dependency Management声明依赖能够统一项目范围中依赖的版本，当依赖版本在父POM中声明之后，子模块在使用依赖的时候就无须声明版本，也就不会发生多个子模块使用依赖版本不一致的情况；这可以帮助降低依赖冲突的几率。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;第一章-Maven简介&quot;&gt;&lt;a href=&quot;#第一章-Maven简介&quot; class=&quot;headerlink&quot; title=&quot;第一章 Maven简介&quot;&gt;&lt;/a&gt;第一章 Maven简介&lt;/h1&gt;&lt;p&gt;Maven: 跨平台的自动化构建工具&lt;/p&gt;
&lt;h1 id=&quot;第五章</summary>
      
    
    
    
    <category term="Study" scheme="http://example.com/categories/Study/"/>
    
    <category term="Reading" scheme="http://example.com/categories/Study/Reading/"/>
    
    
    <category term="Maven" scheme="http://example.com/tags/Maven/"/>
    
  </entry>
  
  <entry>
    <title>Java项目第三方库的使用、更新和风险的实证研究</title>
    <link href="http://example.com/2022/12/11/Java%E9%A1%B9%E7%9B%AE%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93%E7%9A%84%E4%BD%BF%E7%94%A8%E3%80%81%E6%9B%B4%E6%96%B0%E5%92%8C%E9%A3%8E%E9%99%A9%E7%9A%84%E5%AE%9E%E8%AF%81%E7%A0%94%E7%A9%B6/"/>
    <id>http://example.com/2022/12/11/Java%E9%A1%B9%E7%9B%AE%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93%E7%9A%84%E4%BD%BF%E7%94%A8%E3%80%81%E6%9B%B4%E6%96%B0%E5%92%8C%E9%A3%8E%E9%99%A9%E7%9A%84%E5%AE%9E%E8%AF%81%E7%A0%94%E7%A9%B6/</id>
    <published>2022-12-11T14:32:57.000Z</published>
    <updated>2023-07-09T16:16:46.364Z</updated>
    
    <content type="html"><![CDATA[<p>💡  论文内容讲解顺序</p><ol><li>论文解决什么问题（研究背景及意义）</li><li>问题分析，和以前的方法相比多考虑什么因素，或者多了什么输入？（现有研究 创新点）</li><li>方法路线</li><li>实验数据</li><li>从那几个方面进行实验对比，用了那几个指标，有哪些新颖的图</li><li>论文的有效性威胁</li><li>论文结论和进一步工作</li><li>相关工作的分类</li><li>论文结构编排</li></ol><h1 id="研究背景及意义"><a href="#研究背景及意义" class="headerlink" title="研究背景及意义"></a>研究背景及意义</h1><p>第三方库是开发软件系统的核心构建块，给开发带来好处，提高生产力。但是，如果使用过时的第三方库，开发人员通常不太了解潜在的风险。<br><strong>从开发者的角度</strong>来看，开发人员缺乏有效的机制来意识到使用和更新第三方库时的潜在风险（比如说API不兼容）。<br><strong>从第三方库的角度</strong>来看，第三方库的开发者也缺乏有效的渠道来了解自己的第三方库在客户端项目中的使用和更新情况，此类信息无法反馈到库的开发周期以改进第三方库的设计。<br>因此，对第三方库的使用、更新和风险进行定量和整体研究可持续地改善生态系统。<br>那么为了可持续地改善这种情况，本文回答以下三个研究问题：第一，第三方库的使用强度和使用时效如何？第二，第三方库的更新强度和更新延迟如何？第三，使用和更新过时的第三方库有什么潜在风险？<br>通过以上三个问题的分析，本文定量和全面地描述 Java 生态系统中第三方库的使用、更新和风险，并为改善生态系统提供切实可行的见解。【提供了有关维护第三方库（例如，智能警报和自动更新过时库）的问题和潜在解决方案的实用见解。】</p><blockquote><p>由此，本文对806个维护良好的Java开源项目和13565个第三方库进行库使用分析和库更新分析，对806个项目和13565个第三方库中的544个安全漏洞进行库风险分析。 本研究中的数据爬取和分析在台式机上花费了大约四个月的时间。  （可借鉴，数据集大）<br>可行的见解是什么？——&gt;对于使用了有bug的库的项目，报告、建议了的更新库的版本</p></blockquote><h1 id="相关工作"><a href="#相关工作" class="headerlink" title="相关工作"></a>相关工作</h1><img src="/.com//12/11/Java%E9%A1%B9%E7%9B%AE%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93%E7%9A%84%E4%BD%BF%E7%94%A8%E3%80%81%E6%9B%B4%E6%96%B0%E5%92%8C%E9%A3%8E%E9%99%A9%E7%9A%84%E5%AE%9E%E8%AF%81%E7%A0%94%E7%A9%B6/image-20230119211143873.png" class title="image-20230119211143873"><h2 id="Usage-Analysis"><a href="#Usage-Analysis" class="headerlink" title="Usage Analysis"></a>Usage Analysis</h2><p>关于库的使用分析，现有研究包括：</p><p>M和K对库版本的使用趋势和流行度进行了研究</p><p>Z等人分析了项目中使用的库版本和类的数量。</p><blockquote><p>他们报告一个项目的库使用情况，但不报告整个项目的库使用情况。</p></blockquote><p>L等人仅针对一个特定的库或项目在方法级别进行库使用分析，但没有衡量一系列库和项目的汇总结果。<br>总之，现有的 Java 生态系统库使用分析都只提供了有关库使用的部分方面。而本文是第一个在细粒度级别上全面分析项目和第三方库库使用情况的研究。  </p><h2 id="Update-Analysis"><a href="#Update-Analysis" class="headerlink" title="Update Analysis"></a>Update Analysis</h2><p>关于库的更新分析，现有研究包括：<br>Bavota等人分析了开发人员更新依赖项的时间和原因，他们发现大量错误修复是依赖项更新的主要原因。</p><p>F等人探讨了库的发布周期与库版本更新之间的关系。</p><p>K等人分析了第三方库更新的实践，发现开发者很少更新库。</p><p>与这些研究不同的是，本文分别从项目和库的角度量化更新强度、更新延迟和更新风险。  </p><h2 id="Risk-Analysis"><a href="#Risk-Analysis" class="headerlink" title="Risk Analysis"></a>Risk Analysis</h2><p>关于库的风险分析，现有研究包括：</p><p>D等人分析了 Java 程序和依赖项的更新风险，发现 75% 的版本更新不兼容。</p><p>C等人提出了一个警报系统来报告具有安全漏洞的 Java 库依赖项。</p><p>而本文则是量化了这种不兼容性，通过调用图对库 API 的更改进行细粒度的分析。</p><blockquote><p>缺陷库api数量和调用次数</p></blockquote><h1 id="研究方法和路线"><a href="#研究方法和路线" class="headerlink" title="研究方法和路线"></a>研究方法和路线</h1><h2 id="研究设计"><a href="#研究设计" class="headerlink" title="研究设计"></a>研究设计</h2><p>对于三个研究问题，设计的方法路线如下。</p><p>首先对于<strong>使用分析</strong>，分别从项目和库的角度分析对第三方库的依赖程度和使用时效，由此量化在项目开发中使用库的重要性以及不断发展的库的影响。</p><p>其次是<strong>更新分析</strong>，分别从项目和库的角度分析对第三方库更新程度和更新延迟。</p><p>最后是<strong>风险分析</strong>，对于项目，分析使用了多个有缺陷的库以及调用了有缺陷的库中的api数量；</p><p>对于库，分析存在多少安全漏洞，以及多少api不同于安全的库版本。由此量化使用过时的库的安全风险和API不兼容的风险。</p><p>然后就是对实验对象进行选取，也就是语料库选择。</p><img src="/.com//12/11/Java%E9%A1%B9%E7%9B%AE%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93%E7%9A%84%E4%BD%BF%E7%94%A8%E3%80%81%E6%9B%B4%E6%96%B0%E5%92%8C%E9%A3%8E%E9%99%A9%E7%9A%84%E5%AE%9E%E8%AF%81%E7%A0%94%E7%A9%B6/image-20230119211235223.png" class title="image-20230119211235223"><h2 id="语料库选择"><a href="#语料库选择" class="headerlink" title="语料库选择"></a>语料库选择</h2><p>本文研究者对从 GitHub 中选择的 Java 开源项目语料库进行了这项研究。本文专注于 Java，因为它被广泛使用，因此研究的发现可能对更广泛的受众有益。</p><p>具体来说，首先选择了github上 200 stars以上的 Java 项目，以确保项目质量，从而产生了最初的 2,216 个项目。<br>在这些项目中，我们筛选使用 Maven 或 Gradle 作为自动构建工具的项目，以便于提取项目中已声明的库依赖项，范围缩小到1,828 个项目中。</p><p>再次选择了在过去三个月内提交的活跃且维护良好的项目，因为来自维护良好的项目的受众可能更具代表性。最后，得到 806 个项目作为数据集，用大写的 P 表示。</p><h1 id="研究问题"><a href="#研究问题" class="headerlink" title="研究问题"></a>研究问题</h1><p>本文具体研究这三个问题。</p><h2 id="RQ1-Library-Use-Analysis"><a href="#RQ1-Library-Use-Analysis" class="headerlink" title="RQ1 Library Use Analysis"></a>RQ1 Library Use Analysis</h2><p>第一个研究问题，研究第三方库的使用情况。<br>为了研究库的使用，本文开发了 library-extractor 以在一次提交中从每个项目的配置文件中提取库依赖项。<br>库依赖项 d 表示为 这个4 元组 &lt;p, f, com, v&gt;<br>运行lib-extracter:</p><blockquote><p>对 P 中每个项目的最新提交运行 lib-extractor，并获得 164,470 个库依赖项，表示为 Dus，24,205 个库版本，表示为 Vus &#x3D; {d.v | d ∈Dus}，以及 13,565 个库，表示为 Lus &#x3D; {v.l | v∈Vus}。  </p></blockquote><h3 id="Usage-Intensity"><a href="#Usage-Intensity" class="headerlink" title="Usage Intensity"></a>Usage Intensity</h3><p>首先是对第三方库使用强度的分析。</p><p>从项目和库的角度分别定义第三方库使用强度：</p><p>一是项目 p 的方法调用第三方库 API 的百分比，二是库 l 的 API 被其他项目调用的百分比。</p><p>要计算这两个参数 usip 和 usil，我们需要提取第三方库的 API、项目中的方法和项目方法中对第三方库的 API 调用。这里借助了Soot和javaparser两个代码分析工具。  </p><blockquote><ol><li>通过爬取jar包得到类文件</li><li>使用Soot提取库中的API</li></ol><p>这里我们保守地将<strong>公共类中的公共方法和字段</strong>视为库 API。  </p><ol start="3"><li>使用 JavaParser 解析项目使用了库中的哪些api，项目方法，表示为 M，以及项目方法中的 API 调用，  表示为C。</li></ol><p>m ∈ M &lt;p, method&gt; p表示项目，method表示项目中的方法；<br>c ∈ C &lt;a, m&gt; a表示库的api，m表示项目中调用a的方法</p></blockquote><blockquote><p>通过上述几个参数（P Vus Lus A M C），可以计算usip &amp; usil</p><img src="/.com//12/11/Java%E9%A1%B9%E7%9B%AE%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93%E7%9A%84%E4%BD%BF%E7%94%A8%E3%80%81%E6%9B%B4%E6%96%B0%E5%92%8C%E9%A3%8E%E9%99%A9%E7%9A%84%E5%AE%9E%E8%AF%81%E7%A0%94%E7%A9%B6/1670468909486-6cfe97b1-8de4-4521-bf5a-d1255213d2a4.png" class title="image.png"><p><strong>解释一下公式</strong>：如图所示，项目使用密集度可以<br>usip &#x3D; 调用第三方库的方法数目&#x2F;项目总的方法数目<br>我的理解是：对于同一第三方库的不同版本 usil &#x3D; 被调用的api数目&#x2F;该第三方库所有api数目 取最大值</p></blockquote><h4 id="Findings"><a href="#Findings" class="headerlink" title="Findings"></a>Findings</h4><p>最后得到统计计算结果，结果如下：</p><img src="/.com//12/11/Java%E9%A1%B9%E7%9B%AE%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93%E7%9A%84%E4%BD%BF%E7%94%A8%E3%80%81%E6%9B%B4%E6%96%B0%E5%92%8C%E9%A3%8E%E9%99%A9%E7%9A%84%E5%AE%9E%E8%AF%81%E7%A0%94%E7%A9%B6/1670469105688-8677fa31-811c-409b-97c1-0c4fe94e3246.png" class title="image.png"><ul><li>图1.a: 纵坐标表示项目数量，横坐标表示调用第三方库api的百分比。</li><li>图1.b:横坐标表示库的数量，横坐标表示跨库调用的百分比。</li></ul><p>可以看到，从项目角度来看，小部分项目不调用库 API，大部分项目对库依赖性在10%~40%之间。<br>从第三方库的角度，60.0%的库最多只有 2% 的 API 被其他项目调用；只有3.9%个库有超过 40% 的 API 被其他项目调用。</p><p>可以看出：<strong>项目通常对库 API 具有适度的依赖性。这种具体的使用依赖性也反映了库的维护所需的努力。 第二是 大多数库中只有非常小的一部分库API被使用。说明库的开发人员可以去除一些未使用的库功能。</strong></p><h3 id="Usage-Outdateness"><a href="#Usage-Outdateness" class="headerlink" title="Usage Outdateness"></a>Usage Outdateness</h3><p>第二点就是关于库使用是否过时的评估。</p><p>本文定义一个库依赖 d 的使用过时度，表示为 use-outdate，作为在库爬取时具有更高版本号的库发布的数量。</p><img src="/.com//12/11/Java%E9%A1%B9%E7%9B%AE%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93%E7%9A%84%E4%BD%BF%E7%94%A8%E3%80%81%E6%9B%B4%E6%96%B0%E5%92%8C%E9%A3%8E%E9%99%A9%E7%9A%84%E5%AE%9E%E8%AF%81%E7%A0%94%E7%A9%B6/1670469720193-24ffb52d-8b09-4c57-affa-10529afb35fe.png" class title="image.png"><p>并从项目和库的角度分别定义第三方库使用过时度：一是项目 p 库依赖项的<strong>平均使用过时度</strong>uso_l–库 l 的库依赖项的<strong>平均使用过时度</strong>。</p><img src="/.com//12/11/Java%E9%A1%B9%E7%9B%AE%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93%E7%9A%84%E4%BD%BF%E7%94%A8%E3%80%81%E6%9B%B4%E6%96%B0%E5%92%8C%E9%A3%8E%E9%99%A9%E7%9A%84%E5%AE%9E%E8%AF%81%E7%A0%94%E7%A9%B6/1670599907528-cd837e8b-ab7e-4f19-9eb0-bcd8074260d3.png" class title="image.png"><h4 id="Findings-1"><a href="#Findings-1" class="headerlink" title="Findings"></a>Findings</h4><p>得到统计结果如图所示：</p><img src="/.com//12/11/Java%E9%A1%B9%E7%9B%AE%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93%E7%9A%84%E4%BD%BF%E7%94%A8%E3%80%81%E6%9B%B4%E6%96%B0%E5%92%8C%E9%A3%8E%E9%99%A9%E7%9A%84%E5%AE%9E%E8%AF%81%E7%A0%94%E7%A9%B6/1670471257614-8ff6c220-d794-4536-9d0d-7d6be3f31ec5.png" class title="image.png"><p>研究结果发现只有 3.5%项目使用最新的库版本。10.3%项目使用的库平均最多与最新版本相差两个版本。 剩下大部分项目采用的库与最新版本相差较大。</p><p>对于第三方库， <strong>在所有使用它们的项目中</strong>，45.2%个调用的库已经是最新的，1,419 (19.6%) 个调用的库平均最多与最新版本相差两个版本，14.2% 库是最新的调用的平均分别与最新版本相差超过 10个版本。<br>可以得到：</p><p><strong>几乎每个项目都会采用过时的库。</strong>项目所使用的第三方库版本通常与最新版本的距离很大。<strong>因此，需要有机制让项目开发人员意识到过时库的风险</strong>（例如，安全漏洞）或新版本的好处（例如，新功能)。</p><p>于是就有了之后两个研究。</p><h2 id="RQ2-Library-Update-Analysis"><a href="#RQ2-Library-Update-Analysis" class="headerlink" title="RQ2 Library Update Analysis"></a>RQ2 Library Update Analysis</h2><p>关于研究问题2，为了研究库的升级，本文开发了 update-extractor 来从项目的提交历史中提取库版本更新。  </p><blockquote><p>它扫描项目 p 的提交以识别每个更改 p 的配置文件的提交 com。然后在 com 和 com 之前的提交上使用 lib-extractor（见 Sec.IV），分别提取 com 之前和之后的库依赖。最后，利用这两组库依赖，通过搜索版本号发生变化的库依赖来识别库版本更新。</p></blockquote><blockquote><p>每个库版本更新 u 表示为一个 6 元组 &lt;p, f, com, l, ver1,ver2&gt;，其中 p, f, com 和 l 分别表示 u 所在的项目、配置文件、提交和库，以及ver1和ver2分别表示更新前后的版本号。  </p></blockquote><h3 id="Update-Intensity"><a href="#Update-Intensity" class="headerlink" title="Update Intensity"></a>Update Intensity</h3><p>从项目和库的角度分别定义第三方库更新强度：upip:  项目 p 当前声明的库依赖项其版本号在 p 的提交中更新所占的百分比；upil，调用库l的项目中，对库l进行更新的项目所占百分比</p><img src="/.com//12/11/Java%E9%A1%B9%E7%9B%AE%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93%E7%9A%84%E4%BD%BF%E7%94%A8%E3%80%81%E6%9B%B4%E6%96%B0%E5%92%8C%E9%A3%8E%E9%99%A9%E7%9A%84%E5%AE%9E%E8%AF%81%E7%A0%94%E7%A9%B6/1670471551992-fc179326-036e-4501-b46f-386c19e38e16.png" class title="image.png"><h4 id="Findings-2"><a href="#Findings-2" class="headerlink" title="Findings"></a>Findings</h4><p>得到统计结果如图所示：</p><img src="/.com//12/11/Java%E9%A1%B9%E7%9B%AE%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93%E7%9A%84%E4%BD%BF%E7%94%A8%E3%80%81%E6%9B%B4%E6%96%B0%E5%92%8C%E9%A3%8E%E9%99%A9%E7%9A%84%E5%AE%9E%E8%AF%81%E7%A0%94%E7%A9%B6/1670471778765-230b9752-e4f4-4c82-ab5d-6fedc6cce2f1.png" class title="image.png"><p>项目角度来看，14.1%的项目没有更新任何当前声明的库依赖项。大部分项目更新了20%-50%的库依赖项，少部分项目更新了超过80% 的库依赖项。  </p><p>第三方库的角度来看，<strong>4,414 (32.5%) 个库在所有依赖它们的项目中从未更新过</strong>。 65.4%的库在超过一半的依赖它们的项目中没有被更新。</p><p>可以看出，<strong>大部分项目的开发人员确实会更新库。尽管如此，仍有一半的项目让其超过一半的第三方库从未更新；三分之一的库在使用它们的项目中没有被更新过。考虑到所选项目维护良好，但是更新实践相对差。由此可见，应该提高对更新库的重要性的认识。</strong>  </p><h3 id="Update-Delay"><a href="#Update-Delay" class="headerlink" title="Update Delay"></a>Update Delay</h3><p>那么开发者对库更新的敏感程度如何呢？本文定义一个库版本更新 u 的更新延迟，记为 update delay-u，作为 u 的<strong>提交日期</strong>和 u 之后的<strong>库版本发布日期之间的延迟</strong>。<br>对于每一个版本更新u，爬取库的发布数据。<br>并且从项目和第三方库的角度分别去分析更新延迟。</p><img src="/.com//12/11/Java%E9%A1%B9%E7%9B%AE%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93%E7%9A%84%E4%BD%BF%E7%94%A8%E3%80%81%E6%9B%B4%E6%96%B0%E5%92%8C%E9%A3%8E%E9%99%A9%E7%9A%84%E5%AE%9E%E8%AF%81%E7%A0%94%E7%A9%B6/1670481251290-44103c14-8e55-41a7-954a-3cb1ae6a3ef8.png" class title="image.png"><h4 id="Findings-3"><a href="#Findings-3" class="headerlink" title="Findings"></a>Findings</h4><p>得到统计结果：</p><img src="/.com//12/11/Java%E9%A1%B9%E7%9B%AE%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93%E7%9A%84%E4%BD%BF%E7%94%A8%E3%80%81%E6%9B%B4%E6%96%B0%E5%92%8C%E9%A3%8E%E9%99%A9%E7%9A%84%E5%AE%9E%E8%AF%81%E7%A0%94%E7%A9%B6/1670481364216-06f04645-2da5-4609-8aea-e27fd0f0c0fb.png" class title="image.png"><p>从项目的角度来看，23.1%的项目最多延迟 30 天更新其库依赖项。大部分项目的更新延迟s超过 60天。</p><p>从库的角度来看，72.6%个库的更新延迟最多为 30 天。剩下库的更新延迟超过 60天。<br>可以看出，<strong>开发人员对新库的发布反应迟缓。库发布新版本，开发人员延迟更新，可能会增加使用过时库的风险（例如，安全漏洞)，甚至会增加更新到新版本的难度，因为在此时间窗口内其他项目可能将使用更多的过时库 API。</strong></p><h2 id="RQ3-Library-Risk-Analysis"><a href="#RQ3-Library-Risk-Analysis" class="headerlink" title="RQ3 Library Risk Analysis"></a>RQ3 Library Risk Analysis</h2><p>那么使用过时的库风险情况如何呢？为了研究库的风险，本文开发了 bug-extractor来收集库中的安全漏洞，首先从 Veracode 的漏洞数据库中爬取每个安全漏洞的元数据。</p><blockquote><p>【Veracode静态源代码分析服务平台是全球商业运营最好的平台，全球数千家 软件科技公司都在使用其服务发现软件安全漏洞、质量缺陷】 中搜索，然后爬取每个安全漏洞的元数据（例如，受影响的库版本和安全补丁）。 </p></blockquote><h3 id="Usage-Risk"><a href="#Usage-Risk" class="headerlink" title="Usage Risk"></a>Usage Risk</h3><p>我们将一个项目的使用风险定义为两个指标：一是一个项目使用的有缺陷的库版本的数量；二是一个项目使用的有缺陷的库版本中的安全漏洞的数量。<br>将库版本的使用风险定义为<strong>库版本中的安全漏洞数量</strong>。</p><h4 id="Findings-4"><a href="#Findings-4" class="headerlink" title="Findings"></a>Findings</h4><p>计算得到统计结果：</p><img src="/.com//12/11/Java%E9%A1%B9%E7%9B%AE%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93%E7%9A%84%E4%BD%BF%E7%94%A8%E3%80%81%E6%9B%B4%E6%96%B0%E5%92%8C%E9%A3%8E%E9%99%A9%E7%9A%84%E5%AE%9E%E8%AF%81%E7%A0%94%E7%A9%B6/1670484785513-df7b8ec5-c4a5-487d-9ddf-7dfbbbd5030f.png" class title="image.png"><p>可以得到，56.0%的项目采用有缺陷的库版本；其中大部分缺陷库版本在1-5个之间，少部分使用超过5个有缺陷的库版本。<br>在这么多个库版本中，只有31.2%个库版本没有安全漏洞。 34.2%的库版本有 1 个安全漏洞。剩下的超过2个安全漏洞。<br>可以看出，**超过一半的项目使用包含安全漏洞的库版本。三分之二的库版本包含安全漏洞。安全漏洞的相对普遍存在表明，如果项目开发人员没有意识到使用库中的安全漏洞或延迟库更新，项目将面临潜在风险。  **</p><h3 id="Update-Risk"><a href="#Update-Risk" class="headerlink" title="Update Risk"></a>Update Risk</h3><p>但是如果开发者贸然更新库也会存在更新风险。<br>本文将项目的更新风险定义为两个指标：一是项目使用的有缺陷的库版本调用 API 的数量（调用了有bug库的多少api），二是对项目使用的错误库版本的 API 调用次数。<br>将有缺陷的版本的更新风险定义为两个指标：一是安全的库版本中删除的缺陷库版本中的 API 数量；二是安全的库版本中修改的缺陷库版本中的 API 数量</p><h4 id="Findings-5"><a href="#Findings-5" class="headerlink" title="Findings"></a>Findings</h4><p>得到统计结果</p><img src="/.com//12/11/Java%E9%A1%B9%E7%9B%AE%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93%E7%9A%84%E4%BD%BF%E7%94%A8%E3%80%81%E6%9B%B4%E6%96%B0%E5%92%8C%E9%A3%8E%E9%99%A9%E7%9A%84%E5%AE%9E%E8%AF%81%E7%A0%94%E7%A9%B6/1670689071599-2e9642aa-e7c8-42fe-af9d-12d85ac6e7cd.png" class title="image.png"><p>在451个采用有bug的库版本的项目中，三分之一的项目在使用的bug库版本中没有调用API，大部分调用了1-20个API，少部分项目调用超过40个API。</p><p>38.3%有缺陷的库版本在安全的库版本中修改了不到 40 个 API，而 24.4%个有缺陷的库版本在安全库版本中修改了超过 100 个 API。2,065 (17.2%) 个有缺陷的库版本在安全库版本中删除了不到 40 个 API。4,236 (35.3%) 个有缺陷的库版本在安全版本中删除了 300 多个 API。</p><p>由此可以得到结论： <strong>使用有缺陷的库的API存在中度风险。需要工具结合项目中使用的库 API 和在安全版本中更改的库 API 来提供对风险的严格估计，以便开发人员更有把握地更新有缺陷的库。</strong></p><h1 id="研究结果"><a href="#研究结果" class="headerlink" title="研究结果"></a>研究结果</h1><img src="/.com//12/11/Java%E9%A1%B9%E7%9B%AE%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93%E7%9A%84%E4%BD%BF%E7%94%A8%E3%80%81%E6%9B%B4%E6%96%B0%E5%92%8C%E9%A3%8E%E9%99%A9%E7%9A%84%E5%AE%9E%E8%AF%81%E7%A0%94%E7%A9%B6/image-20230119211623358.png" class title="image-20230119211623358"><p>并没有找到如何使用这个系统？看不到直观的结果。无法测试自己的数据。开源的只有研究结果和数据集和工具代码。<br>基于上述量化指标和统计结果，本文设计了一个<strong>针对有缺陷库的安全错误驱动警报系统</strong>。包括两个主要模块：风险分析和（更新库版本建议的）工作量分析。<br>然后本研究针对 451 个使用了有缺陷的库的项目运行了这个警报系统，看有问题的库是否影响系统。我们发现 413 个项目不受 bug 库的影响并且可以是安全的。剩下34个受bug影响的项目。<br>表1列出了10个受有bug的库影响的项目，其中 BL 是影响项目的错误库数量，NB、NA 和 NC 是风险分析中报告的指标（其中安全错误总数、调用库 API 和对库 API 的调用列在括号中），SL 是建议库版本的数量，其他列列出了一个建议库版本的工作量分析指标。<br>但是这个警报系统并不是开源&amp;可视化的，在网站上只能看到对节选项目的研究结果。</p><blockquote><p>不能测试自己的项目数据，没有得到更直观的数据。</p></blockquote><blockquote><p>开源的只有数据集。以及基础代码（爬取的代码）</p></blockquote><h1 id="有效性威胁"><a href="#有效性威胁" class="headerlink" title="有效性威胁"></a>有效性威胁</h1><p>最后，本研究讨论了可能的有效性威胁，包括</p><ol><li><strong>（关于）间接依赖。本研究重点在于直接依赖的库</strong>，即在项目配置文件中声明的库。如果考虑间接库依赖，对库的依赖会更重，安全漏洞方面的潜在风险会更高。如果继续深挖、考虑间接依赖，会十分复杂。</li><li><strong>（数据的）主体代表性。</strong>本研究使用维护良好的项目，而筛选掉了不活跃的项目。需要对那些维护不好的项目进行独立研究，以比较结果。此外，研究者无法爬取一些库的 jar 文件和发布日期，因此它们在一些分析中被排除。但是由于数据集规模庞大，研究的数据仍然具有代表性和意义。</li></ol><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>最后对论文进行一个总结，本文主要做了以下工作：</p><ul><li>一是进行了<strong>大规模</strong>的实证分析，定量、全面地分析了第三方库在 Java 开源项目中的使用、更新和风险。  </li><li>二是向开发人员和研究人员提供了<strong>实际意义</strong>，发布了数据集，并提出了一个原型系统<strong>LIBRARY-SECURIFY</strong>，用于协助开发者在更新过时的第三方库时，通过量化风险做出更有把握的决定。证明了研究发现的有用性。</li></ul><h1 id="论文结构"><a href="#论文结构" class="headerlink" title="论文结构"></a>论文结构</h1><p>最后是论文的结构。分为以下八个部分：研究背景及意义、研究现状、实证研究方法、第三方库的使用、更新、风险分析、以及关于论文的讨论和总结。</p><p>以上就是我关于这篇论文的汇报，谢谢大家。</p><hr><h1 id="个人思考"><a href="#个人思考" class="headerlink" title="个人思考"></a>个人思考</h1><h2 id="可借鉴-x2F-优点："><a href="#可借鉴-x2F-优点：" class="headerlink" title="可借鉴&#x2F;优点："></a>可借鉴&#x2F;优点：</h2><ol><li>工作量大，数据集大</li></ol><p>数据集爬取耗费四个月，并且进行了筛选，数据集庞大，具有可信性和代表性。</p><ol start="2"><li>这篇文章提到的许多的相关工作可以去细看一下，比如说JavaParser</li><li>量化评估指标，使研究更具有可行性代表性</li></ol><p>思想上有哪些值得学习的地方？</p><p>既考虑到项目开发者，反馈所使用库的缺陷</p><p>又考虑到第三方库的开发者，</p><p>从两个方面共同促进软件生态。</p><h2 id="todo"><a href="#todo" class="headerlink" title="todo"></a>todo</h2><p>项目数据集开源，但是系统并未开源（？）</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;💡  论文内容讲解顺序&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;论文解决什么问题（研究背景及意义）&lt;/li&gt;
&lt;li&gt;问题分析，和以前的方法相比多考虑什么因素，或者多了什么输入？（现有研究 创新点）&lt;/li&gt;
&lt;li&gt;方法路线&lt;/li&gt;
&lt;li&gt;实验数据&lt;/li&gt;
&lt;li&gt;从那几个方面</summary>
      
    
    
    
    <category term="Study" scheme="http://example.com/categories/Study/"/>
    
    <category term="Research" scheme="http://example.com/categories/Study/Research/"/>
    
    
    <category term="Dependency" scheme="http://example.com/tags/Dependency/"/>
    
    <category term="论文汇报" scheme="http://example.com/tags/%E8%AE%BA%E6%96%87%E6%B1%87%E6%8A%A5/"/>
    
  </entry>
  
  <entry>
    <title>深度学习入门</title>
    <link href="http://example.com/2022/10/08/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E5%85%A5%E9%97%A8/"/>
    <id>http://example.com/2022/10/08/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E5%85%A5%E9%97%A8/</id>
    <published>2022-10-08T02:27:08.000Z</published>
    <updated>2023-07-09T16:53:00.088Z</updated>
    
    <content type="html"><![CDATA[<p>基于《深度学习入门——基于Python的理论和实现》</p><p>一边看源码，一边思考。</p><h1 id="Chapter-1-Python入门"><a href="#Chapter-1-Python入门" class="headerlink" title="Chapter 1 Python入门"></a>Chapter 1 Python入门</h1><p>使用python版本3.9.6。</p><p>外部库：</p><ul><li><p>Numpy 用于数值计算</p></li><li><p>Matplotlib 用于画图，实验结果可视化</p></li></ul><p>anaconda 是一个python的发行版，包括了python和很多常见的软件库, 和一个包管理器conda。</p><h1 id="Chapter-2-感知机"><a href="#Chapter-2-感知机" class="headerlink" title="Chapter 2 感知机"></a>Chapter 2 感知机</h1><p>Perceptron</p><p>感知机接收多个输入信号，输出一个信号。</p><p>感知机的信号只有0&#x2F;1。</p><p>图2-1是一个接收两个输入信号的感知机的例子。<em>x</em>1、<em>x</em>2是输入信号，<em>y</em>是输出信号，<em>w</em>1、<em>w</em>2是权重（<em>w</em>是weight的首字母）。图中的⭕称为“神经元”或者“节点”。输入信号被送往神经元时，会被分别乘以固定的权重。神经元计算传送过来的信号的总和（y&#x3D;w1*x1 + w2*x2），只有这个总和超过了某个界限值（阈值，θ）时，才会输出1，如式子2.1所示。</p><img src="/.com//10/08/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E5%85%A5%E9%97%A8/image-20230612220641031.png" class title="image-20230612220641031"><img src="/.com//10/08/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E5%85%A5%E9%97%A8/image-20230612220854958.png" class title="image-20230612220854958"><p>感知机的多个输入信号都有各自固有的权重，这些权重发挥着控制各个信号的重要性的作用。也就是说，权重越大，对应该权重的信号的重要性就越高。</p><h1 id="Chapter-3-神经网络"><a href="#Chapter-3-神经网络" class="headerlink" title="Chapter 3 神经网络"></a>Chapter 3 神经网络</h1><p>神经网络的特征就是可以从数据中学习。所谓“从数据中学习”，是指可以由数据自动决定权重参数的值。</p><h1 id="Chapter-4-神经网络的学习"><a href="#Chapter-4-神经网络的学习" class="headerlink" title="Chapter 4 神经网络的学习"></a>Chapter 4 神经网络的学习</h1><p>神经网络就是通过不断地学习所提供的数据，尝试发现待求解的问题的模式。</p><p>机器学习：一般将数据分为<strong>训练数据</strong>和<strong>测试数据</strong>两部分来进行学习。首先，使用训练数据进行学习，寻找最优的参数；然后，使用测试数据评价训练得到的模型的实际能力。为什么需要将数据分为训练数据和测试数据呢？因为我们追求的是模型的泛化能力。为了正确评价模型的<u>泛化能力</u>，就必须划分训练数据和测试数据。另外，训练数据也可以称为<strong>监督数据</strong>。</p><p>泛化能力是指处理未被观察过的数据（不包含在训练数据中的数据）的能力。</p><h2 id="损失函数"><a href="#损失函数" class="headerlink" title="损失函数"></a>损失函数</h2><p>神经网络的学习通过某个指标表示现在的状态。然后，以这个指标为基准，寻找最优权重参数。</p><p>神经网络的学习中所用的指标称为<strong>损失函数（loss function）</strong>。这个损失函数可以使用任意函数，但一般用<strong>均方误差</strong>和<strong>交叉熵误差</strong>等。</p><h3 id="均方误差"><a href="#均方误差" class="headerlink" title="均方误差"></a>均方误差</h3><p>可用作损失函数的函数有很多，最有名的是均方误差（mean squared error）</p><img src="/.com//10/08/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E5%85%A5%E9%97%A8/image-20230612221618209.png" class title="image-20230612221618209"><p><em>yk</em>是表示神经网络的输出，<em>tk</em>表示监督数据，<em>k</em>表示数据的维数。</p><h3 id="交叉熵误差"><a href="#交叉熵误差" class="headerlink" title="交叉熵误差"></a>交叉熵误差</h3><img src="/.com//10/08/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E5%85%A5%E9%97%A8/image-20230612221713506.png" class title="image-20230612221713506"><p>这里，log表示以e为底数的自然对数（log e ）。<em>yk</em>是神经网络的输出，<em>tk</em>是正确解标签。</p><h3 id="mini-batch学习"><a href="#mini-batch学习" class="headerlink" title="mini-batch学习"></a>mini-batch学习</h3><p>机器学习针对训练数据计算损失函数的值，找出使得损失函数值更小的参数。计算损失函数时必须将所有的训练数据作为对象。</p><p>MNIST数据集的训练数据有60000个，如果以全部数据为对象求损失函数的和，则计算过程需要花费较长的时间。再者，如果遇到大数据，数据量会有几百万、几千万之多，这种情况下以全部数据为对象计算损失函数是不现实的。因此，我们从全部数据中选出一部分，作为全部数据的“近似”。神经网络的学习也是从训练数据中选出一批数据（称为mini-batch*,*小批量），然后对每个mini-batch进行学习。比如，从60000个训练数据中随机选择100笔，再用这100笔数据进行学习。这种学习方式称为<strong>mini-batch</strong>学习。</p><h2 id="数值微分"><a href="#数值微分" class="headerlink" title="数值微分"></a>数值微分</h2><h3 id="导数"><a href="#导数" class="headerlink" title="导数"></a>导数</h3><h3 id="偏导数"><a href="#偏导数" class="headerlink" title="偏导数"></a>偏导数</h3><h3 id="梯度"><a href="#梯度" class="headerlink" title="梯度"></a>梯度</h3><p>由全部变量的偏导数汇总而成的向量称为梯度（gradient）</p><p>机器学习的主要任务是在学习时寻找<strong>最优参数（损失函数取最小值时的参数）</strong>。</p><p>而通过巧妙地使用梯度（gradient）来寻找函数最小值（或者尽可能小的值）的方法就是梯度法。</p><p>根据目的是寻找最小值还是最大值，梯度法的叫法有所不同。严格地讲，寻找最小值的梯度法称为梯度下降法（gradient descent method），寻找最大值的梯度法称为梯度上升法（gradient ascent method）。但是通过反转损失函数的符号，求最小值的问题和求最大值的问题会变成相同的问题，因此“下降”还是“上升”的差异本质上并不重要。</p><p>一般来说，神经网络（深度学习）中，梯度法主要是指梯度下降法。</p><ul><li><input disabled type="checkbox"> 跑代码</li></ul><h1 id="误差反向传播法"><a href="#误差反向传播法" class="headerlink" title="误差反向传播法"></a>误差反向传播法</h1><p>将学习一个能够高效计算权重参数的梯度的方法——误差反向传播法。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;基于《深度学习入门——基于Python的理论和实现》&lt;/p&gt;
&lt;p&gt;一边看源码，一边思考。&lt;/p&gt;
&lt;h1 id=&quot;Chapter-1-Python入门&quot;&gt;&lt;a href=&quot;#Chapter-1-Python入门&quot; class=&quot;headerlink&quot; title=&quot;Cha</summary>
      
    
    
    
    <category term="Study" scheme="http://example.com/categories/Study/"/>
    
    
    <category term="Deep Learning" scheme="http://example.com/tags/Deep-Learning/"/>
    
  </entry>
  
  <entry>
    <title>依赖问题</title>
    <link href="http://example.com/2022/09/18/%E4%BE%9D%E8%B5%96%E9%97%AE%E9%A2%98/"/>
    <id>http://example.com/2022/09/18/%E4%BE%9D%E8%B5%96%E9%97%AE%E9%A2%98/</id>
    <published>2022-09-18T04:03:48.000Z</published>
    <updated>2023-07-09T16:51:17.868Z</updated>
    
    <content type="html"><![CDATA[<p>Pattern A: 由Maven依赖仲裁机制引起——包粒度的依赖冲突问题</p><ul><li>直接依赖和传递依赖之间的冲突</li><li>传递依赖之间的冲突</li><li>本地代码与第三方库之间的冲突</li></ul><p>Pattern B: 由 Java 虚拟机的类加载原则引起</p><ul><li>类粒度的依赖冲突问题</li></ul><h2 id="Pattern-A-包粒度的依赖冲突问题"><a href="#Pattern-A-包粒度的依赖冲突问题" class="headerlink" title="Pattern A 包粒度的依赖冲突问题"></a>Pattern A 包粒度的依赖冲突问题</h2><p>由于 Maven 依赖加载的两条原则：<strong>最短路径优先</strong>和<strong>先声明优先</strong>。当项目中存在同一个第三方库的不同版本时只有一个版本的依赖可以被加载而剩下版本的依赖被屏蔽。</p><h3 id="Rep-1：项目使用同一第三方库的不同版本"><a href="#Rep-1：项目使用同一第三方库的不同版本" class="headerlink" title="Rep 1：项目使用同一第三方库的不同版本"></a>Rep 1：项目使用同一第三方库的不同版本</h3><blockquote><p>直接依赖与间接依赖之间的冲突。</p></blockquote><img src="/.com//09/18/%E4%BE%9D%E8%B5%96%E9%97%AE%E9%A2%98/image-20220913152459197.png" class title="image-20220913152459197"><h3 id="Rep-5：动态绑定机制干扰下的依赖冲突问题"><a href="#Rep-5：动态绑定机制干扰下的依赖冲突问题" class="headerlink" title="Rep 5：动态绑定机制干扰下的依赖冲突问题"></a>Rep 5：动态绑定机制干扰下的依赖冲突问题</h3><img src="/.com//09/18/%E4%BE%9D%E8%B5%96%E9%97%AE%E9%A2%98/image-20220913194026967.png" class title="image-20220913194026967"><p>对于库B有两个版本，根据最短声明原则，2.0版本被加载，1.0被屏蔽。被加载的 org.example:LibB 的 2.0 版本的类 libB.Base64 中没有包含 1.0 版本libB.Base64 的 encode(byte[])方法，因此传统的依赖置换问题检测算法判定该场景会产生程序异常。</p><p>然而，可以看到虽然 org.example:LibB 的 2.0版本的类 libB.Base64 中没有包含 1.0 版本类 libB.Base64 的encode(byte[])方法，但是 2.0 版本的<strong>类 libB.Base64 继承于父类 libB.BaseNCodec</strong>，<strong>父类 libB.BaseNCodec中定义了方法 encode(byte[])被子类 libB.Base64 继承</strong>，因此该场景不会在项目运行时产生 NoSuchMethodError 的程序异常，应该被<strong>过滤以避免产生误报对开发者造成困扰</strong>。</p><blockquote><p>这种情况属于把无害的依赖置换问题”误诊“为有害的。</p></blockquote><h3 id="Rep-6：循环依赖问题"><a href="#Rep-6：循环依赖问题" class="headerlink" title="Rep 6：循环依赖问题*"></a>Rep 6：循环依赖问题*</h3><blockquote><p>也是属于Rep1，但是是特殊情况需要特殊解决。</p></blockquote><img src="/.com//09/18/%E4%BE%9D%E8%B5%96%E9%97%AE%E9%A2%98/image-20220913194958016.png" class title="image-20220913194958016"><h3 id="隐式冲突"><a href="#隐式冲突" class="headerlink" title="隐式冲突"></a>隐式冲突</h3><p>隐式冲突定义：在依赖A_m0→A_m1→· · ·  中，存在一组 A_ij , A_mn 满足 A_ij &#x3D;&#x3D;A_mn 且 V_ij ! &#x3D; V_mn项目使用了同一第三方库的不同版本，但是目前仍能正常编译运行。</p><blockquote><p>也属于Rep 1, 主要是解决间接依赖之间的冲突。</p><p>要消除间接依赖的冲突，就要更改直接依赖的版本以消除间接依赖的冲突。</p><p>如何修改？→ 协同更新法</p></blockquote><h4 id="Rep-1-1：出现冲突的包，与别的包存在公共依赖。"><a href="#Rep-1-1：出现冲突的包，与别的包存在公共依赖。" class="headerlink" title="Rep 1.1：出现冲突的包，与别的包存在公共依赖。"></a>Rep 1.1：出现冲突的包，与别的包存在公共依赖。</h4><img src="/.com//09/18/%E4%BE%9D%E8%B5%96%E9%97%AE%E9%A2%98/image-20220913162752636.png" class title="image-20220913162752636"><p>因此，只需分别获取以下四种映射，<em>VA</em> <em>→</em> <em>VD</em>1,<em>VB</em> <em>→</em> <em>VD</em>1,<em>VA</em> <em>→</em> <em>VD</em>2,<em>VC</em> <em>→</em> <em>VD</em>2，据此选择相应版本, 使得 <em>fAD</em>1(<em>VA</em>) &#x3D; <em>fBD</em>1(<em>VB</em>) &amp;&amp; <em>fAD</em>2(<em>VA</em>) &#x3D; <em>fCD</em>2(<em>V**C</em>)，那么更新 A，B， C 的版本将会从定义上消除冲突。</p><p>取A和B关于冲突包的版本的交集，再反向映射得到修改的A 和 B的版本。</p><h4 id="Rep-1-2：出现冲突的包，只共用了出现冲突的依赖（-）"><a href="#Rep-1-2：出现冲突的包，只共用了出现冲突的依赖（-）" class="headerlink" title="Rep 1.2：出现冲突的包，只共用了出现冲突的依赖（*）"></a>Rep 1.2：出现冲突的包，只共用了出现冲突的依赖（*）</h4><p>改进哪一个？</p><img src="/.com//09/18/%E4%BE%9D%E8%B5%96%E9%97%AE%E9%A2%98/image-20220913162802511.png" class title="image-20220913162802511"><p>有时候，虽然项目的整体结构复杂，但出现冲突的依赖之间关系非常简单：例如图1-11中所示，A,B 包存在大量共同依赖 <em>D</em>1*, D<em>2</em>, . . . , Dx<em>，C 依赖了不同版本的包 <em>Dx</em>。这种情况*<em>往往出现在往无冲突的现有项目中引入新的包。时。</em></em></p><p>对于这种情况，我们往往只需要<strong>对新引入的 C 包进行版本的改变</strong>，即可消除冲突。</p><p>我们根据冲突信息可以知道当前版本过高还是过低，于是据此收缩左右边界，并将中间版本置为当前版本。重复执行直至 C 包依赖的包不再出现 conflict。</p><blockquote><p>有没有间接依赖的间接依赖之间出现冲突的情况？协同更新是否还适用？</p></blockquote><h2 id="Pattern-B-类粒度的依赖冲突问题（-）"><a href="#Pattern-B-类粒度的依赖冲突问题（-）" class="headerlink" title="Pattern B 类粒度的依赖冲突问题（*）"></a>Pattern B 类粒度的依赖冲突问题（*）</h2><h3 id="Rep-2：不同的-JAR-包含完全限定名相同的类文件"><a href="#Rep-2：不同的-JAR-包含完全限定名相同的类文件" class="headerlink" title="Rep 2：不同的 JAR 包含完全限定名相同的类文件"></a><u>Rep 2：不同的 JAR 包含<strong>完全限定名相同的类文件</strong></u></h3><blockquote></blockquote><img src="/.com//09/18/%E4%BE%9D%E8%B5%96%E9%97%AE%E9%A2%98/image-20220913191833238.png" class title="image-20220913191833238"><p>按照 Java 虚拟机的类加载原则，只会加载先声明的 org.example:LibA:1.0 中的类 org.example.classCase.C1 和 org.example.classCase.C2，Client 从调用 org.example.LibB:1.0 的类 org.example.classCase.C1 和org.example.classCase.C2 转为调用 org.example.LibA:1.0 的类 org.example.classCase.C1 和 org.example.classCase.C2，发生了类粒度的依赖置换问题。</p><h3 id="Rep-3：客户软件与第三方依赖中包含冲突的类文件"><a href="#Rep-3：客户软件与第三方依赖中包含冲突的类文件" class="headerlink" title="Rep 3：客户软件与第三方依赖中包含冲突的类文件"></a>Rep 3：客户软件与第三方依赖中包含冲突的类文件</h3><blockquote><p>本地代码与第三方库之间的冲突</p></blockquote><img src="/.com//09/18/%E4%BE%9D%E8%B5%96%E9%97%AE%E9%A2%98/image-20220913193849124.png" class title="image-20220913193849124"><p>Java 虚拟机中规定完全限定名相同的类文件只能加载一个，此时，会分为两种子情况：</p><ol><li>如果客户软件和第三方依赖分别打包发布，实际加载的是客户软件中的类文件</li><li>如果客户软件和第三方依赖一同打包发布，实际加载的是第三方依赖中的类文件</li></ol><h3 id="Rep-4：混合粒度的依赖冲突问题"><a href="#Rep-4：混合粒度的依赖冲突问题" class="headerlink" title="Rep 4：混合粒度的依赖冲突问题"></a>Rep 4：混合粒度的依赖冲突问题</h3><blockquote><p>REP 1 &amp; 2混合的情况</p></blockquote><img src="/.com//09/18/%E4%BE%9D%E8%B5%96%E9%97%AE%E9%A2%98/image-20220913193823229-16630691056091.png" class title="image-20220913193823229"><hr><p>扩展其他编程语言&#x2F;构建工具</p><p>Rust，PHP， Android Gradle</p><p><a href="https://docs.gradle.org/current/userguide/core_dependency_management.html">Gradle中的依赖管理</a></p><p><a href="https://segmentfault.com/a/1190000013002041?utm_source=sf-similar-article"><a href="https://segmentfault.com/a/1190000013002041">PHP依赖管理Composer</a></a></p><img src="/.com//09/18/%E4%BE%9D%E8%B5%96%E9%97%AE%E9%A2%98/image-20220913200300335.png" class title="image-20220913200300335"><hr><p>Q：</p><ol><li><p>Maven 广度&#x2F;深度？</p></li><li><p>版本区间 </p><ol><li>下载机制？</li><li>现成的数据集 有没有存在版本区间？</li></ol></li><li></li></ol><p>怎么发现这些依赖问题？感觉实际项目中很难发现这些抽象的依赖冲突问题。</p><p>怎么收集那些大型项目（folk star多的）进行实验？</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Pattern A: 由Maven依赖仲裁机制引起——包粒度的依赖冲突问题&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;直接依赖和传递依赖之间的冲突&lt;/li&gt;
&lt;li&gt;传递依赖之间的冲突&lt;/li&gt;
&lt;li&gt;本地代码与第三方库之间的冲突&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Pattern B: 由 J</summary>
      
    
    
    
    <category term="Study" scheme="http://example.com/categories/Study/"/>
    
    <category term="Research" scheme="http://example.com/categories/Study/Research/"/>
    
    
    <category term="Dependency" scheme="http://example.com/tags/Dependency/"/>
    
  </entry>
  
  <entry>
    <title>study notion</title>
    <link href="http://example.com/2022/09/15/study-notion/"/>
    <id>http://example.com/2022/09/15/study-notion/</id>
    <published>2022-09-15T02:08:34.000Z</published>
    <updated>2023-07-09T18:44:54.330Z</updated>
    
    <content type="html"><![CDATA[<h1 id="使用Java爬取网页"><a href="#使用Java爬取网页" class="headerlink" title="使用Java爬取网页"></a>使用Java爬取网页</h1><p>用到okhttp3 &amp; jsoup两个库。</p><p>countDownLatch</p><h1 id="Maven依赖版本更新不及时的解决办法"><a href="#Maven依赖版本更新不及时的解决办法" class="headerlink" title="Maven依赖版本更新不及时的解决办法"></a>Maven依赖版本更新不及时的解决办法</h1><p>找不到依赖项？怎么解决？maven同步一下&#x2F;重新打开项目时下载。</p><p>在使用maven的时候，遇到过这样一个问题，在使用夫工程进行版本控制的时候，把其中的一个依赖版本进新了更改，但是在子工程中的依赖还是显示的上一个依赖的版本，点完maven刷新也是不变化，这时候就是需要clean一下你当前工程的target目录让他重新生成，然后点击maven刷新可以了</p><p>java.net.SocketTimeoutException</p><img src="/.com//09/15/study-notion/%E6%8A%A5%E9%94%991.png" class><h1 id="如何打包java文件为jar包"><a href="#如何打包java文件为jar包" class="headerlink" title="如何打包java文件为jar包"></a>如何打包java文件为jar包</h1><p>文件-项目结构-工件-“+”-JAR</p><p>Maven 的<dependency>的scope属性可以为system，因为有些你依赖的jar包可能是没有maven坐标的，它完全不在maven体系中，这时候你可以把它下载到本地硬盘，然后通过system来引用</dependency></p><p>不过不推荐使用system，因为一个项目的pom.xml如果使用了scope为system的depend后，会导致传递依赖中断，即所有其他依赖本项目的项目都无法传递依赖了。</p><p>依赖范围设置为system后，会导致传递依赖中断。</p><h1 id="Maven项目导入本地jar包"><a href="#Maven项目导入本地jar包" class="headerlink" title="Maven项目导入本地jar包"></a>Maven项目导入本地jar包</h1><p><a href="https://blog.csdn.net/myli92/article/details/119921846">https://blog.csdn.net/myli92/article/details/119921846</a></p><p><a href="https://www.jianshu.com/p/212ab6bc96c9">https://www.jianshu.com/p/212ab6bc96c9</a></p><h1 id="普通java项目转换为Maven项目"><a href="#普通java项目转换为Maven项目" class="headerlink" title="普通java项目转换为Maven项目"></a>普通java项目转换为Maven项目</h1><ol><li><p>项目上右键 Add Framework Support。</p><img src="/.com//09/15/study-notion/image-20220922115953146.png" class title="image-20220922115953146"></li><li><p>选择maven，点击OK。</p></li></ol><h1 id="javac编译报错：cannot-find-symbol"><a href="#javac编译报错：cannot-find-symbol" class="headerlink" title="javac编译报错：cannot find symbol"></a>javac编译报错：cannot find symbol</h1><p>cmd编译java文件，cannot find symbol。依赖并未加载？</p><p><a href="https://stackoverflow.com/questions/53809709/package-org-apache-poi-ss-usermodel-does-not-exist">https://stackoverflow.com/questions/53809709/package-org-apache-poi-ss-usermodel-does-not-exist</a></p><h1 id="如何看某一个项目-调用了依赖的包的哪些api（类和方法）"><a href="#如何看某一个项目-调用了依赖的包的哪些api（类和方法）" class="headerlink" title="如何看某一个项目 调用了依赖的包的哪些api（类和方法）"></a>如何看某一个项目 调用了依赖的包的哪些api（类和方法）</h1>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;使用Java爬取网页&quot;&gt;&lt;a href=&quot;#使用Java爬取网页&quot; class=&quot;headerlink&quot; title=&quot;使用Java爬取网页&quot;&gt;&lt;/a&gt;使用Java爬取网页&lt;/h1&gt;&lt;p&gt;用到okhttp3 &amp;amp; jsoup两个库。&lt;/p&gt;
&lt;p&gt;count</summary>
      
    
    
    
    
    <category term="notion" scheme="http://example.com/tags/notion/"/>
    
  </entry>
  
  <entry>
    <title>编译原理与技术笔记</title>
    <link href="http://example.com/2022/08/27/Compiler/"/>
    <id>http://example.com/2022/08/27/Compiler/</id>
    <published>2022-08-27T00:45:49.000Z</published>
    <updated>2023-07-09T18:43:39.177Z</updated>
    
    <content type="html"><![CDATA[<p>这是2021 ~ 2022 第二学期必修课编译原理与技术的课堂笔记。</p><h1 id="Lecture-01-Introduction-to-Compiling"><a href="#Lecture-01-Introduction-to-Compiling" class="headerlink" title="Lecture 01 Introduction to Compiling"></a>Lecture 01 Introduction to Compiling</h1><p>Goal:</p><ul><li>What’s compiling?</li><li>What’s compiler?</li></ul><h2 id="Preliminaries-Required"><a href="#Preliminaries-Required" class="headerlink" title="Preliminaries Required"></a>Preliminaries Required</h2><ul><li>Basic knowledge of CFG (Context Free Grammar ). 上下文无关语法</li><li>Knowledge of a high programming language (C&#x2F;C++&#x2F;Java&#x2F;Python) for the programming assignments. C++&#x2F;Java</li></ul><h2 id="Course-Outline"><a href="#Course-Outline" class="headerlink" title="Course Outline"></a>Course Outline</h2><p>Introduction to Compiling</p><p><strong>Lexical Analysis</strong> </p><ul><li>Regular expressions, regular definitions </li><li>NFA, DFA</li><li>Subset construction, Thompson’s construction</li></ul><p><strong>Syntax Analysis</strong></p><ul><li>Context Free Grammars </li><li>Top-Down Parsing, LL Parsing </li><li>Bottom-Up Parsing, LR Parsing</li></ul><p><strong>Syntax-Directed Translation</strong> </p><ul><li>Attribute Definitions </li><li>Evaluation of Attribute Definitions</li></ul><p><strong>Semantic Analysis, Type Checking</strong> </p><p>Run-Time Organization </p><p>Intermediate Code Generation </p><p>Assembler Code Generation</p><h2 id="Compilers"><a href="#Compilers" class="headerlink" title="Compilers"></a>Compilers</h2><p>A compiler（编译器） is a program takes a program written in a source  language and translates it into an equivalent program in a target language.</p><img src="/.com//08/27/Compiler/image-20220310161900386.png" class title="image-20220310161900386"><p><strong>编译器</strong>是将源程序（用高级编程语言写的代码）“翻译”为目标程序（机器可执行形式）的软件。</p><p><strong>编译：</strong>将高级编程语言编程的源程序（source program）翻译成机器可执行的形式（target program）。其中完成这项翻译工作的软件系统——编译系统，核心部分为编译器。</p><h2 id="Compiling-System"><a href="#Compiling-System" class="headerlink" title="Compiling System"></a>Compiling System</h2><img src="/.com//08/27/Compiler/image-20220310161843908.png" class title="image-20220310161843908"><p><strong>注：编译器只是整个编译过程中的一部分，但也是最核心的部分</strong></p><ul><li>预处理器（Preprocessor）：聚合源程序、把宏的缩写形式转换为源语言的语句，去掉机器不需要看到的（如注释、Tab…）</li><li><strong>编译器（Compiler）：输出汇编语言程序（target program）</strong></li><li>汇编器（Assembler）：生成可重定位的机器代码</li><li>链接器（Linker）：解决外部内存地址问题</li><li>加载器（Loader）：把所有可执行目标文件放到内存中执行</li></ul><h2 id="The-Phases-of-a-Compiler"><a href="#The-Phases-of-a-Compiler" class="headerlink" title="The Phases of a Compiler"></a>The Phases of a Compiler</h2><p>There are two major parts of a compiler:  <strong>Analysis and Synthesis</strong>&#x2F;<strong>Front-end and Back-end</strong> (分析与综合&#x2F;前端与后端)</p><img src="/.com//08/27/Compiler/image-20220310162806711.png" class title="image-20220310162806711"><img src="/.com//08/27/Compiler/image-20220310162816800.png" class title="image-20220310162816800"><p>Each phase transforms the source program from one representation  into another representation. </p><p>They communicate with the symbol table（符号表）. </p><p>They communicate with error handlers</p><blockquote><p>Why symbol table &amp; error handlers?</p><p>Machine just do 2 things: calculate and store. Thus a machine is storing every time(need symbol table) and can make mistakes(need error handler) any time.</p></blockquote><h1 id="Lecture-02-Lexical-Analysis"><a href="#Lecture-02-Lexical-Analysis" class="headerlink" title="Lecture 02 Lexical Analysis"></a>Lecture 02 Lexical Analysis</h1><blockquote><p>Chapter 3-1 词法分析器</p></blockquote><p>词法分析最重要的是：机器如何识别<strong>合法的单词</strong>（Token）。首先需要知道，什么才是单词？</p><p>词法分析器（Lexical Analyzer Generator）的作用就是告诉机器什么叫做单词。（那么要怎么做呢？）</p><p>Lexical analyzer &#x3D; scanning + lexical analysis</p><h2 id="Steps-of-Lexical-Analysis"><a href="#Steps-of-Lexical-Analysis" class="headerlink" title="Steps of Lexical Analysis"></a>Steps of Lexical Analysis</h2><ol><li><p>Reading the source program as a file of characters. 从源程序中<strong>读字符（character by character）</strong></p></li><li><p>Dividing the file up into tokens. 从字符中分割出单词</p></li><li><p>Store tokens into symbol table. 将单词存入Symbol Table</p></li></ol><img src="/.com//08/27/Compiler/image-20220310192508335.png" class title="image-20220310192508335"><p><strong>识别合法单词的方法：</strong></p><ul><li>Regular expression 正则表达式</li><li>（Transition Diagram 状态转移图）有限自动机&#x2F;语法树</li></ul><h2 id="Major-Terms-for-Lexical-Analysis"><a href="#Major-Terms-for-Lexical-Analysis" class="headerlink" title="Major Terms for Lexical Analysis"></a>Major Terms for Lexical Analysis</h2><ol><li><p>token 单词</p><p>&lt; identifier &gt;,  &lt; number &gt;, etc.</p></li><li><p>pattern 模式、规则</p><p>The rules which characterize the set of strings for a token</p></li><li><p>lexeme 词素（例子）</p><p>Identifiers: x, count, name, etc.</p></li></ol><h2 id="Terminology-of-Languages"><a href="#Terminology-of-Languages" class="headerlink" title="Terminology of Languages"></a>Terminology of Languages</h2><p>Def. A language, L, is simply <code>any set of strings over a fixed alphabet</code>.</p><p><strong>Alphabet:</strong> a finite set of symbols (ASCII  characters)</p><p><strong>String :</strong>  </p><ul><li>Finite sequence of symbols on an alphabet 字母表上符号的有限序列</li><li>Sentence and word are also used in terms of  string </li><li>ε is the empty string  是空字符串，不包含任何字符（不是语言）</li></ul><p><strong>Language:</strong> sets of strings over some fixed alphabet 由固定字母表上的字符组合的字符串的集合</p><ul><li>空集也是语言</li><li>The set of all possible identifiers is a language. 所有可能的标识符的集合</li><li>注意： <ul><li>ε is a string containing no symbols. It is not a language.</li><li>{ε} is <strong>a language containing one string: the empty string ε</strong>. It is not a string. <strong>只包含空串</strong>的语言，它不是字符串，而是语言。</li><li>Ø is the empty language. It contains no strings. Ø空集是空语言。它不包含字符串。</li></ul></li></ul><h2 id="Operations-on-Languages"><a href="#Operations-on-Languages" class="headerlink" title="Operations on Languages"></a>Operations on Languages</h2><p>有限的算子➡无限的语言</p><img src="/.com//08/27/Compiler/image-20220310192848018.png" class title="image-20220310192848018"><p>有4种算子：</p><ul><li><p>union: 并集&#x2F;或 关系</p></li><li><p>concatenation：<strong>连接</strong></p></li><li><p><strong>Kleene Closure</strong>：Kleen闭包——&gt;<strong>L</strong>* — “<strong>zero</strong> or more concatenations of “ L</p></li><li><p><strong>Positive Closure</strong>：真闭包——&gt;<strong>L+</strong> —“<strong>one</strong> or more concatenations of “ L</p></li></ul><h2 id="Regular-Expression-正则表达式——-词法分析的灵魂"><a href="#Regular-Expression-正则表达式——-词法分析的灵魂" class="headerlink" title="Regular Expression 正则表达式—— 词法分析的灵魂"></a>Regular Expression 正则表达式—— 词法分析的灵魂</h2><p>A <strong>Regular Expression</strong> is a Set of Rules &#x2F; Techniques for  <code>Constructing Sequences of Symbols (Strings) From an Alphabet</code>.</p><p>正则表达式是由字母表种构造字符串的一套规则。</p><p>两个正则表达式等价，是指两个表达式描述完全相同的语言，即**正则表达式expr1和expr2等价，当且仅当L(expr1)&#x3D;L(expr2)**。</p><h3 id="Rules-for-Specifying-Regular-Expressions"><a href="#Rules-for-Specifying-Regular-Expressions" class="headerlink" title="Rules for Specifying Regular Expressions"></a>Rules for Specifying Regular Expressions</h3><p><strong>结构归纳法构造正则表达式</strong></p><img src="/.com//08/27/Compiler/image-20220310193624617.png" class title="image-20220310193624617"><img src="/.com//08/27/Compiler/image-20220310193700154.png" class title="image-20220310193700154"><img src="/.com//08/27/Compiler/image-20220310193732208.png" class title="image-20220310193732208"><h3 id="Regular-Definitions-正则定义"><a href="#Regular-Definitions-正则定义" class="headerlink" title="Regular Definitions 正则定义"></a>Regular Definitions 正则定义</h3><blockquote><p>To write regular expression for some languages can be difficult, because  their regular expressions can be quite complex. In those cases, we may use  regular definitions.</p><p>使用正则定义简化</p></blockquote><p>A regular definition is a sequence of the definitions of the form:</p><img src="/.com//08/27/Compiler/image-20220310193830247.png" class title="image-20220310193830247"><p>Shorthand Notation: </p><ul><li><p>“+” : one or more   r* &#x3D; r+ |  &amp; r + &#x3D; r r*</p></li><li><p>“?” : zero or one   r?&#x3D;r | ∈ </p></li><li><p>[range] : set range of characters (replaces “|” )   [A-Z] &#x3D; A | B | C | … | Z</p></li></ul><hr><p>Homework Exercise:</p><p>Some are difficult and I don’t know whether what I wrote were reasonable.</p><h1 id="Lecture-03-Finite-automata-NFA-to-DFA"><a href="#Lecture-03-Finite-automata-NFA-to-DFA" class="headerlink" title="Lecture 03 Finite automata NFA to DFA"></a>Lecture 03 Finite automata NFA to DFA</h1><p>机器如何存储Tokens? ➡ 状态转移图</p><p>RE(Regular Expression)——&gt;TD(Transition Diagram)</p><aside>💡 如何将正则表达式变为计算机可识别的有限状态自动机？</aside>有限状态自动机：NFA & DFA<h2 id="Constructing-Transition-Diagrams-for-Tokens"><a href="#Constructing-Transition-Diagrams-for-Tokens" class="headerlink" title="Constructing Transition Diagrams for Tokens"></a>Constructing Transition Diagrams for Tokens</h2><p><strong>Transition Diagrams (TD)</strong> are used to represent the tokens </p><p>Each TD has:（TD的4大特征）</p><ul><li>States : Represented by Circles</li><li>Actions : Represented by Arrows between states</li><li>Start State : Beginning of a pattern (Arrowhead)</li><li>Final State(s) : End of pattern (Concentric Circles)</li></ul><p>Each TD is <code>Deterministic</code>（确定性） - No need to choose between 2 different actions  不需要“选择困难” （因此对计算机来说，确定性是最优的。而对人来说，更多时候都是不确定性）</p><p><strong>Example of TD:</strong></p><img src="/.com//08/27/Compiler/image-20220310194536345.png" class title="image-20220310194536345"><h2 id="Finite-Automata-有限自动机"><a href="#Finite-Automata-有限自动机" class="headerlink" title="Finite Automata 有限自动机"></a>Finite Automata 有限自动机</h2><p>A finite automaton can be: <code>deterministic(DFA)</code> or <code>nondeterministic(NFA)</code></p><ul><li>deterministic – faster recognizer, but it may take more space 确定性的快，占更多的空间，不够精确</li><li>non-deterministic – slower, but it may take less space 不确定的慢（回溯），占用空间较少，更精确</li><li>Deterministic automatons <strong>are widely used</strong> lexical analyzer</li></ul><p>First, we define regular expressions for tokens; Then we convert them into a DFA to get a lexical analyzer for our tokens.</p><ul><li>Algorithm1: Regular Expression ➔ NFA ➔ DFA (two steps: first to NFA, then to DFA) 先得到NFA，再转换为DFA（子集构造法：不确定的➡确定的）</li><li>Algorithm2: Regular Expression ➔ DFA (directly convert a regular expression into a DFA) 直接得到DFA （Thompson, mention in next class）</li></ul><h3 id="Non-Deterministic-Finite-Automata"><a href="#Non-Deterministic-Finite-Automata" class="headerlink" title="Non-Deterministic Finite Automata"></a>Non-Deterministic Finite Automata</h3><p><strong>不确定的自动机</strong></p><p>An NFA is a mathematical model that consists of : </p><ul><li>S, a set of <strong>states</strong> </li><li>∑, the symbols of the <strong>input alphabet</strong></li><li>move, a <strong>transition function</strong> 状态迁移函数<ul><li>move(state, symbol) → set of states</li><li>move: S × ∑ ∪{ε} → Pow(S) (path of word)</li></ul></li></ul><p><strong>不确定性：</strong></p><ul><li><strong>空转移</strong>：<strong>不做任何指令</strong>可以转变为任意状态</li><li>接受某一指令后，<strong>既可以到xx状态，又可以到yy状态</strong></li></ul><p><strong>Representing NFAs</strong></p><ul><li>状态转移图</li><li>状态转移表（前面注明start state &amp; final state）</li></ul><img src="/.com//08/27/Compiler/image-20220310201113816.png" class title="image-20220310201113816"><h3 id="Deterministic-finite-automation-DFA"><a href="#Deterministic-finite-automation-DFA" class="headerlink" title="Deterministic finite automation (DFA)"></a>Deterministic finite automation (DFA)</h3><p><strong>确定的自动机</strong></p><p>A DFA is an NFA with the following restrictions:</p><ul><li>ε moves are <strong>not</strong> allowed 不允许空转移</li><li>For every state s ∈ S, there is one and only one path from s for every input symbol a ∈ ∑ 对于任一状态，再接受某一输入字符后，只有一条路径（即转移到另一个状态）</li></ul><h3 id="Converting-NFA-into-DFA"><a href="#Converting-NFA-into-DFA" class="headerlink" title="Converting NFA into DFA"></a>Converting NFA into DFA</h3><h4 id="Calculate-ε-closure-计算空闭包"><a href="#Calculate-ε-closure-计算空闭包" class="headerlink" title="Calculate ε-closure 计算空闭包"></a>Calculate ε-closure 计算空闭包</h4><img src="/.com//08/27/Compiler/image-20220310194917018.png" class title="image-20220310194917018"><ul><li>ε-closure(s): 状态s在识别ε后所能到达的状态集合</li><li>ε-closure(T): 状态集合T中的状态在识别ε后所能到达的状态集合</li><li>Move(T,a): 状态集合T中的状态在识别某一输入字符‘a’后所能到达的状态集合</li></ul><h4 id="Subset-construction-子集构造法"><a href="#Subset-construction-子集构造法" class="headerlink" title="Subset construction 子集构造法"></a>Subset construction 子集构造法</h4><ul><li>空转移：空闭包</li><li>move函数再加空闭包</li></ul><img src="/.com//08/27/Compiler/image-20220310201647651.png" class title="image-20220310201647651"><img src="/.com//08/27/Compiler/image-20220310201656105.png" class title="image-20220310201656105"><img src="/.com//08/27/Compiler/image-20220310201705176.png" class title="image-20220310201705176"><img src="/.com//08/27/Compiler/image-20220310201712750.png" class title="image-20220310201712750"><h1 id="Lecture-04-RE-to-NFA-Thompson-amp-RE-to-DFA-direct"><a href="#Lecture-04-RE-to-NFA-Thompson-amp-RE-to-DFA-direct" class="headerlink" title="Lecture 04 RE to NFA(Thompson) &amp; RE to DFA(direct)"></a>Lecture 04 RE to NFA(Thompson) &amp; RE to DFA(direct)</h1><h2 id="RE-to-NFA-Thompson-Construction"><a href="#RE-to-NFA-Thompson-Construction" class="headerlink" title="RE to NFA(Thompson Construction)"></a>RE to NFA(Thompson Construction)</h2><blockquote><p>Thompson’s Construction is simple and systematic method.</p><p>It guarantees that the resulting NFA will have exactly one final<br> state, and one start state. 确保NFA恰好有一个开始状态 和一个终止状态</p></blockquote><ol><li>Identify subexpressions of the regular expression【类型判别】</li><li>Characterize “pieces” of NFA for each subexpression</li></ol><p><strong>一共六种形式：</strong>（只有六种，其余NFA都是这六种的组合）</p><img src="/.com//08/27/Compiler/image-20220317144558280.png" class title="image-20220317144558280"><img src="/.com//08/27/Compiler/image-20220317144607036.png" class title="image-20220317144607036"><img src="/.com//08/27/Compiler/image-20220317144631981.png" class title="image-20220317144631981"><p>注：如果是L(s)L(t),那么N(s)的开始节点作为开始节点，N(s)的结束节点与N(t)的开始节点重合(overlap)，N(t)的结束节点作为结束节点</p><img src="/.com//08/27/Compiler/image-20220317144926082.png" class title="image-20220317144926082"><h3 id="Properties-of-Construction"><a href="#Properties-of-Construction" class="headerlink" title="Properties of Construction"></a>Properties of Construction</h3><ol><li><p>状态数目可控（是<strong>有规律地</strong>构造）</p><p>N(r) has #of states ≤  2*(#symbols + #operators) of r</p></li><li><p><strong>只有一个开始状态和一个结束状态</strong></p></li><li><p>每个状态对应每个字符(a∈∑)<strong>只有唯一一条输出的边（确定性）</strong></p></li><li><p><em>注意从0开始标状态，<u>从左至右、从上至下</u>标状态</em></p></li></ol><h3 id="Note"><a href="#Note" class="headerlink" title="Note"></a>Note</h3><p>So, an NFA may be simulated by algorithm, when NFA is constructed using Previous techniques</p><p>Algorithm run time is proportional to |N| * |x| where <strong>|N| is the number of states</strong> and <strong>|x| is the length of input</strong></p><p>Alternatively, we can construct DFA from NFA and use the resulting Dtran to recognize input:</p><p>复杂度这里不太懂</p><img src="/.com//08/27/Compiler/image-20220317145239375.png" class title="image-20220317145239375"><h2 id="RE-to-DFA-direct"><a href="#RE-to-DFA-direct" class="headerlink" title="RE to DFA(direct)"></a>RE to DFA(direct)</h2><p>Steps </p><ol><li>给正则表达式后面加上<strong>终止符“#”</strong></li><li>给字符<strong>标号</strong>（除了空串）</li><li>画出<strong>语法树</strong></li><li>每个节点的firstpos &amp; lastpos,得到每个叶子节点的followpos</li><li>根据followpos得到DFA</li></ol><h3 id="followPOSITION函数"><a href="#followPOSITION函数" class="headerlink" title="followPOSITION函数"></a>followPOSITION函数</h3><p>在当前位置后面可能跟着的position的集合</p><blockquote><p>followpos(i) – is the set of positions which can follow  the position i in the strings generated by the augmented regular expression</p></blockquote><img src="/.com//08/27/Compiler/image-20220317150801403.png" class title="image-20220317150801403"><blockquote><p>To evaluate followpos, we need three more functions to be defined for the nodes (not just for leaves) of the syntax tree</p></blockquote><h3 id="辅助函数firstpos-lastpos-nullable"><a href="#辅助函数firstpos-lastpos-nullable" class="headerlink" title="辅助函数firstpos, lastpos, nullable"></a><strong>辅助函数firstpos, lastpos, nullable</strong></h3><ul><li>firstpos(n) – the set of the positions of the first symbols of strings generated by the sub-expression rooted by n.</li><li>lastpos(n) – the set of the positions of the last symbols of strings generated by the sub-expression rooted by n.</li><li>nullable(n) – true if the empty string is a member of strings generated by the sub-expression rooted by n. false otherwise.</li></ul><h3 id="How-to-evaluate-firstpos-lastpos-nullable"><a href="#How-to-evaluate-firstpos-lastpos-nullable" class="headerlink" title="How to evaluate firstpos, lastpos, nullable"></a>How to evaluate firstpos, lastpos, nullable</h3><img src="/.com//08/27/Compiler/image-20220317150415605.png" class title="image-20220317150415605"><h3 id="How-to-evaluate-followpos"><a href="#How-to-evaluate-followpos" class="headerlink" title="How to evaluate followpos"></a>How to evaluate followpos</h3><p>Two-rules define the function followpos: （根据以下两条规则 看Followpos）</p><ol><li>If n is concatenation-node with left child c1 and right child c2(如果是连接节点) , and i <u>is a position in lastpos(c1)</u>, then <code>all positions in firstpos(c2 ) are in followpos(i)</code>. </li><li>If n is a star-node(如果是Kleene闭包), and <u>i is a position in lastpos(n)</u>, then <code>all positions in firstpos(n) are in followpos(i)</code>.</li></ol><p>Example</p><img src="/.com//08/27/Compiler/image-20220317150504722.png" class title="image-20220317150504722"><img src="/.com//08/27/Compiler/image-20220317150522966.png" class title="image-20220317150522966"><h1 id="Lecture-05-Minimizing-DFA-amp-Review-of-Chapter-3"><a href="#Lecture-05-Minimizing-DFA-amp-Review-of-Chapter-3" class="headerlink" title="Lecture 05 Minimizing DFA &amp; Review of Chapter 3"></a>Lecture 05 Minimizing DFA &amp; Review of Chapter 3</h1><h2 id="Minimizing-DFA"><a href="#Minimizing-DFA" class="headerlink" title="Minimizing DFA"></a>Minimizing DFA</h2><p>DFA与 NFA相比，状态数较多，占空间比较多，可以简化。</p><h3 id="Algorithm"><a href="#Algorithm" class="headerlink" title="Algorithm"></a>Algorithm</h3><ol><li>首先将状态集分为两组，G1代表接收&#x2F;结束状态集，G2代表非接收状态:<ul><li>G1: set of <strong>accepting states</strong></li><li>G2: set of <strong>non-accepting states</strong></li></ul></li><li>对于状态集G中的状态，识别任意字符，若到达同一状态集(Group)，则不分解；若达到不同状态集，分解。</li><li>上述操作循环直至状态集不能再分。</li><li>将新的状态集合组合成最简的DFA。</li></ol><h3 id="Example"><a href="#Example" class="headerlink" title="Example"></a>Example</h3><img src="/.com//08/27/Compiler/image-20220323105717173.png" class title="image-20220323105717173"><img src="/.com//08/27/Compiler/image-20220323105728239.png" class title="image-20220323105728239"><h2 id="Review-amp-Exercise"><a href="#Review-amp-Exercise" class="headerlink" title="Review &amp; Exercise"></a>Review &amp; Exercise</h2><img src="/.com//08/27/Compiler/image-20220323105737544.png" class title="image-20220323105737544"><ul><li>基本概念</li><li>核心概念<ul><li>正则表达式</li><li>正则定义</li><li>注意需要自己给定约束&#x2F;限制</li></ul></li><li>四大算法（考试要求手写出来）<ul><li>RE to NFA</li><li>NFA to DFA</li><li>RE to DFA</li><li>Minimize DFA</li></ul></li></ul><h1 id="Lecture-06-Syntax-Analysis-I"><a href="#Lecture-06-Syntax-Analysis-I" class="headerlink" title="Lecture 06 Syntax Analysis I"></a>Lecture 06 Syntax Analysis I</h1><aside> 💡 语法分析器<ol><li>什么叫句子？</li><li>用什么方式&#x2F;规则表示句子？ —— CFG</li><li>机器可识别的TD形式是什么样的？ —— Syntax Tree</li></ol><h2 id="Error-Processing"><a href="#Error-Processing" class="headerlink" title="Error Processing"></a>Error Processing</h2><ul><li>Detecting errors</li><li>Finding position at which they occur</li><li>Clear &#x2F; accurate presentation</li><li>Recover (pass over) to continue and find later errors</li><li>Don’t impact compilation of “correct” programs</li></ul><h2 id="Error-Recovery-Strategies"><a href="#Error-Recovery-Strategies" class="headerlink" title="Error Recovery Strategies"></a>Error Recovery Strategies</h2><ul><li><p><strong>Panic Mode 紧急模式</strong></p><ul><li>发现错误所在后，快速处理（如缺少分号）</li></ul></li><li><p><strong>Phrase level - Local correction on input 短语级模式</strong></p><ul><li>看前后单词关系</li></ul></li><li><p>Error Production 错误产生式</p><ul><li>发现错误，认为规则出错，改变规则</li><li>语法规则数目较小，可以使用</li></ul></li><li><p>Global Correction 全局订正法</p><ul><li>全局来看错误，全局的改正（难以实现）</li></ul></li></ul><aside> 💡 什么叫做句子？<br>    RE v.s. CFG    <aside> 💡用什么规则表示        <br> 上下文无关文法<h3 id="Regular-Expressions"><a href="#Regular-Expressions" class="headerlink" title="Regular Expressions"></a>Regular Expressions</h3><ul><li>Basis of lexical analysis 词法分析的基础</li><li>Repesent regular languages</li><li>正则表达式还不够表达句子→扩充</li></ul><h3 id="Context-Free-Grammars"><a href="#Context-Free-Grammars" class="headerlink" title="Context Free Grammars"></a>Context Free Grammars</h3><ul><li>Basis of parsing 解析句子的基础</li><li>Represent language constructs</li><li>Characterize context free languages</li></ul><blockquote><p>关系：<strong>CFG包含了RE</strong>（表达能力包含了RE）</p></blockquote><img src="/.com//08/27/Compiler/image-20220329204202914.png" class title="image-20220329204202914"><p>产生式 production rules <code>A→ α</code></p><img src="/.com//08/27/Compiler/image-20220329204235489.png" class title="image-20220329204235489"><p><strong>T</strong>: Terminals &#x2F; tokens of the language（终结符集合）</p><p><strong>NT</strong>: Non-terminals to denote sets of strings generated by the grammar &amp; in the language（非终结符集合）</p><p><strong>S</strong>: Start symbol, S ⇒ NT, which defines all strings of the language</p><p><strong>PR</strong>: Production rules to indicate how T and NT are combined togenerate valid strings of the languag</p><blockquote><p>CFG最FORMAL的定义：<strong>PR:</strong> <strong>NT</strong> <strong>→</strong> <strong>(T | NT)</strong></p></blockquote><h4 id="Terminology"><a href="#Terminology" class="headerlink" title="Terminology"></a>Terminology</h4><p><strong>L(G) is the language of G</strong>(the language generated by G) which is a set of sentences.</p><p><strong>等价文法的判定：</strong></p><ul><li><strong>对于文法G1和G2，若有：L(G1)&#x3D;L(G2)，则称文法G1和G2是等价的。</strong></li></ul><p>A <strong>sentence （句子）</strong>of L(G) is a string of terminal symbols of G.</p><img src="/.com//08/27/Compiler/image-20220329204522787.png" class title="image-20220329204522787"><img src="/.com//08/27/Compiler/image-20220329204534628.png" class title="image-20220329204534628"><p>$$<br>S \overset{+}{\Rightarrow} w<br>$$</p><ul><li><p>句子：A <strong>sentence （句子）</strong>of L(G) is a string of terminal symbols of G. 这个语言中关于终结符的字符串</p></li><li><p>句型：从开始符经过一系列推导得到句子，中间形式（包括开始符）称为句型。</p></li><li><p>If α contains non-terminals, it is called as a <strong>sentential form</strong> of G. 存在非终结符，则为句型</p></li><li><p>If α does not contain non-terminals, it is called as a <strong>sentence</strong> of G. 最后全是终结符，称为句子</p></li></ul><blockquote><p>后面还有句柄（Handle）的概念，需要辨析。</p></blockquote><h2 id="Derivation"><a href="#Derivation" class="headerlink" title="Derivation"></a>Derivation</h2><p>E ⇒ E+E</p><ul><li>E+E derives from E<ul><li>we can replace E by E+E</li><li>to able to do this, we have to have a production rule E→E+E in our grammar.</li></ul></li></ul><p>E ⇒ E+E ⇒ id+E ⇒ id+id</p><ul><li><strong>A sequence of replacements of non-terminal symbols</strong> is called a **<u>derivation （推导）</u>**of id+id from E</li></ul><h2 id="Other-Derivation-Concepts"><a href="#Other-Derivation-Concepts" class="headerlink" title="Other Derivation Concepts"></a>Other Derivation Concepts</h2><p><strong>Example</strong></p><p>E ⇒ -E ⇒ -(E) ⇒ -(E+E) ⇒ -(id+E) ⇒ -(id+id)</p><p><strong>OR</strong></p><p>E ⇒ -E ⇒ -(E) ⇒ -(E+E) ⇒ -(E+id) ⇒ -(id+id)</p><ul><li><p>At each derivation step, we can <u>choose any of the non-terminal in the sentential form of G for the replacement.</u></p></li><li><p>If we always choose the <code>left-most</code> non-terminal in each derivation step, this derivation is called as left-most derivation （最左推导）.</p><p>最左推导：每次替换最左边的非终结符</p></li><li><p>If we always choose the <code>right-most</code> non-terminal in each derivation step, this derivation is called as right-most derivation （最右推导）.</p><p>最右推导：每次替换最右边的非终结符</p></li></ul><img src="/.com//08/27/Compiler/image-20220329204624394.png" class title="image-20220329204624394"><h1 id="Lecture-07-Syntax-Analysis-II"><a href="#Lecture-07-Syntax-Analysis-II" class="headerlink" title="Lecture 07 Syntax Analysis II"></a>Lecture 07 Syntax Analysis II</h1><p> 💡 什么是句子？</p><p><strong>由开始符出发，经过一系列的替换&#x2F;重写，得到只有终结符组成的strings（句子）。</strong></p><p>💡 机器如何选择替换规则？（不确定性）</p><p>不确定性 → 确定性，找规律，给出<strong>规定</strong>（最左推导和最右推导)</p><p>机器可识别的形式 → Transition Diagram (Parse Tree)</p><h2 id="Parse-Tree"><a href="#Parse-Tree" class="headerlink" title="Parse Tree"></a>Parse Tree</h2><p>语法树的形式表示句子的推导。只需要看叶子节点。</p><img src="/.com//08/27/Compiler/image-20220410211102441.png" class title="image-20220410211102441"><p>情况一：</p><img src="/.com//08/27/Compiler/image-20220410211308489.png" class title="image-20220410211308489"><p>情况二：</p><img src="/.com//08/27/Compiler/image-20220410211314914.png" class title="image-20220410211314914"><blockquote><p>Two distinct leftmost derivations! ⇒ 二义性</p></blockquote><h2 id="Ambiguity-（二义性）"><a href="#Ambiguity-（二义性）" class="headerlink" title="Ambiguity （二义性）"></a>Ambiguity （二义性）</h2><p>A grammar produces <strong>more than one parse tree for a sentence</strong> is called as an <em><strong>ambiguous</strong></em> grammar.（对于一个句子的转换 我们存在多个parse tree）</p><ul><li><p>对文法G中的同一个句子，有<strong>2个不同的最左&#x2F;最右推导</strong>，就有二义性。</p></li><li><p>若文法G对同一句子<strong>产生不止一棵分析树</strong>，则称G是二义的。</p></li></ul><blockquote><p>计算机该识别哪个parse tree?机器可不喜欢不确定性。那么我们如何消除二义性？</p></blockquote><p>else到底跟着哪个if？——规定else紧跟着离它最近的if语句</p><h3 id="Eliminating-Ambiguity（消除二义性）"><a href="#Eliminating-Ambiguity（消除二义性）" class="headerlink" title="Eliminating Ambiguity（消除二义性）"></a>Eliminating Ambiguity（消除二义性）</h3><ol><li><p>以算术表达式为例，<strong>规定操作符的优先级</strong></p><p>Ambiguous grammars (because of ambiguous operators) can be disambiguated according to the precedence and associativity rules.</p><img src="/.com//08/27/Compiler/image-20220410230640965.png" class title="image-20220410230640965"></li><li><p>以if语句为例</p><p><strong>The general rule is “match each else with the closest previous unmatched then.”</strong></p><p>解决方法为规定else匹配的是离它最近的if。</p></li></ol><blockquote><p>消除二义性？<strong>不可行的，只能假设没有二义性。</strong></p></blockquote><h2 id="Left-Recursion（左递归）"><a href="#Left-Recursion（左递归）" class="headerlink" title="Left Recursion（左递归）"></a>Left Recursion（左递归）</h2><ul><li><p>A grammar is <em><strong>left recursive（左递归）</strong></em> if it has a non-terminal A such that there is a derivation A→Aα+ for some string α.</p></li><li><p>The left-recursion may appear in a single step of the derivation(<em><strong>immediate left-recursion 直接左递归</strong></em>), or may appear in more than one step of the derivation.</p></li><li><p><strong>Top-down parsing</strong> techniques <strong>cannot</strong> handle left-recursive grammars.</p><p>存在左递归，解析程序无法终止</p></li></ul><img src="/.com//08/27/Compiler/image-20220410230717615.png" class title="image-20220410230717615"><p><strong>造成程序无法终止。</strong></p><p>对于直接左递归：用右递归代替</p><img src="/.com//08/27/Compiler/image-20220504185446654.png" class title="image-20220504185446654"><blockquote><p>注意！A’右边记得加上空∈</p></blockquote><h3 id="Elimination-of-Left-Recursion（消除间接左递归）"><a href="#Elimination-of-Left-Recursion（消除间接左递归）" class="headerlink" title="Elimination of Left-Recursion（消除间接左递归）"></a>Elimination of Left-Recursion（消除间接左递归）</h3><img src="/.com//08/27/Compiler/image-20220504185413164.png" class title="image-20220504185413164"><p><strong>Algorithm:</strong></p><img src="/.com//08/27/Compiler/image-20220504185350407.png" class title="image-20220504185350407"><p>对于所有的非终结符：A1…An</p><p>两个循环：i：1<del>n ; j：1</del>i-1</p><p>Ai可以被前面的Aj替换 ⇔ Ai → Aj γ，Aj → ɑ1|…|ɑk，将ɑ1|…|ɑk带入Aj，Ai → ɑ1 γ|…|ɑk γ</p><h2 id="Left-Factoring（左因式分解）"><a href="#Left-Factoring（左因式分解）" class="headerlink" title="Left-Factoring（左因式分解）"></a>Left-Factoring（左因式分解）</h2><p>有公共左因子，导致不确定性</p><p>如何消除？提出公共左因子。推迟让计算机做选择。</p><img src="/.com//08/27/Compiler/image-20220418153720112.png" class title="image-20220418153720112"><img src="/.com//08/27/Compiler/image-20220824204402914.png" class title="image-20220824204402914"><h2 id="Summary"><a href="#Summary" class="headerlink" title="Summary"></a>Summary</h2><p>对于CFG,有以下三个约束：什么样的CFG机器是喜欢的？</p><ol><li>二义性（导致不确定）</li><li>左递归（导致不终止）</li><li>公共左因子（导致不确定）</li></ol><p>对于后两条规则，机器是可以解决的。然而二义性除了经验，没有办法解决。只能假设没有二义性。</p><h1 id="Lecture-08-Top-Down-Parsing-I"><a href="#Lecture-08-Top-Down-Parsing-I" class="headerlink" title="Lecture 08 Top-Down Parsing I"></a>Lecture 08 Top-Down Parsing I</h1><blockquote><p>什么是Top-Down?</p><p>自顶向下，从开始符出发分析到叶子节点</p></blockquote><p>Top-Down Parsing主要有两种方式：</p><ol><li>带回溯的递归下降语法分析（最一般的方法，适用于大部分文法，效率较低）</li><li>预测语法树（速度快，适用范围较小，需CFG满足三个约束）</li></ol><img src="/.com//08/27/Compiler/image-20220504185722901.png" class title="image-20220504185722901"><h2 id="Recursive-Descent-Parsing-uses-Backtracking"><a href="#Recursive-Descent-Parsing-uses-Backtracking" class="headerlink" title="Recursive-Descent Parsing (uses Backtracking)"></a>Recursive-Descent Parsing (uses Backtracking)</h2><p><strong>带回溯的自顶向下的语法分析</strong></p><img src="/.com//08/27/Compiler/image-20220418155612612.png" class title="image-20220418155612612"><h2 id="Recursive-Predictive-Parsing-预测语法树（核心）"><a href="#Recursive-Predictive-Parsing-预测语法树（核心）" class="headerlink" title="Recursive Predictive Parsing 预测语法树（核心）"></a>Recursive Predictive Parsing 预测语法树（核心）</h2><p>最经典的预测语法树——LL(1) Parser</p><p>先进行<strong>预处理（一定要先预处理）</strong>，得到适用于LL(1)语法的CFG：</p><ol><li>消除左递归</li><li>提取公共左因子</li></ol><p>Non-Recursive predictive parsing is a table-driven parser which has an input buffer, a stack, a parsing table, and an output stream. <strong>It is also known as LL(1) Parser.</strong></p><blockquote><p>无回溯，且高效</p></blockquote><h3 id="LL-1-Parser——最经典的预测语法树"><a href="#LL-1-Parser——最经典的预测语法树" class="headerlink" title="LL(1) Parser——最经典的预测语法树"></a>LL(1) Parser——最经典的预测语法树</h3><blockquote><p>为啥叫LL(1)？</p></blockquote><ol><li><strong>Left</strong> to right scan input 从左至右扫描</li><li>Find <strong>leftmost</strong> derivation 最左推导</li><li>Everytime scan <strong>1</strong> character 每次只扫描一个字符&#x2F;指针一次只指向一个字符</li></ol><p>组成部分：<em>input， output， stack，parsing table</em></p><ul><li>input：输入的<strong>字符串（句子）</strong>【判断结束：加上结束符 ’$‘】</li><li>output：输出为<strong>语法树</strong>，<u>本质上是一系列有序的产生式规则——最左推导过程</u></li><li>stack：重写规则的动作</li><li>parsing table：事先生成的预测表</li></ul><h3 id="Table-Driven"><a href="#Table-Driven" class="headerlink" title="Table Driven"></a>Table Driven</h3><p><strong>语法分析表&amp;栈</strong></p><img src="/.com//08/27/Compiler/image-20220418155822436.png" class title="image-20220418155822436"><p>input: string + terminator(注意要加上终止符“$”)</p><p>初始化栈：<strong>栈底放terminator(’$’), 放入开始符(S)</strong></p><p>Parser behavior: <strong>X: top of stack(栈顶)</strong>  <strong>a:current input(指针现在指向的字符)</strong></p><ol><li>When X &#x3D; a &#x3D; $, <u><strong>栈顶元素与a匹配，且a恰好是终止符($)，程序结束，成功分析</strong>；</u></li><li>When X &#x3D; a ≠ $, <u><strong>栈顶元素与终结符a匹配，pop X off stack, 继续扫描后续字符</strong>；</u></li><li>When X is a non-terminal, <u><strong>examine M[X,a]</strong></u>；</li></ol><ul><li><p>if it is an error → call recovery routine 如果表项为空 错误处理</p></li><li><p>if <strong>M[X,a] &#x3D; {X → UVW}</strong>, POP X, <strong>PUSH W,V,U(最左推导，要把最左边的放在栈顶)</strong> 如果对于产生式，弹出X，<u>产生式右边部分倒序入栈</u></p></li></ul><p><strong>Example</strong></p><p>语法分析表：</p><ul><li>行：非终结符</li><li>列：终结符加上”$“符</li><li>每一项是产生式，也有可能为空</li></ul><img src="/.com//08/27/Compiler/image-20220418155933899.png" class title="image-20220418155933899"><img src="/.com//08/27/Compiler/image-20220418155942057.png" class title="image-20220418155942057"><p>那么如何写出语法分析表呢？</p><h2 id="Constructing-LL-1-Parsing-Tables"><a href="#Constructing-LL-1-Parsing-Tables" class="headerlink" title="Constructing LL(1) Parsing Tables"></a>Constructing LL(1) Parsing Tables</h2><p>Constructing the Parsing Table M !</p><ol><li>Calculate FIRST &amp; FOLLOW for Grammar</li><li>Apply Construction Algorithm for Parsing Table( We’ll see this shortly )</li></ol><h3 id="Basic-Function"><a href="#Basic-Function" class="headerlink" title="Basic Function"></a>Basic Function</h3><p><strong>FIRST</strong>: Let α be a string of grammar symbols. FIRST(α) is the set that includes every terminal that appears leftmost in α or in any string originating from α.</p><blockquote><p>NOTE: If α ⇒ 空串, then 空串 is FIRST(α). </p></blockquote><p>表示<strong>有可能</strong>出现在这个字符串最开始的字符的集合</p><p><strong>FOLLOW</strong>: Let <strong>A be a non-terminal</strong>. FOLLOW(A) is the set of terminals a that can appear directly to the right of A in some sentential form.</p><p>表示<strong>有可能</strong>跟在它后面的那些字符</p><h3 id="Compute-FIRST-for-Any-String-X"><a href="#Compute-FIRST-for-Any-String-X" class="headerlink" title="Compute FIRST for Any String X"></a>Compute FIRST for Any String X</h3><img src="/.com//08/27/Compiler/image-20220418160016626.png" class title="image-20220418160016626"><ol><li><p>如果X是终结符，FIRST(X) &#x3D; {X}</p></li><li><p>如果X → 空串  , 那么将空串加入FIRST(X)中</p></li><li><p>如果X是非终结符，且产生式<br>$$<br>X\rightarrow Y_{1}Y_{2}…Y_{k}<br>$$<br>那么：</p><p>将FIRST(Y1)加入FIRST(X);</p><p>如果<strong>Y1可能为空</strong>，<strong>将FIRST(Y2)加入FIRST(X)</strong>;</p><p>如果Y2可能为空，将FIRST(Y3)加入FIRST(X);</p><p>如果全部都可能为空，那么把空加入FIRST(X);</p><p>……直至没有元素需要加到FIRST(X) 【直至Yi不可能为空】</p></li></ol><h3 id="Compute-FOLLOW-for-Any-non-terminal-X"><a href="#Compute-FOLLOW-for-Any-non-terminal-X" class="headerlink" title="Compute FOLLOW for Any non-terminal X"></a>Compute FOLLOW for Any non-terminal X</h3><img src="/.com//08/27/Compiler/image-20220418160031407.png" class title="image-20220418160031407"><ol><li>S是开始符，那么结束符一定在FOLLOW(S)中；（初始化栈时”S$”）</li><li>若是产生式 A → αBβ，那么所有在FIRST(β)的都在FOLLOW(B)中（除了空串 why）</li><li>若是产生式 A → αB 或者 A → αBβ 且 FIRST(B)中含有空串</li></ol><h3 id="Constructing-LL-1-Parsing-Table"><a href="#Constructing-LL-1-Parsing-Table" class="headerlink" title="Constructing LL(1) Parsing Table"></a>Constructing LL(1) Parsing Table</h3><img src="/.com//08/27/Compiler/image-20220418160145530.png" class title="image-20220418160145530"><ul><li><p>列：终结符+$结束符</p></li><li><p>行：非终结符</p></li></ul><ol><li><p>对于CFG中的每一条产生式 A→α， 重复Step 2&amp;3;</p></li><li><p>若终结符a ∈ First(α)，那么将 A→α 加入M[A,a]中;</p></li><li><p>若空串 ∈ First(α)，将 A→α 放入M[A,b]中，其中<strong>b∈Follow(A)(包括$)</strong>;</p><p>？产生式可能为空，那么对Follow(A)有影响？</p></li><li><p>最终构造出来的表中，有空着的项 &#x3D;&gt; Error Handler；</p><blockquote><p>注：若在表项中现两个或两个以上产生式，这是由<strong>二义性</strong>造成的（<code>因为二义性无法进行预处理，进行预处理的是左递归和左因子</code>），就说明**<u>不是LL(1)文法</u>**。因为会产生不确定性。</p></blockquote></li></ol><h1 id="Lecture-09-Top-Down-Parsing-II"><a href="#Lecture-09-Top-Down-Parsing-II" class="headerlink" title="Lecture 09 Top-Down Parsing II"></a>Lecture 09 Top-Down Parsing II</h1><p>Top-Down Parsing:</p><ol><li>带回溯的递归（一般的方法，但分析效率不高）</li><li>预测法 如LL(1) Parser（分析速度快，但应用范围小，只适用于无二义性、无左递归、无左因子的CFG）</li></ol><h2 id="Properties-of-LL-1-Grammars"><a href="#Properties-of-LL-1-Grammars" class="headerlink" title="Properties of LL(1) Grammars"></a>Properties of LL(1) Grammars</h2><p>A grammar G is LL(1) if and only if the following conditions hold for two  distinctive production rules A → α and A → β</p><ol><li><p><em>Both α and β <strong>cannot</strong> derive strings starting with same terminals.</em> </p><p><strong>不能有公共左因子（因为会使得M[A, a]表项有2个或2个以上的产生式供选择，产生不确定性）</strong></p></li><li><p><em>At most one of α and β  can derive to ε.</em></p><p><strong>至多有一个可能为空（如果两个都为空，那么M[A, b]&#x2F;&#x2F;b∈FOLLOW(A)&#x2F;&#x2F;表项中会有2个或2个以上的产生式进行选择）</strong></p></li><li><p><em>If β can derive to ε , then α cannot derive to any string starting with a  terminal in FOLLOW(A).</em></p></li></ol><p>   <strong>如果β为空，α不为空，那么First(α) ∩ Follow(A) &#x3D; Ф</strong>，否则那么M[A, b]&#x2F;&#x2F;b∈FOLLOW(A)&#x2F;&#x2F;表项中会有2个或2个以上的产生式进行选择）</p><blockquote><p>不符合上述三个条件之一，都可能产生不确定性。</p><p>第二条和第三条可以合并</p></blockquote><h2 id="判断CFG是否为LL-1-文法"><a href="#判断CFG是否为LL-1-文法" class="headerlink" title="判断CFG是否为LL(1)文法"></a>判断CFG是否为LL(1)文法</h2><p><strong>硬着头皮做Parsing Table，看表项是否唯一。</strong></p><blockquote><p>注：若题目判读是不是LL(1)文法:（有2种选择）</p></blockquote><ol><li><p><strong>不用做预处理</strong>，直接判断是不是LL(1)（判断左因子、左递归以及LL(1)性质）。</p></li><li><p><strong>做了预处理，得到等价文法</strong>，构建出预测表，判断是不是LL(1)文法</p><ol><li>如果是，那么回答：预处理后的文法是LL(1)文法；</li><li>不是，直接回答不是LL(1)文法。</li></ol></li></ol><h1 id="Lecture-10-Bottom-Up-Parsing-I"><a href="#Lecture-10-Bottom-Up-Parsing-I" class="headerlink" title="Lecture 10 Bottom-Up Parsing I"></a>Lecture 10 Bottom-Up Parsing I</h1><p>自底向上：<strong>规约</strong>的过程</p><p>由句子（叶子节点）规约到开始符（根节点）</p><h2 id="Shift-Reduce-Parsing"><a href="#Shift-Reduce-Parsing" class="headerlink" title="Shift-Reduce Parsing"></a>Shift-Reduce Parsing</h2><ul><li><p>Shift 转换</p></li><li><p>Reduce 归约</p></li></ul><p>Shift-Reduce Parsing – Example</p><img src="/.com//08/27/Compiler/image-20220508173759905.png" class title="image-20220508173759905"><blockquote><ul><li><p><input disabled type="checkbox"> ？为什么能这样归约？</p></li><li><p><input disabled type="checkbox"> ？为什么是最右推导？</p></li><li><p><input checked disabled type="checkbox"> ？什么样的子串能进行归约？——产生式右边才有可能被规约→句柄</p></li></ul></blockquote><h2 id="Handle-句柄"><a href="#Handle-句柄" class="headerlink" title="Handle 句柄"></a>Handle 句柄</h2><p><strong>Informally</strong>, a handle (句柄) of a string is a <strong>substring that matches the right side of a production rule.</strong> <u>But not every substring matches the right side of a production rule is handle.</u></p><ul><li><p><strong>只有出现在产生式右边的（必要条件）</strong><u><code>才有可能</code></u>被归约。</p></li><li><p><strong>Formally Def</strong>: 句柄β<u>一定是在<strong>产生式的右边</strong>且一定是<strong>在最右推导过程中所使用的产生式的右边</strong>。</u></p></li></ul><blockquote><p>注意区分：句子、句型、句柄</p><p>句子：由开始符出发，经过一系列的替换&#x2F;重写，得到只有终结符组成的strings（句子）。S ⇒(+) w，w不包含非终结符。</p><p>句型：S ⇒(*) w，w包含非终结符，我们称之为句型。由开始符出发推导到句子过程中的中间形式。</p><p>句柄：最右推导中所使用的产生式的右边部分。</p></blockquote><p> 💡 核心：找句柄——句柄裁剪</p><h3 id="句柄裁剪"><a href="#句柄裁剪" class="headerlink" title="句柄裁剪"></a>句柄裁剪</h3><img src="/.com//08/27/Compiler/image-20220508173904084.png" class title="image-20220508173904084"><h2 id="Shift-Reduce-Parser"><a href="#Shift-Reduce-Parser" class="headerlink" title="Shift-Reduce Parser"></a>Shift-Reduce Parser</h2><h3 id="基于栈实现Shift-Reduce-Parser"><a href="#基于栈实现Shift-Reduce-Parser" class="headerlink" title="基于栈实现Shift-Reduce Parser"></a>基于<strong>栈</strong>实现Shift-Reduce Parser</h3><img src="/.com//08/27/Compiler/image-20220508174010221.png" class title="image-20220508174010221"><p>💡 机器该怎么做？</p><p>There are four <strong>possible actions</strong> of a shift-parser action:</p><ol><li><p><code>Shift</code> : The next input symbol is <strong>shifted onto the top of the stack.</strong></p><p>将指针指向的token<u>放入栈</u>里面。指针后移。</p></li><li><p><code>Reduce</code>: <strong>Replace the handle on the top of the stack by the nonterminal.</strong></p><p>用<u>产生式左边的非终结符替换</u>栈顶的句柄。</p></li><li><p>Accept: Successful completion of parsing.</p><p>成功结束分析（到达开始符）</p></li><li><p>Error: Parser discovers a syntax error, and calls an error recovery routine.</p></li></ol><blockquote><p>Initial stack just contains only the end-marker $. 初始化栈只有终止符 $</p></blockquote><p>Example: Stack, Input, Action(Table Driven), Output</p><img src="/.com//08/27/Compiler/image-20220508174033391.png" class title="image-20220508174033391"><p>💡 核心：<strong>表</strong>——告诉你用什么产生式进行归约替换（规约预测表）</p><ul><li><p>Shift：将id push进stack</p></li><li><p>Reduce：把id归约成F，即把id pop出来，把F push进去（替换句柄）</p></li><li><p>直至栈到达<strong>开始符</strong>，此时解析成功。</p></li></ul><h3 id="LR-1-与LL-1"><a href="#LR-1-与LL-1" class="headerlink" title="LR(1)与LL(1)"></a>LR(1)与LL(1)</h3><p>LR(k)：L从左至右扫描 R最右推导 (k)往前看k个</p><ul><li><p>框架一样：input output stack table</p></li><li><p>分析方法不同，表不同</p></li></ul><p>LR-Parsers covers wide range of grammars.</p><ul><li><p>SLR – simple LR parser </p></li><li><p>LR – most general LR parser</p></li><li><p>LALR – intermediate LR parser (lookhead LR parser) 优化后的LR Parser，介于SLR与LR之间</p></li><li><p>SLR, LR and LALR <strong>work same, only their parsing tables are different.</strong> 工作机制一样，分析表不同</p></li></ul><h3 id="LR-Parser-Algorithm——SLR-Parsing"><a href="#LR-Parser-Algorithm——SLR-Parsing" class="headerlink" title="LR Parser Algorithm——SLR Parsing"></a>LR Parser Algorithm——SLR Parsing</h3><img src="/.com//08/27/Compiler/image-20220509103638858.png" class title="image-20220509103638858"><p><strong>Action Table</strong></p><p>列：终结符 &amp; $</p><p>行：状态 states</p><blockquote><p>用于表示此时进行的行为 shift&#x2F;reduce</p></blockquote><p><strong>Goto Table</strong></p><p>列：非终结符</p><p>行：状态states</p><img src="/.com//08/27/Compiler/image-20220508174109496.png" class title="image-20220508174109496"><ul><li>栈顶Sm</li><li>指针指向ai（终结符或非终结符或$ + 状态信息）</li></ul><p>（Sm, ai）决定是shift&#x2F;reduce</p><p>pop&#x2F;push的时候是<strong>成对的(A附加状态的信息）</strong>pop&#x2F;push</p><ul><li><p>Action Table: 栈顶元素和<strong>终结符&#x2F;$</strong> match，此时要进行什么样的动作？ shift&#x2F;reduce</p><p>因此列为终结符 &amp; ‘$’</p></li><li><p>Goto Table：当归约到<strong>非终结符</strong>时，要给出怎么样的状态信息</p><p>因此列为非终结符</p></li></ul><h3 id="Actions-of-A-LR-Parser"><a href="#Actions-of-A-LR-Parser" class="headerlink" title="Actions of A LR Parser"></a>Actions of A LR Parser</h3><ol><li>shift s</li><li>reduce A → β<ol><li>pop 2|β| items from back 成对地pop</li><li>push A and s（成对地push）where s &#x3D; goto[$S_{m-r},A$]（查看Goto Table：<strong>栈顶S &amp; 归约的非终结符</strong>A 对应的状态s）</li></ol></li><li>accept-解析成功，分析停止</li><li>error-检测到错误状态</li></ol><img src="/.com//08/27/Compiler/image-20220508174210040.png" class title="image-20220508174210040"><p><strong>表 Example:</strong></p><img src="/.com//08/27/Compiler/image-20220508174220540.png" class title="image-20220508174220540"><ul><li>(0,id)&#x3D;S<strong>5</strong>，表示动作为shift，push(id, <strong>状态5</strong>) into stack</li><li>(2,+)&#x3D;R<strong>2</strong>，表示动作为reduce，栈顶先<strong>成对地</strong>pop，用<strong>产生式（2）</strong>进行归约，并且要看GOTO TABLE中非终结符E对应的状态，再<strong>成对</strong>地push(E, s）</li></ul><img src="/.com//08/27/Compiler/image-20220508174242625.png" class title="image-20220508174242625"><p>💡 什么时候开始？——开始找句柄</p><h3 id="Constructing-SLR-Parsing-Tables-–-LR-0-Item"><a href="#Constructing-SLR-Parsing-Tables-–-LR-0-Item" class="headerlink" title="Constructing SLR Parsing Tables – LR(0) Item"></a>Constructing SLR Parsing Tables – LR(0) Item</h3><p>item: 表示可能的状态</p><p>An LR(0) item of a grammar G is a production of G <strong>a dot</strong> at the some position of the right side.</p><p>A → aBb</p><p>Possible LR(0) Items: (four different possibility) 针对一个产生式，找可能句柄</p><ul><li>A → .aBb 准备开始要找a了</li><li>A → a.Bb 找完a，准备开始找B了</li><li>A → aB.b</li><li>A → aBb. 找完了</li></ul><p>【这里不太懂】</p><p>注：A→空串 <strong>只有一种可能的状态</strong></p><h1 id="Lecture-11-Bottom-Up-Parsing-II"><a href="#Lecture-11-Bottom-Up-Parsing-II" class="headerlink" title="Lecture 11 Bottom-Up Parsing II"></a>Lecture 11 Bottom-Up Parsing II</h1><h2 id="Constructing-SLR-Parsing-Tables"><a href="#Constructing-SLR-Parsing-Tables" class="headerlink" title="Constructing SLR Parsing Tables"></a>Constructing SLR Parsing Tables</h2><p>💡 states 到底是什么？</p><h3 id="LR-0-Item"><a href="#LR-0-Item" class="headerlink" title="LR(0) Item"></a>LR(0) Item</h3><p>An LR(0) item of a grammar G is a production of G a dot at the some position of the right side.</p><p>Ex: A → aBb 有4种可能的LR(0) Item:</p><ul><li><p>A → .aBb 开始分析</p></li><li><p>A → a.Bb &amp; A → aB.b 中间项</p></li><li><p>A → aBb. 结束分析</p></li></ul><p>针对所有的文法，找到整个文法的第一个项。</p><p><strong>Augmented Grammar: 扩展文法</strong> </p><p>G’ is G with a new production rule <strong>S’→S</strong> where S’ is the new starting symbol. 创造文法的新的、唯一的开始符 S‘。</p><blockquote><p>why</p></blockquote><h3 id="Closure-Operation-闭包算子"><a href="#Closure-Operation-闭包算子" class="headerlink" title="Closure Operation 闭包算子"></a>Closure Operation 闭包算子</h3><p>If I is a set of LR(0) items for a grammar G, then closure(I) is the set of LR(0) items constructed from I by the two rules:</p><ol><li><p>Initially, every LR(0) item in I is added to closure(I).</p></li><li><p>If <code>A → α.Bβ</code> （即将要分析B&#x2F;非终结符 ↔ B的产生式的第一项加进来）is in closure(I) and B→γ is a production rule of G; then <code>B→.γ</code> （B的产生式即将开始分析）will be in the closure(I). （放在一个closure里面）</p><p>We will apply this rule until no more new LR(0) items can be added to closure(I).</p></li></ol><p>Ex:</p><img src="/.com//08/27/Compiler/image-20220509165715178.png" class title="image-20220509165715178"><h3 id="Goto-Operation"><a href="#Goto-Operation" class="headerlink" title="Goto Operation"></a>Goto Operation</h3><p>If I is a set of LR(0) items and <strong>X is a grammar symbol (terminal or nonterminal)</strong>, then goto(I,X) is defined as follows:</p><p><u>LR(0) Item的集合，识别终结符或非终结符后，到达另一个新的集合。</u></p><p>If <code>A → α.Xβ</code> in <em><strong>I</strong></em> then every item in <code>closure(&#123;A → αX.β&#125;)</code> （把X分析完了）will be in <code>goto(I,X)</code> （在I里面，找到能识别完X的）goto动作：表示X分析完了。</p><img src="/.com//08/27/Compiler/image-20220509170128986.png" class title="image-20220509170128986"><blockquote><p>注：要把<strong>闭包</strong>加进去。</p></blockquote><h3 id="Construction-of-The-Canonical-LR-0-Collection"><a href="#Construction-of-The-Canonical-LR-0-Collection" class="headerlink" title="Construction of The Canonical LR(0) Collection"></a>Construction of The Canonical LR(0) Collection</h3><p> LR(0)的集簇——集合的集合</p><p>机器<u>对所有的终结符和非终结符进行Goto函数</u>，看到达怎样的集合。</p><p>Ex:</p><img src="/.com//08/27/Compiler/image-20220509171041538.png" class title="image-20220509171041538"><p>I0项：E’ → .E (初状态，不出现在最后的表中，代表分析的开始)</p><p>I1项：E’ → E.(表示开始符E都被归约了，说明accept，表示分析的结束)</p><p>…</p><p><strong>所有的状态数：I0~I11。</strong></p><blockquote><p><strong>一旦找到了整个集簇，那么语法分析表就可以完成。</strong></p></blockquote><h3 id="Constructing-SLR-Parsing-Table"><a href="#Constructing-SLR-Parsing-Table" class="headerlink" title="Constructing SLR Parsing Table"></a>Constructing SLR Parsing Table</h3><p>(of an augumented grammar G’) 最首要的是<strong>扩展文法</strong></p><blockquote><p>优化？ 不用扩展文法。——只有一个产生式的时候。这样做不合适。</p></blockquote><ol><li><p>Construct the <em>canonical collection</em> of sets of LR(0) items for G’. 构建LR(0)项集集簇。</p><p>C←{I0,…,In} 状态数目n+1（行）</p></li><li><p>Create the parsing <em><strong>action table</strong></em> as follows:</p><ol><li><p>If a is a terminal, <code>A→α.aβ</code> in Ii and goto(Ii,a)&#x3D;Ij then <strong>action[i,a]</strong> is <code>shift j</code>. </p><p>若a是终结符，A→α.aβ在Ii项中，且goto(Ii, a) &#x3D; Ij，那么action[i, a] 为 <em>shift j</em> (sj)；</p></li><li><p>If <strong>A→α.</strong> is in Ii, then action[i,a] is <code>reduce A → α</code> for <strong>all a in FOLLOW(A) where A ≠ S’.</strong></p><p>若A→α.在Ii项中（找到产生式可能被归约），那么是归约，action[i,a] 为 reduce A→ α，放在FOLLOW(A)列里面且 A ≠ S’；</p></li><li><p>If <strong>S’→S.</strong> is in Ii, then action[i,$] is <code>accept</code>.</p><p>结束分析，endmark。</p></li><li><p>If any conflicting actions generated by these rules, the grammar is not SLR(1).</p></li></ol></li><li><p>Create the parsing <em><strong>goto table</strong></em> :</p><ol><li><p>for all non-terminals A, if goto(Ii,A)&#x3D;Ij then goto[i,A]&#x3D;j</p><p>对于所有非终结符，如果goto(Ii, A) &#x3D; Ij，那么goto[i, A] &#x3D; j</p></li></ol></li><li><p>All entries not defined by (2) and (3) are errors.</p></li><li><p>Initial state of the parser contains S’ → .S</p></li></ol><h2 id="SLR-Conflicts"><a href="#SLR-Conflicts" class="headerlink" title="SLR Conflicts"></a>SLR Conflicts</h2><blockquote><p>对于SLR文法来说，也是要求<strong>无二义性</strong>的。是不是所有无二义性的都说SLR文法？——不一定。</p></blockquote><p>问题出现在哪？冲突。不确定的动作。</p><h3 id="shift-reduce-and-reduce-reduce-conflicts"><a href="#shift-reduce-and-reduce-reduce-conflicts" class="headerlink" title="shift-reduce and reduce-reduce conflicts"></a>shift-reduce and reduce-reduce conflicts</h3><blockquote><p>shift&#x2F;shift冲突不会出现。 why？在刚才的方法中，<u>一次指针只指向一个符号，每次只处理一个，不会出现shift-shift冲突</u></p></blockquote><p><strong>Ex 1: Shift-Reduce冲突——不知道是该shift还是该reduce。</strong></p><img src="/.com//08/27/Compiler/image-20220509213548044.png" class title="image-20220509213548044"><p>action table中，<u>action[2, &#x3D;]表项既有可能是shift 6，又有可能是reduce R → L</u>。此时出现<strong>shift-reduce冲突</strong>。</p><p>Q: SLR &amp; LLR？哪个表达能力更强？</p><p><strong>Ex 2: Reduce-Reduce冲突——不知道用哪个产生式进行归约。</strong></p><img src="/.com//08/27/Compiler/image-20220509214030759.png" class title="image-20220509214030759"><p>由于FOLLOW(A)与FOLLOW(B)有交集{a, b}，所以在规约时，不知道用哪一条产生式进行规约，产生不确定性。</p><blockquote><p>解决方案：明确告诉遇到a用哪条归约、遇到b用哪条归约。</p></blockquote><h1 id="Lecture-12-Bottom-Up-Parsing-III"><a href="#Lecture-12-Bottom-Up-Parsing-III" class="headerlink" title="Lecture 12 Bottom-Up Parsing III"></a>Lecture 12 Bottom-Up Parsing III</h1><p>LR(0) &amp; LR(<strong>1</strong>) Item的区别：</p><p>A → α.β, a where <strong>a</strong> is the <strong>look-ahead</strong>.  解决reduce&#x2F;reduce 冲突。</p><h2 id="LR-1-Item"><a href="#LR-1-Item" class="headerlink" title="LR(1) Item"></a>LR(1) Item</h2><img src="/.com//08/27/Compiler/image-20220516151000068.png" class title="image-20220516151000068"><p>LR(1) Item: <code>A➡α.β, a</code>（分析完α，将要分析β，看到了a要进行归约）</p><img src="/.com//08/27/Compiler/image-20220516151244327.png" class title="image-20220516151244327"><p>额外信息 a ∈ FOLLOW(A)</p><h2 id="Canonical-Collection-of-Sets-of-LR-1-Items"><a href="#Canonical-Collection-of-Sets-of-LR-1-Items" class="headerlink" title="Canonical Collection of Sets of LR(1) Items"></a>Canonical Collection of Sets of LR(1) Items</h2><p>LR(1)项的集簇</p><p><strong>closure(I)</strong> is: ( where I is a set of LR(1) items) </p><ul><li><p>every LR(1) item in I is in closure(I) </p></li><li><p>if A→α.Bβ, a in closure(I) and B→γ is a production rule of G; then <code>B→.γ, b</code> will be in the closure(I) for each terminal <code>b in FIRST(βa)</code> ，其中a∈FOLLOW(A)。【若β为空，则为FIRST(a)】</p></li><li><p>增加了额外信息</p></li></ul><p><strong>goto operation</strong> </p><p>If I is a set of LR(1) items and X is a grammar symbol  (terminal or non-terminal), then goto(I,X) is defined as  follows: </p><ul><li>If A→α.Xβ, a in I  then <strong>every item in closure({A → α.Xβ, a}) will be in  goto(I,X)</strong>.</li><li>对于goto函数来说，A→α.Xβ 分析完X后，<strong>额外信息没有改变</strong>。但是在新的集合的闭包中，可能会出现新的额外信息。</li></ul><p>Example:</p><img src="/.com//08/27/Compiler/image-20220516153412624.png" class title="image-20220516153412624"><h2 id="Constructing-LR-1-Table"><a href="#Constructing-LR-1-Table" class="headerlink" title="Constructing LR(1) Table"></a>Constructing LR(1) Table</h2><ol><li><p>Construct the <em>canonical collection</em> of sets of LR(0) items for G’. 构建LR(0)项集集簇。</p><p>C←{I0,…,In} 状态数目n+1（行）</p></li><li><p>Create the parsing <em><strong>action table</strong></em> as follows:</p><ol><li><p>If a is a terminal, <code>A→α.aβ, b</code> in Ii and goto(Ii,a)&#x3D;Ij then <strong>action[i,a]</strong> is <code>shift j</code>. </p><p>若a是终结符，A→α.aβ, b在Ii项中，且goto(Ii, a) &#x3D; Ij，那么action[i, a] 为 <em>shift j</em> (sj)；</p></li><li><p>If <code>A→α., a</code> is in Ii, then action[i,a] is <code>reduce A → α</code> for <strong>where A ≠ S’.</strong></p><p>若A→α., a在Ii项中（找到产生式可能被归约），那么是归约，action[i,a] 项为 reduce A→ α；(额外信息为a，看到a就进行归约，<strong>不用计算FOLLOW(A)了</strong>)</p></li><li><p>If <strong>S’→S., $</strong> is in Ii, then action[i,$] is <code>accept</code>.</p><p>结束分析，endmark。</p></li><li><p>If any conflicting actions generated by these rules, the grammar is not SLR(1).</p></li></ol></li><li><p>Create the parsing <em><strong>goto table</strong></em> :</p><ol><li><p>for all non-terminals A, if goto(Ii,A)&#x3D;Ij then goto[i,A]&#x3D;j</p><p>对于所有非终结符，如果goto(Ii, A) &#x3D; Ij，那么goto[i, A] &#x3D; j</p></li></ol></li><li><p>All entries not defined by (2) and (3) are errors.</p></li><li><p>Initial state of the parser contains <code>S’ → .S, $</code>（第一项一定是拓展文法S’）</p></li></ol><p>Ex:</p><img src="/.com//08/27/Compiler/image-20220516155942857.png" class title="image-20220516155942857"><p><strong>优化：既能解决SLR的Shift-Reduce冲突问题，又能减少状态数目——<em>合并类似的状态以减少状态数目</em>。</strong></p><h2 id="LALR-Parsing-Tables"><a href="#LALR-Parsing-Tables" class="headerlink" title="LALR Parsing Tables"></a>LALR Parsing Tables</h2><ul><li>LALR stands for <strong>LookAhead LR</strong></li><li>LALR parsers are often used in practice because LALR parsing  tables are <u>smaller than LR(1) parsing tables</u>. </li><li><u>The number of states in SLR and LALR parsing tables for a  grammar G are equal</u>.  （状态数与SLR一样）</li><li>But LALR parsers <u>recognize more grammars than SLR parsers</u>. （LALR表达能力 &gt; SLR)</li><li>YACC creates a LALR parser for the given grammar. </li><li>A state of LALR parser will be again a set of LR(1) items.</li></ul><img src="/.com//08/27/Compiler/image-20220516161243733.png" class title="image-20220516161243733"><blockquote><p>LR(0)项完全相同，附加信息不一样，那么合并成一个状态</p></blockquote><h2 id="Creation-of-LALR-Parsing-Tables"><a href="#Creation-of-LALR-Parsing-Tables" class="headerlink" title="Creation of LALR Parsing Tables"></a>Creation of LALR Parsing Tables</h2><ol><li><p>Create the canonical LR(1) collection of the sets of LR(1) items for the given grammar. </p></li><li><p>Find each core; find all sets having that same core; replace those sets having same cores  with a single set which is their union.  对于每一个核，如果<strong>他们有同心核，那么就合并</strong>（只是做了这个变化而已）。</p><p>C&#x3D;{I0 ,…,In } ➔ C’&#x3D;{J1 ,…,Jm} where m ≤ n </p></li><li><p>Create the parsing tables (action and goto tables) same as the construction of the parsing  tables of LR(1) parser. </p><p>Note that: If J&#x3D;I1∪ … ∪Ik since I1 ,…,Ik have same cores ➔ cores of goto(I1 ,X),…,goto(I2 ,X) must be same.  </p><p>So, goto(J,X)&#x3D;K where K is the union of all sets of items having same cores as  goto(I1 ,X). </p><p>【其他步骤与LR(1)完全一致】</p></li><li><p>If no conflict is introduced, the grammar is LALR(1) grammar</p></li></ol><blockquote><p>We say that we cannot introduce a shift&#x2F;reduce conflict during the shrink process for the creation of the states of a LALR parser.</p></blockquote><blockquote><p>But, we may introduce a reduce&#x2F;reduce conflict during the  shrink process for the creation of the states of a LALR  parser. <strong>只会产生reduce&#x2F; reduce冲突（因为合并了额外信息），不会产生shift&#x2F;reduce冲突</strong></p></blockquote><img src="/.com//08/27/Compiler/image-20220516195736046.png" class title="image-20220516195736046"><h2 id="Using-Ambiguous-Grammars"><a href="#Using-Ambiguous-Grammars" class="headerlink" title="Using Ambiguous Grammars"></a>Using Ambiguous Grammars</h2><p>发现冲突后，做一个合理的约束。</p><p>运算符左结合&#x2F;右结合、优先级</p><img src="/.com//08/27/Compiler/image-20220516200248310.png" class title="image-20220516200248310"><h1 id="Lecture-13-Semantic-Analysis-I"><a href="#Lecture-13-Semantic-Analysis-I" class="headerlink" title="Lecture 13 Semantic Analysis I"></a>Lecture 13 Semantic Analysis I</h1><p>什么是<strong>语义</strong>分析？分析这个<strong>句子的含义</strong>。</p><p><strong>基于上下文无关文法CFG的拓展</strong></p><p>Semantic Analyzer:</p><ul><li>Attribute Grammars 属性文法</li><li>Syntax Tree Construction 语法分析树</li><li>Top-Down Translators 自顶向下语法分析</li><li>Recursive Evaluators </li><li>Bottom-Up Translators 自底向上语法分析</li><li>Type Checking (next chapter) 类型检查</li></ul><blockquote><p>思考：语义分析中，比语法分析增加的是什么？</p></blockquote><img src="/.com//08/27/Compiler/image-20220523205220278.png" class title="image-20220523205220278"><h2 id="Syntax-Directed-Translation-语法制导翻译"><a href="#Syntax-Directed-Translation-语法制导翻译" class="headerlink" title="Syntax-Directed Translation 语法制导翻译"></a>Syntax-Directed Translation 语法制导翻译</h2><p><strong>依赖CFG进行拓展，基于语法翻译出意思</strong></p><ul><li>Grammar symbols are associated with <code>attributes</code> to associate information  with the programming language constructs that they represent.  只有<strong>属性</strong>才有可能赋予句子含义</li><li>Values of these attributes are evaluated by the semantic rules <strong>（语义规则）</strong> associated with the production rules. <ul><li>Evaluation of these semantic rules: </li><li>may generate intermediate codes</li><li>may put information into the symbol table</li><li>may perform type checking</li><li>may issue error messages</li><li>may perform some other activities </li><li>in fact, they may perform almost any activities.</li></ul></li><li>An attribute may hold almost any thing. <ul><li>a string, a number, a memory location, a complex record.</li></ul></li></ul><h2 id="Syntax-Directed-Definitions-and-Translation-Schemes"><a href="#Syntax-Directed-Definitions-and-Translation-Schemes" class="headerlink" title="Syntax-Directed Definitions and Translation Schemes"></a>Syntax-Directed Definitions and Translation Schemes</h2><ol><li>定义语义规则 —— Syntax-Directed Definitions <strong>语法制导定义</strong></li><li>如何使用语义规则？——Translation Schemes <strong>翻译模式</strong></li></ol><ul><li>indicate the order of evaluation of semantic actions associated with a production rule.  使用语义规则的顺序</li><li>In other words, translation schemes give a little bit information about implementation  details</li></ul><h3 id="Syntax-Directed-Definitions-语法制导定义"><a href="#Syntax-Directed-Definitions-语法制导定义" class="headerlink" title="Syntax-Directed Definitions 语法制导定义"></a>Syntax-Directed Definitions 语法制导定义</h3><ul><li>give high-level specifications for translations 告诉你定义好的语义规则</li><li>hide many implementation details such as order of evaluation of semantic actions. 隐藏实现细节</li><li>We associate a production rule with a set of semantic actions, and we do not say  when they will be evaluate 产生式&lt;-&gt;语义</li></ul><p>A syntax-directed definition is a generalization of a context-free grammar in which: （其实就是<strong>CFG语法分析的扩展模式</strong>）</p><ol><li><p>Each grammar symbol is associated with a set of attributes.  <u>每一个语法<strong>符号</strong>都对应着一系列<strong>属性</strong></u></p></li><li><p>This set of attributes for a grammar symbol is <strong>partitioned into two subsets</strong> called  <code>synthesized</code> and <code>inherited</code> attributes of that grammar symbol.  <u>属性集合分类为两个子集：综合 &amp; 继承</u>（哪些是重要的，哪些是不重要的）</p><p>综合：综合其他一系列属性得到的</p><p>继承：继承其他属性得到的</p></li><li><p>Each production rule is associated with a set of semantic rules.  每一个产生式都对应着一系列的语义规则</p></li></ol><p><strong>Semantic rules</strong> set up dependencies between attributes  which can be represented by a <strong>dependency graph</strong>.  依赖图</p><p>This dependency graph determines the <strong>evaluation order of  these semantic rules</strong>.</p><p>Evaluation of a semantic rule defines the value of an  attribute. But a semantic rule may also have some side  effects such as printing a value.</p><h4 id="Form-of-a-Syntax-Directed-Definition-Semantic-Rules"><a href="#Form-of-a-Syntax-Directed-Definition-Semantic-Rules" class="headerlink" title="Form of a Syntax-Directed Definition(Semantic Rules)"></a>Form of a Syntax-Directed Definition(Semantic Rules)</h4><p>In a syntax-directed definition, each production A→α is associated with <strong>a set of semantic rules</strong>(语义规则-函数形式) of the form: <code>b=f(c1 ,c2 ,…,cn )</code> where f is a function,  and b can be one of the followings:(b 代表属性值，f 代表函数)</p><ul><li><p>b is a <code>synthesized attribute</code> of A and c1 ,c2 ,…,cn are attributes of  the grammar symbols in the production ( A→α ).  </p><p>综合属性：<u>b是<strong>产生式左边A</strong>中某个symbol的属性值</u>，b来自于α的计算结果</p><ul><li><strong>A的属性b</strong>的值一定来源于A右边α属性和A自身其他属性的计算结果。</li></ul></li><li><p>b is an <code>inherited attribute</code> of one of the grammar symbols in α (on the <u>right side of the production</u>), and c1 ,c2 ,…,cn are attributes  of the grammar symbols in the production ( A→α ). </p><ul><li>继承属性：<u>b是<strong>产生式右边α</strong>的某个symobl的属性</u></li></ul></li></ul><p>Synthesized attribute Ex:</p><img src="/.com//08/27/Compiler/image-20220523211742461.png" class title="image-20220523211742461"><ul><li>E.val, T.val, F.val represent for their attrubutes.</li><li>lexval is evaluated by the lexical analyzer.</li></ul><p>以上都是综合属性，<strong>A的属性值通过α计算得来</strong>。</p><p>E.val &#x3D; E1.val + T.val, what is E1 meaning? 在语义中，<strong>不同时刻含义&#x2F;属性值不一样</strong>（？）E &amp; E1是为了区分2个不同时刻下E的不同的值。</p><p>Inherited Attribute Ex:</p><h4 id="Attribute-Grammar-属性文法"><a href="#Attribute-Grammar-属性文法" class="headerlink" title="Attribute Grammar 属性文法"></a>Attribute Grammar 属性文法</h4><ol><li>每个symbol有一系列属性</li><li>每个产生式有一系列规则</li><li>属性文法是上下文无关文法（语法规则） + 语义规则</li></ol><p>So, a semantic rule b&#x3D;f(c1 ,c2 ,…,cn ) indicates that the <strong>attribute b depends on attributes c1 ,c2 ,…,cn</strong> . </p><p>In a syntax-directed definition, a semantic rule may  just evaluate a value of an attribute or it may have  some side effects such as printing values</p><h4 id="Annotated-Parse-Tree-注释语法树"><a href="#Annotated-Parse-Tree-注释语法树" class="headerlink" title="Annotated Parse Tree 注释语法树"></a>Annotated Parse Tree 注释语法树</h4><ul><li>Parse-tree that also shows the values of the <strong>attributes at each node</strong>.  每一个节点有属性值</li><li>Attributes in the leaves of the annotated parse-tree are determined  by the lexical analyzer. </li><li>Values of attributes in inner nodes of annotated parse-tree are  determined by the semantic-rules.  属性值通过语义规则计算出来</li><li>If a syntax-directed definition employs only Synthesized attributes  the evaluation of all attributes can be done in a bottom-up fashion. </li><li>Inherited attributes would require more arbitrary “traversals” of the  annotated parse-tree. </li><li>A <strong>dependency graph</strong> suggests possible evaluation orders for an  annotated parse-tree.  依赖图——计算的顺序</li></ul><p>EX：语法树：d + d*d</p><img src="/.com//08/27/Compiler/image-20220524075322963.png" class title="image-20220524075322963"><blockquote><p>上述依赖树计算属性值实则为<strong>bottom-up 的过程</strong></p></blockquote><img src="/.com//08/27/Compiler/image-20220524150601309.png" class title="image-20220524150601309"><p>L.in &#x3D; T.type ⇒ 继承属性（产生式右边一个symbol的属性）</p><p>L1.in &#x3D; L.in ⇒ 继承属性</p><blockquote><p>一个symbol的同一个属性，不可能既是综合属性又是继承属性</p></blockquote><img src="/.com//08/27/Compiler/image-20220524150610190.png" class title="image-20220524150610190"><img src="/.com//08/27/Compiler/image-20220524151153668.png" class title="image-20220524151153668"><blockquote><p>可以看出，继承属性的依赖图无规律，综合属性的依赖图更有规律，是Bottom-Up的过程。</p><p>结论：综合属性比继承属性更容易算。</p></blockquote><p>依赖图：</p><img src="/.com//08/27/Compiler/image-20220524151237625.png" class title="image-20220524151237625"><h4 id="S-Attribute-Definitions-amp-L-Attribute-Definition"><a href="#S-Attribute-Definitions-amp-L-Attribute-Definition" class="headerlink" title="S-Attribute Definitions &amp; L-Attribute Definition"></a>S-Attribute Definitions &amp; L-Attribute Definition</h4><ul><li>S-Attributed Definitions: <strong>only synthesized attributes</strong> used in the syntax-directed  definitions. <u>只含有综合属性</u></li><li>L-Attributed Definitions: in addition to synthesized attributes, we may also use inherited attributes in a restricted fashion. <u>既有综合属性又有继承属性</u></li></ul><h1 id="Lecture-14-Semantic-Analysis-II"><a href="#Lecture-14-Semantic-Analysis-II" class="headerlink" title="Lecture 14 Semantic Analysis II"></a>Lecture 14 Semantic Analysis II</h1><img src="/.com//08/27/Compiler/image-20220601175248880.png" class title="image-20220601175248880"><p>在语法分析过程中，额外<strong>借助一个栈val-stack进行语义分析。</strong></p><img src="/.com//08/27/Compiler/image-20220601180012157.png" class title="image-20220601180012157"><h2 id="L-Attributed-Definitions"><a href="#L-Attributed-Definitions" class="headerlink" title="L-Attributed Definitions"></a>L-Attributed Definitions</h2><p><strong>S-Attributed Definitions can be efficiently implemented. 综合属性都能被解决</strong></p><p><strong>We are looking for a larger (larger than S-Attributed Definitions)</strong> <strong>subset of syntax-directed definitions which can be efficiently</strong> <strong>evaluated.</strong> </p><p><strong>➔</strong> <strong>L-Attributed Definitions</strong></p><p><strong>L-Attributed Definitions can always be evaluated by the depth first</strong> <strong>visit of the parse tree.</strong> <img src="/.com//08/27/Compiler/image-20220601225513829.png" class title="image-20220601225513829"></p><blockquote><p>通俗来说，<strong>L属性文法中的继承属性一定只能依赖于哥哥姐姐 或 父辈，而不能来自于后面的弟弟妹妹。</strong></p></blockquote><p>是L属性文法， EX：</p><img src="/.com//08/27/Compiler/image-20220601225744443.png" class title="image-20220601225744443"><img src="/.com//08/27/Compiler/image-20220828093105442.png" class title="image-20220828093105442"><p>不是L属性文法，EX：</p><img src="/.com//08/27/Compiler/image-20220601234042228.png" class title="image-20220601234042228"><blockquote><p>Q的属性值依赖于R的属性值，【不能依赖于弟弟妹妹】</p></blockquote><h2 id="Translation-Schemes-翻译模式"><a href="#Translation-Schemes-翻译模式" class="headerlink" title="Translation Schemes 翻译模式"></a>Translation Schemes 翻译模式</h2><p>告诉如何(什么时候)使用语义规则。</p><ul><li>attributes are associated with the grammar symbols and</li><li>semantic actions enclosed between braces {} are inserted within the right sides of productions.</li><li>翻译模式就是将语义规则插入在产生式中</li></ul><p>Ex: A ➡ {…}X{…}Y{…} <u>把语义规则插入产生式中</u>，意味着<u>语义规则的执行顺序</u>。</p><p><strong>S属性文法的翻译模式：</strong></p><ul><li><p>For S-Attributed Definitions, we simply put all semantic rules into {…} at the rightmost of each production.</p></li><li><p><strong>语义规则用大括号括起来，放到产生式最后。</strong></p></li></ul><img src="/.com//08/27/Compiler/image-20220602002549415.png" class title="image-20220602002549415"><p><strong>L属性文法的翻译模式：</strong></p><p>If both inherited and synthesized attributes are involved:</p><ul><li>An inherited attribute for a symbol on the RHS of a production must be <strong>computed in an action before that symbol</strong>. 继承属性语义规则在语法规则之前</li><li>An action must not refer to a synthesized attribute of a symbol that is to the right.</li><li>A synthesized attribute for the NT on the LHS can only be computed after all attributes it references are already computed. (the action for such attributes is typically placed in the rightmost end of the production)</li></ul><blockquote><p>未见其人，先闻其声。</p><p>想要对继承属性进行语法分析，要先得到它的属性值 继承属性计算规则⇒放在继承属性语法规则之前</p></blockquote><p>EX：判断是不是正确的翻译模式。</p><img src="/.com//08/27/Compiler/image-20220602002756943.png" class title="image-20220602002756943"><blockquote><p>不是正确的翻译模式。<strong>综合属性的语义规则应该在最后。</strong>因为是右边所有属性算完之后才能得到综合属性的值。</p></blockquote><img src="/.com//08/27/Compiler/image-20220602002844823.png" class title="image-20220602002844823"><blockquote><p>不符合翻译模式。因为在分析A1, A2之前，要求先有A1, A2继承属性的值。那么**把A1, A2语义规则放在分析A1, A2之前。</p></blockquote><h3 id="A-Translation-Scheme-Example"><a href="#A-Translation-Scheme-Example" class="headerlink" title="A Translation Scheme Example"></a>A Translation Scheme Example</h3><img src="/.com//08/27/Compiler/image-20220602003700670.png" class title="image-20220602003700670"><p>语法分析的同时，又做了语义分析。</p><p>得到注释语法树：</p><blockquote><p>从左至右看<strong>红色部分（语义分析）</strong>，得到：ab+c+</p></blockquote><img src="/.com//08/27/Compiler/image-20220602004145792.png" class title="image-20220602004145792"><h3 id="Top-Down-Translation"><a href="#Top-Down-Translation" class="headerlink" title="Top-Down Translation"></a>Top-Down Translation</h3><p>LL(1) 预测语法分析</p><p>For each nonterminal, 对于非终结符</p><ul><li>inherited attributes → formal parameters 继承属性可以看作 <strong>形参</strong></li><li>synthesized attributes → returned values 综合属性看作 <strong>返回值</strong></li></ul><img src="/.com//08/27/Compiler/image-20220827092429691.png" class title="image-20220827092429691"><p>For each production, 对于每条产生式</p><ul><li><p>for each terminal X with synthesized attribute x,</p><p>​save X.x; match(X);</p></li><li><p>for nonterminal B, c :&#x3D; B(b1 , b2 , …, bk );</p></li><li><p>for each semantic rule, copy the rule to the parser</p></li></ul><p>Ex:</p><img src="/.com//08/27/Compiler/image-20220602172027629.png" class title="image-20220602172027629"><p>在Top-Down过程中，我们做了预处理（消除左递归和左因子），那么语义规则要如何改变？</p><p>消除左递归 EX：</p><img src="/.com//08/27/Compiler/image-20220602173641311.png" class title="image-20220602173641311"><ol><li>消除左递归</li><li>属性文法的修改——靠E‘传递值 （E’的属性怎么得到？）<ol><li>E’.<strong>in 继承属性</strong>，既要继承T的值，又要继承原来表达式的E1.val</li><li><strong>E’.in 作为形参传递到E’.syn （桥梁）</strong></li><li>E’.<strong>syn 综合属性</strong>，作为返回值给E.val</li></ol></li></ol><h4 id="消除左递归"><a href="#消除左递归" class="headerlink" title="消除左递归"></a>消除左递归</h4><p>【要记忆】</p><img src="/.com//08/27/Compiler/image-20220602174235897.png" class title="image-20220602174235897"><p>新增A’有两个属性：in（继承属性，作为形参）&amp; syn（综合属性，作为返回值）</p><p>桥梁：A‘ → ∈ {A’.syn &#x3D; A’.in}</p><h3 id="Bottom-Up-Translation"><a href="#Bottom-Up-Translation" class="headerlink" title="Bottom-Up Translation"></a>Bottom-Up Translation</h3><h4 id="Removing-Embedding-Semantic-Actions"><a href="#Removing-Embedding-Semantic-Actions" class="headerlink" title="Removing Embedding Semantic Actions"></a>Removing Embedding Semantic Actions</h4><p>把L属性文法<u>转换为S属性文法</u></p><img src="/.com//08/27/Compiler/image-20220602174631059.png" class title="image-20220602174631059"><blockquote><p>语义动作用非终结符M替换。 M → <strong>空产生式{语义动作}</strong> 的形式。</p></blockquote><p>Ex:</p><img src="/.com//08/27/Compiler/image-20220602174753847.png" class title="image-20220602174753847"><h4 id="Problems"><a href="#Problems" class="headerlink" title="Problems"></a>Problems</h4><p>问题：是不是所有的L属性文法都能用Bottom-Up做？</p><p>Some L-attributed definitions based on LR grammars cannot be evaluated during bottom-up parsing.</p><img src="/.com//08/27/Compiler/image-20220602175119808.png" class title="image-20220602175119808"><p>即使将L属性文法转换为S属性文法的形式，也有可能没法用Bottom-Up进行语义分析。</p><h1 id="Lecture-15-Type-Checking"><a href="#Lecture-15-Type-Checking" class="headerlink" title="Lecture 15 Type Checking"></a>Lecture 15 Type Checking</h1><p>经典的语义分析工具——类型检查。</p><p>类型检查可以作为比较完整的语义分析器。<strong>静态分析工具</strong>。</p><img src="/.com//08/27/Compiler/image-20220606132952250.png" class title="image-20220606132952250"><h2 id="Type-System-类型系统"><a href="#Type-System-类型系统" class="headerlink" title="Type System 类型系统"></a>Type System 类型系统</h2><p>A <strong>type system</strong> is a collection of rules for assigning type  expressions to the parts of a program.  一系列的语义规则组成。</p><p>A <strong>type checker</strong> implements a type system. 类型检查器（语义分析器）</p><p>强类型：编译器不接受任何类型错误。</p><h2 id="Type-Expression"><a href="#Type-Expression" class="headerlink" title="Type Expression"></a>Type Expression</h2><p>The type of language construct is denoted by a <strong>type expression</strong>.</p><blockquote><p><strong>结构归纳法使得自动化成为可能。</strong></p></blockquote><p>A type expression can be: 类型表达</p><p><strong>A basic type</strong> 基本类型</p><ul><li>a primitive data type such as integer, real, char, boolean, …   整型，实数型，布尔型等</li><li>type-error to signal a type error  类型错误</li><li>void : no type 空类型</li></ul><p><strong>A type name</strong> 类型名称</p><ul><li>a name can be used to denote a type expression.</li></ul><p><strong>A type constructor applies to other type expressions</strong>.</p><ul><li>arrays</li><li>products</li><li>pointers</li><li>functions</li></ul><p>The type checker is a translation scheme that synthesizes the type of each expression from the types of its sub-expressions.</p><h2 id="Type-Checking-of-Expressions"><a href="#Type-Checking-of-Expressions" class="headerlink" title="Type Checking of Expressions"></a>Type Checking of Expressions</h2><h2 id="Type-Checking-of-Statements"><a href="#Type-Checking-of-Statements" class="headerlink" title="Type Checking of Statements"></a>Type Checking of Statements</h2><img src="/.com//08/27/Compiler/image-20220606134824221.png" class title="image-20220606134824221"><h2 id="Structural-Equivalence-of-Type-Expressions"><a href="#Structural-Equivalence-of-Type-Expressions" class="headerlink" title="Structural Equivalence of Type Expressions"></a>Structural Equivalence of Type Expressions</h2><p>How do we know that two type expressions are equal? 如何判断两个类型表达式是相同的呢？</p><p>As long as type expressions are built from basic types (no type names), we may use structural equivalence between two type expressions 只要类型表达式时由基本类型构建的，就可以使用两个类型表达式之间的<strong>结构等价性</strong>。</p><h3 id="Names-for-Type-Expressions"><a href="#Names-for-Type-Expressions" class="headerlink" title="Names for Type Expressions"></a>Names for Type Expressions</h3><img src="/.com//08/27/Compiler/image-20220617105257365.png" class title="image-20220617105257365"><p>名字等价 vs. 结构等价</p><p>如果是<strong>名字等价</strong>，名字不一样就是不一样</p><p>如果是<strong>结构等价</strong>，内容一样则相等（？）</p><h2 id="Type-Coercions"><a href="#Type-Coercions" class="headerlink" title="Type Coercions"></a>Type Coercions</h2><p>类型融合</p><p><code>x+y</code>      x和y类型相同，才能继续做运算。</p><p>x: real y: int 类型融合处理&#x3D;&gt; y: int-&gt;real (强制转换？)</p><p>用到函数：</p><ul><li><p>inttoreal t1, y 表示要把y变成t1，也就是把0变成0.0。</p></li><li><p>real+  t2, x, t1 （将x和t1相加，把结果放进t2） 【三地址代码】</p></li></ul><h2 id="Overloading"><a href="#Overloading" class="headerlink" title="Overloading"></a>Overloading</h2><p>一个表达式能否有多个类型系统？</p><p>理论上，对机器来说是不允许的，带来了不确定性。同一个表达式不能用不同的类型。</p><ul><li><input disabled type="checkbox"> 作业题</li></ul><h1 id="Lecture-16-运行时环境"><a href="#Lecture-16-运行时环境" class="headerlink" title="Lecture 16 运行时环境"></a>Lecture 16 运行时环境</h1><img src="/.com//08/27/Compiler/image-20220619102839007.png" class title="image-20220619102839007"><p>编译器后端需要什么样的环境？</p><p><strong>存储</strong></p><img src="/.com//08/27/Compiler/image-20220619102946049.png" class title="image-20220619102946049"><h2 id="过程"><a href="#过程" class="headerlink" title="过程"></a>过程</h2><p>假定程序由若干个过程组成</p><p><strong>过程（procedure）</strong>定义</p><ul><li>一个过程<strong>活动(Activation)<strong>：该过程的</strong>一次执行</strong>（什么叫做执行？）</li><li>过程P一个活动的**生存期(Lifetime)**：从<u>执行该过程体第一步操作到最后一步操作之间的操作序</u>，<u>包括执行P时调用其它过程花费的时间</u></li><li>过程可以是<strong>递归</strong>的</li></ul><p>function &amp; procedure的区别？</p><ul><li><p><strong>函数</strong>（function）可以看作是一个过程（procedure）——完全符合过程的定义。</p></li><li><p><strong>过程是模块程序设计的主要手段，是节省程序代码和扩充语言的主要途径。</strong></p></li></ul><p>那么机器如何存储活动的生命周期呢？——Transition Diagram中的活动树</p><h3 id="活动树（Activation-Tree"><a href="#活动树（Activation-Tree" class="headerlink" title="活动树（Activation Tree)"></a>活动树（Activation Tree)</h3><p><strong>活动树中：</strong></p><p>➢ <strong>每一个节点代表一个活动</strong></p><p>➢ <strong>根节点代表主程序的活动</strong></p><p>➢ <strong>当且仅当控制流从活动a到活动b时，节点a就是节点b的父节点</strong></p><p>➢ <strong>当且仅当a的生存周期先于b的生存周期发生时，节点a在节点b的左边。</strong></p><p><strong>我们用一棵树来描绘控制进入和离开活动的方式</strong></p><p>Nested Structure: 网结构&#x2F;嵌套形式</p><p>靠什么知道过程执行完了？——参数</p><h2 id="参数传递"><a href="#参数传递" class="headerlink" title="参数传递"></a>参数传递</h2><p>传地址</p><ul><li>把实在<strong>参数的地址</strong>传递给相应的形式参数</li></ul><p><strong>得结果</strong></p><ul><li>传地址的一种变形（每个形参有2个存储单元：地址&amp;值）</li><li>例如， a &#x3D; z + x &#x3D; 7，a为最后计算出来的值</li></ul><p>传值</p><ul><li>把实在<strong>参数的值</strong>传递给相应的形式参数</li><li>例如，a &#x3D; a * w &#x3D; 40; a &#x3D; a + x &#x3D; 42;</li></ul><p><strong>传名</strong></p><ul><li>过程调用的作用相当于把被调用段的过程体抄到（<strong>copy</strong>）调用出现的地方，但把<strong>其中任一出现的形式参数都替换成相应的实参</strong>。</li><li>例如，a &#x3D; a * (a+b) &#x3D; 40; a &#x3D; a + (a-b) &#x3D; 77</li></ul><p>要想研究运行时环境，就是研究<strong>存储空间</strong>。</p><h2 id="运行时存储器的划分"><a href="#运行时存储器的划分" class="headerlink" title="运行时存储器的划分"></a>运行时存储器的划分</h2><p>编译程序为了组织存储空间，必须考虑下面几个问题：</p><ul><li>过程是否允许递归？</li><li>过程是否活动返回时，对局部名称的值如何处理？</li><li>过程是否允许引用非局部名称？</li><li>过程调用时如何传递参数；过程是否可以做为参数被传递和做为结果被返回？</li><li>存储空间可否在程序控制下进行动态分配？</li><li>存储空间是否必须显式地释放？</li></ul><p><strong>一个目标程序运行所需的存储空间包括</strong>:</p><ul><li><strong>存放目标代码的空间</strong></li><li><strong>存放数据项目的空间</strong></li><li><strong>存放程序运行的控制或连接数据所需单元（控制栈)</strong></li></ul><img src="/.com//08/27/Compiler/image-20220824094439850.png" class title="image-20220824094439850"><ul><li>控制栈。<strong>过程调用</strong>和<strong>返回</strong>通常由称为控制栈的运行时刻栈管理。</li><li>栈分配。对于那些允许或<strong>要求局部变量在它们的过程结束之后就不可访问</strong>的语言而言，局部变量的存储空间可以在运行时刻栈中分配。</li></ul><h3 id="活动记录（Activation-Records-x2F-Frame）"><a href="#活动记录（Activation-Records-x2F-Frame）" class="headerlink" title="活动记录（Activation Records &#x2F; Frame）"></a>活动记录（Activation Records &#x2F; Frame）</h3><p><strong>运行时，每当进入一个过程就有一个相应的活动记录累筑于栈顶。在堆栈中记录函数运行时各种信息和数据。</strong></p><ul><li>如何存储活动。</li></ul><ul><li><strong>返回地址</strong></li><li><strong>动态链：指向调用该过程前的最新活动记录地址的指针。</strong> （控制链）</li><li><strong>静态链：指向静态直接外层最新活动记录地址的指针，用来访问非局部数据。</strong>（访问链）<ul><li>控制链与访问链：控制链用于活动记录的正确切换，体现活动的嵌套关系；访问链用于访问非本地数据，体现过程的嵌套关系；</li></ul></li><li><strong>形式单元：存放相应的实在参数的地址或值。</strong> </li><li><strong>局部数据区：局部变量、内情向量、临时工作单元（如存放对表达式求值的结果）</strong></li></ul><img src="/.com//08/27/Compiler/image-20220824095332646.png" class title="image-20220824095332646"><p>整个程序的活动记录表<u>由一张张活动记录表组成</u>。</p><p>这些表通过调用（caller）&amp;被调用（callee）关系连接起来。</p><h1 id="Lecture-17-中间代码生成"><a href="#Lecture-17-中间代码生成" class="headerlink" title="Lecture 17 中间代码生成"></a>Lecture 17 中间代码生成</h1><p>介于source program（高级语言） 和 target program（机器代码，汇编）之间的代码。&#x3D;&gt; 结合体</p><img src="/.com//08/27/Compiler/image-20220620191654940.png" class title="image-20220620191654940"><p>对于中间语言，没有严格的定义与界限。</p><blockquote><p>Intermediate language <strong>can be many different languages</strong>（中间语言可以是很多种形式）, and the designer of the compiler decides this intermediate language.</p></blockquote><p><u>我们用一种统一的形式作为中间代码——三地址代码&#x2F;四元组（其中的一种，最常用、最经典的一种），为目标代码生成做准备</u></p><h2 id="Three-Address-Code-三地址代码"><a href="#Three-Address-Code-三地址代码" class="headerlink" title="Three-Address Code 三地址代码"></a>Three-Address Code 三地址代码</h2><p><code>x := y op z</code> 三地址代码</p><p>四个元素：结果变量，两个计算的变量&#x2F;元素，一个operator</p><p>where x, y and z are names, constants or compiler-generated temporaries; op is any <strong>operator</strong>.</p><p>But we may also the following notation for quadraples (much better notation because it looks like a machine code instruction)</p><blockquote><p>？若operator是一元算子，<strong>y为空</strong>→不确定性</p></blockquote><p><strong>更常用的形式：</strong></p><p><strong><code>op x,y,z</code> 四元组形式</strong></p><blockquote><p>第一个位置是operator，第二个元素是result，第三、第四是元素（最多两个元素），消除了不确定性</p></blockquote><p>apply operator <strong>op to y and z</strong>, and <strong>store the result</strong> in x.</p><p>We use the term “<strong>three-address code</strong>” because each statement usually contains three addresses (<u>two for operands, one for the result</u>).</p><p><strong>Binary Operator:</strong> <code>op result,y,z</code> or <code>result := y op z</code></p><ul><li>二元算子，ex:</li></ul><p>​add a, b, c ⇔ a &#x3D; b + c</p><p><strong>Unary Operator:</strong> <code>op result,,y</code> or <code>result := op y</code></p><ul><li>一元算子，ex:</li></ul><p>​inttoreal a, , c </p><p>​<u>为什么空的是第三个位置而不是第四个位置？</u></p><p>​→ 如果空在第四个位置，就会引入不确定性，需要判断，对机器不友好。找到有效的数字作为结束的标志。（机器友好型）</p><p><strong>Move Operator:</strong> <code>mov result,,y</code> or <code>result := y</code></p><p>where <strong>the content of y is copied into result</strong>. <strong>赋值</strong>语句</p><p>本质与一元算子一样。把y的内容放入result里面。</p><p>Ex:  mov a, , c</p><p><strong>Unconditional Jumps:</strong> <code>jmp ,,L</code> or <code>goto L</code></p><p>We will jump to the three-address code with the label L, and the execution continues from that statement.</p><p>只作用于一个元素，没有结果</p><p>Ex: jmp , , L1 &#x2F;&#x2F; jump to L1 </p><p><strong>Conditional Jumps:</strong>  jmp relop y,z,L or if y relop z goto L</p><p>条件语句&#x3D;&gt;拆分为2个四元组</p><ol><li>relop y,z （y与z的关系为true）</li><li>jmp ,,L（goto L）</li></ol><p>We will jump to the three-address code with the label L <strong>if the result of y relop z is true</strong>, and the execution continues from that statement. If the result is false, the execution continues from the statement following this conditional jump statement.</p><p>用一个四元组优化它：</p><img src="/.com//08/27/Compiler/image-20220620193538884.png" class title="image-20220620193538884"><p><strong>Procedure Parameters:</strong> <code>param x,,</code> or <code>param x</code></p><p>过程的参数：声明一个变量x</p><p>Ex: p(x1,…,xn)</p><p>​param x1,,</p><p>​param x2,,</p><p>​param xn,,</p><p>​call p,n, (n表示调用几个参数)</p><p><strong>Procedure Calls:</strong> <code>call p,n,</code> or <code>call p,n</code></p><p>调用过程</p><p>先声明n个参数，再调用过程p：call p,n, </p><img src="/.com//08/27/Compiler/image-20220823171703630.png" class title="image-20220823171703630"><p><strong>Indexed Assignments:</strong> </p><p>对于数组里的元素</p><p>move x,,y[i] or x :&#x3D; y[i] 数组中的一个元素赋值给x</p><p>move y[i],,x or y[i] :&#x3D; x 给数组中的一个元素赋值</p><p><strong>Address and Pointer Assignments:</strong></p><p><strong>moveaddr</strong> x,,y or x :&#x3D; **&amp;**y 把y地址的值赋值给x</p><p><strong>movecont</strong> x,,y or x :&#x3D; *****y 把y的内容赋值给x</p><h2 id="Syntax-Directed-Translation-into-Three-Address-Code"><a href="#Syntax-Directed-Translation-into-Three-Address-Code" class="headerlink" title="Syntax-Directed Translation into Three-Address Code"></a>Syntax-Directed Translation into Three-Address Code</h2><img src="/.com//08/27/Compiler/image-20220620210802502.png" class title="image-20220620210802502"><img src="/.com//08/27/Compiler/image-20220620211350961.png" class title="image-20220620211350961"><p><u>翻译过程（语义分析）：把<strong>基本代码翻译成四元组</strong></u></p><h3 id="Declarations"><a href="#Declarations" class="headerlink" title="Declarations"></a>Declarations</h3><img src="/.com//08/27/Compiler/image-20220823212452555.png" class title="image-20220823212452555"><h3 id="Nested-Procedure-Declarations"><a href="#Nested-Procedure-Declarations" class="headerlink" title="Nested Procedure Declarations"></a>Nested Procedure Declarations</h3><ul><li><strong>mktable(previous)</strong> – create a new symbol table where previous is the parent symbol table of this new symbol table. 构造新表</li><li><strong>enter(symtable,name,type,offset)</strong> – create a new entry for a variable in the given symbol table. 表里面增加一个新的条目</li><li><strong>enterproc(symtable,name,newsymbtable)</strong> – create a new entry for the procedure in the symbol table of its parent.  母表里面为一个过程简历一个entry</li><li><strong>addwidth(symtable,width)</strong> – puts the total width of all entries in the symbol table into the header of that table. 增加宽度</li></ul><p>We will have two stacks:</p><ul><li><p><strong>tblptr</strong> – to hold the pointers to the symbol tables <strong>控制指针的栈</strong></p></li><li><p><strong>offset</strong> – to hold the current offsets in the symbol tables in tblptr stack. 控制当前的offset 在指针栈中找到位置</p></li></ul><h3 id="Translation-Scheme-with-Locations"><a href="#Translation-Scheme-with-Locations" class="headerlink" title="Translation Scheme with Locations"></a>Translation Scheme with Locations</h3><p>翻译模式。综合属性放最后。（了解就可以）</p><p>存储变量时，如何以数组的形式存？</p><h3 id="Arrays"><a href="#Arrays" class="headerlink" title="Arrays"></a>Arrays</h3><p>Elements of arrays can <strong>be accessed quickly</strong> if the elements are stored in a block of <strong>consecutive locations</strong>.</p><img src="/.com//08/27/Compiler/image-20220823214045876.png" class title="image-20220823214045876"><p>对于一维数组：</p><ul><li>数组起始位置&#x2F;地址 baseA</li><li>每个元素占多少字节 width</li><li>第一个数组元素位置 low</li></ul><p>那么<strong>第i个元素</strong>（A[i]）的位置为：*<em>baseA + (i-low)<em>width</em></em></p><ul><li><p>baseA-low*width在编译时就能计算出</p></li><li><p>i*width在运行时才能算出</p></li></ul><p>对于二维数组：</p><p>对于多维数组：</p><img src="/.com//08/27/Compiler/image-20220823224027324.png" class title="image-20220823224027324"><h4 id="Translation-Scheme-for-Arrays"><a href="#Translation-Scheme-for-Arrays" class="headerlink" title="Translation Scheme for Arrays"></a>Translation Scheme for Arrays</h4><blockquote><p>思考：为什么需要冗余的临时变量？</p><ul><li>四元式之间的联系是通过临时变量实现的，这样易于调整和变动四元式。</li></ul></blockquote><p>要求：代码翻译成三地址代码。</p><h1 id="简答题（复习题）"><a href="#简答题（复习题）" class="headerlink" title="简答题（复习题）"></a>简答题（复习题）</h1><p>题库：<a href="http://www.doc88.com/p-7418076212297.html">http://www.doc88.com/p-7418076212297.html</a></p><h2 id="词法分析"><a href="#词法分析" class="headerlink" title="词法分析"></a>词法分析</h2><p>{∈}表示： <u>只包含空串的集合&#x2F;语言</u></p><p>与正则表达式 a*|b* 等价的正则表达式：___<u>a+|b+|∈</u>___</p><p>什么是上下文无关文法的二义性？消除文法的二义性有哪几种方法？试以简单算术表达式的文法和 if 语句的文法为例，说明怎样消除文法的二义性。</p><ul><li>二义性：对于一个句子的推导，存在不止一个语法树。存在2个最左&#x2F;最右推导。</li><li>算术表达式：id+id<em>id存在两个不同的最左推导。*<em>规定乘法的优先级大于加法。</em></em></li><li>if语句：if E1 then if E2 then S1 <strong>else</strong> S2，else到底在哪里？解决：<strong>强行规定else是关联离它最近的if</strong></li></ul><p>基于字母集｛0,1｝，给出不含子串 010 的所有串的正则表达式和 DFA。</p><p>1*(0|1*|1)*1</p><h2 id="语法分析"><a href="#语法分析" class="headerlink" title="语法分析"></a>语法分析</h2><p>语法：一组规则，可以形成和产生一个程序</p><p>语法分析是在<a href="https://baike.baidu.com/item/%E8%AF%8D%E6%B3%95%E5%88%86%E6%9E%90/8853461?fromModule=lemma_inlink">词法分析</a>的基础上将<a href="https://baike.baidu.com/item/%E5%8D%95%E8%AF%8D/7629019?fromModule=lemma_inlink">单词</a>序列组合成各类语法短语，如“<a href="https://baike.baidu.com/item/%E7%A8%8B%E5%BA%8F/71525?fromModule=lemma_inlink">程序</a>”，“语句”，“<a href="https://baike.baidu.com/item/%E8%A1%A8%E8%BE%BE%E5%BC%8F/7655228?fromModule=lemma_inlink">表达式</a>”等.。语法分析程序判断源程序<strong>在结构上是否正确</strong>。</p><p>文法：描述语言的语法结构的形式规则</p><p>一个文法G是LL(1)文法的充要条件是什么？</p><blockquote><p>若A→ɑ &amp; A→β，</p><ol><li>FIRST(ɑ) ∩ FIRST(β) &#x3D; ∅</li><li>若β→空，FIRST(α) ∩ FOLLOW(A) &#x3D; ∅</li></ol><img src="/.com//08/27/Compiler/image-20220828225518079.png" class title="image-20220828225518079"></blockquote><p>注意区分：句子、句型、句柄</p><blockquote><ul><li>句子：由开始符出发，经过一系列的替换&#x2F;重写，得到只有终结符组成的strings（句子）。S ⇒(+) w，w不包含非终结符。</li><li>句型：S ⇒(*) w，w包含非终结符，我们称之为句型。由开始符出发推导到句子过程中的中间形式。</li><li>句柄：最右推导中所使用的产生式的右边部分。</li></ul></blockquote><p>写一个上下文无关文法 CFG，使其语言是能被 5 整除且不以 0 开头的无符号整数的集合。（如｛5,10,15，….｝） </p><p>能被5整除的数从形式上看，是以0,5结尾的数字串。题目要求的不以0开头，并要注意0不是该语言的句子。所求文法为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">G(S)：S → XTZ|5</span><br><span class="line">T → YT|∈ 【由0~9构成的整数 或者为空】</span><br><span class="line">X → [1-9]</span><br><span class="line">Y → [0-9]</span><br><span class="line">Z → 0|5</span><br></pre></td></tr></table></figure><p>下面是 if-then-else 语句的文法，是否存在二义性？为什么？</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">stmt → if expr then stmt | matched_stmt</span><br><span class="line"></span><br><span class="line">matched_stmt → if expr then matched_stmt else stmt | other</span><br></pre></td></tr></table></figure><p>可以构建LL（1）预测分析表看表项是否存在不止一个产生式。并从这个不确定性入手、构造出有二义性的句子。画出2棵不同的语法树。</p><h2 id="语义分析"><a href="#语义分析" class="headerlink" title="语义分析"></a>语义分析</h2><p>语义：定义程序意义的一组规则</p><h2 id="运行时环境"><a href="#运行时环境" class="headerlink" title="运行时环境"></a>运行时环境</h2><p>在堆栈中记录函数运行时各种信息和数据的是： <u>活动记录&#x2F;帧</u></p><p>在存储管理中，为什么在活动记录内为临时变量分配空间？</p><blockquote><p>在栈式存储管理方式中，以活动记录的形式为一次过程调用（函数调用）中的局部数据提供存储空间。因为活动记录随过程调用被分配，随过程调用的结束而释放；临时变量<u>通常用于保存表达式计算中的中间结果</u>，<strong>在活动记录中为临时变量分配空间，可以保证该空间随过程调用被分配，随活动记录的释放被自动释放</strong>。</p></blockquote><p>函数调用是通过活动记录（帧）保存相关信息的，试简述活动记录的主要内容，并画出函数 func1 调用 func2 前后堆栈变化的示意图。</p><p>堆式动态分配申请和释放存储空间遵守____<u>任意____</u>  原则</p><h2 id="中间代码生成"><a href="#中间代码生成" class="headerlink" title="中间代码生成"></a>中间代码生成</h2><img src="/.com//08/27/Compiler/image-20220828101452318.png" class title="image-20220828101452318"><p>为什么要使用冗余的局部变量t3？</p><ol><li>临时变量记录中间结果</li><li>防止变量混淆 如i++</li><li>便于调整和修改</li><li>不能同时访问两次内存</li></ol><img src="/.com//08/27/Compiler/image-20220828225332052.png" class title="image-20220828225332052"><img src="/.com//08/27/Compiler/image-20220828225548167.png" class title="image-20220828225548167"><p>&lt;——–end———&gt;</p></aside></aside></aside>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;这是2021 ~ 2022 第二学期必修课编译原理与技术的课堂笔记。&lt;/p&gt;
&lt;h1 id=&quot;Lecture-01-Introduction-to-Compiling&quot;&gt;&lt;a href=&quot;#Lecture-01-Introduction-to-Compiling&quot; clas</summary>
      
    
    
    
    <category term="Study" scheme="http://example.com/categories/Study/"/>
    
    
    <category term="Compilers Principals and Techniquess" scheme="http://example.com/tags/Compilers-Principals-and-Techniquess/"/>
    
  </entry>
  
  <entry>
    <title>Computer Organization</title>
    <link href="http://example.com/2022/07/27/Computer-Organization/"/>
    <id>http://example.com/2022/07/27/Computer-Organization/</id>
    <published>2022-07-27T00:26:56.000Z</published>
    <updated>2023-07-09T18:25:54.117Z</updated>
    
    <content type="html"><![CDATA[<p>计算机组成原理。</p><h1 id="Chapter-1-计算机系统概述"><a href="#Chapter-1-计算机系统概述" class="headerlink" title="Chapter 1 计算机系统概述"></a>Chapter 1 计算机系统概述</h1><h1 id="Chapter-2"><a href="#Chapter-2" class="headerlink" title="Chapter 2"></a>Chapter 2</h1>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;计算机组成原理。&lt;/p&gt;
&lt;h1 id=&quot;Chapter-1-计算机系统概述&quot;&gt;&lt;a href=&quot;#Chapter-1-计算机系统概述&quot; class=&quot;headerlink&quot; title=&quot;Chapter 1 计算机系统概述&quot;&gt;&lt;/a&gt;Chapter 1 计算机系统概述&lt;/</summary>
      
    
    
    
    <category term="Study" scheme="http://example.com/categories/Study/"/>
    
    
    <category term="408" scheme="http://example.com/tags/408/"/>
    
  </entry>
  
  <entry>
    <title>Watchman: Monitoring Dependency Conflicts for Python Library Ecosystem</title>
    <link href="http://example.com/2022/07/06/Watchman-Monitoring-Dependency-Conflicts-for-Python-Library-Ecosystem/"/>
    <id>http://example.com/2022/07/06/Watchman-Monitoring-Dependency-Conflicts-for-Python-Library-Ecosystem/</id>
    <published>2022-07-06T14:43:56.000Z</published>
    <updated>2023-07-09T16:24:30.942Z</updated>
    
    <content type="html"><![CDATA[<p>我所报告的论文是：《<strong>Watchman: Monitoring Dependency Conflicts for Python Library Ecosystem</strong>》。我根据自己对这篇论文的理解，将它分成了五个部分，首先是一些背景知识与概念介绍，然后就是本文的主体部分，包括实证研究、Watchman的工作机制和对Watchman的评估，最后就是总结和未来展望。</p><h1 id="Background"><a href="#Background" class="headerlink" title="Background"></a>Background</h1><p>本文主要研究Python库生态系统的依赖冲突问题，Python 中有着各种丰富的标准库、<a href="https://so.csdn.net/so/search?q=%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93&spm=1001.2101.3001.7020">第三方库</a>和模块，受到开发者的欢迎。<strong>PyPI</strong>(<em>Python Package Index</em>)就是python<strong>官方的第三方库的仓库</strong>，所有人都可以从中下载<a href="https://so.csdn.net/so/search?q=%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93&spm=1001.2101.3001.7020">第三方库</a>或上传自己开发的库。PyPI推荐使用pip包安装程序来下载第三方库。通常开发者会在项目配置脚本显式地约束库的版本。pip就会根据库的名称和版本约束来下载它。如果有多个版本满足版本约束，则pip将下载并安装最新版本，也就是First Found Wins原则。</p><hr><img src="/.com//07/06/Watchman-Monitoring-Dependency-Conflicts-for-Python-Library-Ecosystem/image-20230704234406502.png" class title="image-20230704234406502"><p>这张图说明了Python项目依赖关系的概念。配置脚本显式声明并约束的是直接依赖项。如果这些<strong>直接依赖进一步依赖于其他库，那么这些库被称为P的传递依赖</strong>。在本文中，所有的<strong>直接依赖</strong>和<strong>传递依赖</strong>都被统称为P的<strong>上游项目</strong>。相应地，我们称P称为<strong>其依赖的下游项目</strong>。</p><hr><p>即使这样下载包很方便，但也使得项目中的<strong>版本约束很容易发生冲突</strong>，导致构建失败。我们将这类冲突称为依赖冲突问题。举个例子，项目P直接依赖的库c安装版本为2.6，违背传递依赖的库c的约束。</p><p>现实中项目依赖关系更为复杂，这里展示了github上一个真实的案例Django Channels。如图所示，channels 2.1.7根据版本约束会下载asgiref 2.3.0和daphne 2.2.5，在2019.4.9之前是没有冲突问题的。但是在这之后，由于daphne更新到了2.3.0版本并且约束asgiref ≥ 3.0 ∧＜4.0。而channels安装的是asgiref 2.3.0，与daphne的对asgiref的版本约束相违背，导致了Build Error。</p><img src="/.com//07/06/Watchman-Monitoring-Dependency-Conflicts-for-Python-Library-Ecosystem/image-20230704234428833.png" class title="image-20230704234428833"><p>为解决这个问题，开发者发布channels 2.2.0，更新对asgiref的版本约束，使得构建channels时下载3.1.1的版本。然而这又引入了另一个DC问题，channel-redis 2.3.3仍然安装的是asgiref 2.3.0，违反了channels 2.2.0的依赖约束，导致构建失败。</p><p>从上面这个例子我们可以感受到，开发者经常对自己项目所直接依赖的库指定版本约束，而不去考虑其他项目指定的约束。跨项目的复杂的依赖关系使得Python项目的依赖解决相对困难。</p><hr><p>我们主要面临以下挑战：</p><p>首先，库的<strong>版本可能会随时间而变化</strong>。由于pip将安装满足相关约束的最新版本。因此，PyPI上的库的任何更新都会影响为下游项目安装的库的版本（即，依赖于这些库的项目的版本），从而导致潜在的构建失败。</p><p>其次，当一个库更新其对其他库的版本约束时，其<strong>下游项目（也就是依赖这个库的项目）</strong>可能会受到影响。这些影响可以进一步传播到广泛的项目中。</p><p>第三，Python开发人员<strong>很难通过版本约束信息获得他们的项目依赖关系</strong>。像pipnev &amp; Poetry这样的工具只会给出期望安装的库，而非展现深层的依赖关系。</p><p>开发者缺乏工具支持以获得诊断这些问题的根本原因。为了解决这些挑战并帮助Python开发人员解决DC问题，本文作者进行了以下三个工作：实证研究，设计实现Watchman，评估Watchman。</p><hr><h1 id="Empirical-Study"><a href="#Empirical-Study" class="headerlink" title="Empirical Study"></a><strong>Empirical Study</strong></h1><p>在进行实证研究之前，需要进行一些准备工作，比如对项目中依赖进行形式化的定义。这里的C指的是对库的版本约束，可以为空（即安装最新版本），可以为几个范围的并集，也可以指定特定版本。</p><p>首先进行项目数据收集。</p><h2 id="Data-Collection"><a href="#Data-Collection" class="headerlink" title="Data Collection"></a>Data Collection</h2><p>主要选取的是github上的一些真实项目，满足有50以上stars或fork，用作库并且维护良好。然后在这些项目的issue report中，通过搜索关键词“dependency conflict” or “dependency hell”识别DC ISSUES。经过这两步，最终从 124 个项目中获得了 235 个 DC 问题，235 个问题中的 201 个已经修复。</p><p>我们由远程依赖或本地环境引起的DC问题将表现模式分为两类。</p><hr><h2 id="RQ1-Manifestion-Pattern"><a href="#RQ1-Manifestion-Pattern" class="headerlink" title="RQ1 Manifestion Pattern"></a>RQ1 Manifestion Pattern</h2><p>首先是</p><h3 id="Pattern-A"><a href="#Pattern-A" class="headerlink" title="Pattern A"></a>Pattern A</h3><p>模式A：由远程依赖关系更新引起的冲突。</p><p><strong>根据依赖冲突的来源</strong>进行进一步的分类。</p><p>a.直接依赖和传递依赖之间的冲突（139&#x2F;211）。</p><p>b.传递性依赖关系之间的冲突（72&#x2F;211）。</p><p>这里没有直接依赖之间的冲突，因为开发人员通常不会在配置脚本中引入直接依赖关系之间的冲突且这样的错误很容易被捕获。</p><p>然后是</p><h3 id="Pattern-B"><a href="#Pattern-B" class="headerlink" title="Pattern B"></a>Pattern B</h3><p>模式B：受本地环境影响的冲突。当<strong>远程依赖项</strong>所需的工具与<strong>本地安装</strong>的工具不兼容时，就会发生这样的问题(例如，需要Python3.7，<em>但是安装了Python3.6</em>)。当已经安装在本地环境中的依赖项的版本不满足远程依赖项指定的约束时，也会发生这种情况。</p><p>以gradieny #issue 25316为例。项目无法构建，因为在构建之前在本地环境中已经安装了numpy（1.13.3），这个版本与panda 0.24.1指定的约束≥1.15相冲突。</p><h3 id="Dependency-Smells"><a href="#Dependency-Smells" class="headerlink" title="Dependency Smells"></a>Dependency Smells</h3><p>除此2个典型的引起DC问题的场景外，还发现了依赖性气味。它们不会立即引起DC问题，但随着项目的发展引发问题。</p><ul><li><p><strong>类型一：当指定公共库为特定版本时，很容易导致下游项目出现DC问题。</strong></p><p>这里的公共库指的是与下游项目所依赖的库的交集</p><p>例如，molecule依赖库ansible-lint，并约束其为特定版本(i.e. 3.4.23)，这使得同样依赖库ansible-lint的molecule的下游项目对ansible-lint的更新特别敏感。 每当PyPI 上发布新版本的 ansible-lint 时，molecule 的开发人员就会收到来自下游项目关于升级 ansible-lint 的版本约束的请求。最终他们选择将放宽对 ansible-lint 的版本约束，才能让更多下游项目能够很好地使用它。</p></li><li><p><strong>类型二：当一个库的安装版本接近该库另一个版本约束中指定的上限时，很容易发生DC问题。</strong></p><p>例如，一个项目直接依赖urllib3且没有指定上界，即安装最新版本1.22.4；然而传递依赖的urllib3约束≥ 1.21.1 ∧ &lt; 1.23。由于1.22.4接近于另一个约束的上界1.23，<strong>一旦urllib3进行版本更新，DC问题很容易发生</strong>。</p></li></ul><p>之后将展示，识别这两种类型的气味可以帮助进行预测性分析，以在DC问题导致真正的构建失败之前主动预防它们。</p><hr><h2 id="RQ2-Fixing-Strategy"><a href="#RQ2-Fixing-Strategy" class="headerlink" title="RQ2 Fixing Strategy"></a>RQ2 Fixing Strategy</h2><p>观察issue report发现得到7个修复DC问题的策略。</p><p>其中策略1是采用最广泛的一种。这是因为开发人员可以控制他们项目的直接依赖关系的版本约束。策略 1 4适用于解决直接依赖和传递依赖间的冲突；策略2 3 5适用于解决传递依赖间的冲突；策略6 7适用于解决由本地环境引起的冲突。</p><hr><p>基于PyPI上下游项目之间复杂的依赖关系，设计并实现了Watchman。</p><h1 id="Watchman-working-mechanism"><a href="#Watchman-working-mechanism" class="headerlink" title="Watchman working mechanism"></a>Watchman working mechanism</h1><p>Watchman现在已经是一个比较成熟的网站了，可以看到它主要有4个功能：监测PyPI上库的更新，识别受影响的下游项目，构建完全依赖图，诊断DC问题。</p><img src="/.com//07/06/Watchman-Monitoring-Dependency-Conflicts-for-Python-Library-Ecosystem/image-20230704234612902.png" class title="image-20230704234612902"><p>那么Watchman是通过什么技术做到这些的呢？</p><h2 id="构建元数据库"><a href="#构建元数据库" class="headerlink" title="构建元数据库"></a>构建元数据库</h2><p>Watchman首先收集了每个库版本的<strong>元数据</strong>，包括直接依赖的版本约束和他们的声明顺序。将PyPI上所有库的元数据整合到一个库中。以便分析上下游项目的版本约束。</p><p>对于一个版本为v的库ζ，Watchman通过分析ζ的依赖配置脚本获得结构化元数据G(ζ^v), &#x3D;(D, R, P)，其中D是ζ直接依赖库的集合；R是库ζ所指定的依赖关系δ的版本约束；P则是将每个依赖δ按照其声明顺序进行映射。</p><hr><h2 id="分析库更新的影响"><a href="#分析库更新的影响" class="headerlink" title="分析库更新的影响"></a>分析库更新的影响</h2><p><strong>步骤1：监测PyPI库的更新</strong>。在PyPI上有两种类型的库更新：现有库的新版本和新库的分布。Watchman通过每天监控这两种类型的库更新来计算Lupdate。</p><p><strong>步骤2：识别受影响的下游项目</strong>。</p><p>它用深搜的方式在所有元数据G中搜索ζ^v的下游项目，并加入Laffected集合中。</p><hr><h2 id="Construct-FDG"><a href="#Construct-FDG" class="headerlink" title="Construct FDG"></a>Construct FDG</h2><p>为了诊断每个受影响的项目的DC问题，我们需要分析、构建库版本之间的关系。为了捕获这种关系，我们提出了一个<strong>正式的模型——</strong>完全依赖图(FDG)。</p><p>算法2描述了为库ζ^v构建FDG的过程。Watchmant通过<strong>广度优先算法</strong>构建FDG(ζ^v)。</p><p>【pip<strong>首先为项目安装直接依赖</strong>，然后根据项目的<strong>依赖树在下一级安装依赖，这个过程继续，直到安装所有依赖为止</strong>。】</p><blockquote><p>为什么使用广搜？因为要保持依赖<strong>声明的顺序</strong>。</p></blockquote><p>构建FDG之后，我们可以进行DC问题的预测分析。</p><hr><h2 id="Predictive-Analysis-for-DC-Issues"><a href="#Predictive-Analysis-for-DC-Issues" class="headerlink" title="Predictive Analysis for DC Issues"></a><strong>Predictive Analysis for DC Issues</strong></h2><p>主要通过检测前面讨论的两种依赖味道去主动预防DC问题，从而进行<strong>预测分析</strong>。</p><p><strong>类型1</strong>：将<strong>公共依赖库</strong>限制为特定版本。如果满足以下条件：找到一个库ζ将直接依赖α限制为特定版本x，存在ζ下游项目也依赖于α，且αx是在分析时为βy安装的库版本。</p><p>Watchman会发现这样的情况，并建议项目的开发者放宽对库版本的限制。</p><img src="/.com//07/06/Watchman-Monitoring-Dependency-Conflicts-for-Python-Library-Ecosystem/image-20230704234709481.png" class title="image-20230704234709481"><blockquote><p>eg. 如Type1所示，项目C将库A被限制为&#x3D;2.0。此外，C的下游项目B5.0同时依赖于C2.0和A2.0。目前安装的是2.0 当A在PyPI上更新，很有可能违背&#x3D;2.0版本约束。</p></blockquote><p><strong>类型2</strong>：<strong>库的安装版本接近版本约束中指定的上限</strong>。如果满足：在ζ的完全依赖图中有个节点α有多条入边，其中先遍历的边没有指定上界，后遍历的边指定了一个上限且上限大于等于α的最新版本。</p><blockquote><p>eg. 就比如图中Type2所示，项目T4.0有两条入口边，一条约束没有上界，即安装T的最新版本4.0，后一条边约束&gt;2.0∧≤4.0，一旦开发人员在PyPI上发布了T的新版本（例如，4.1），则可能会发生构建失败。</p></blockquote><hr><h1 id="Evaluation"><a href="#Evaluation" class="headerlink" title="Evaluation"></a><strong>Evaluation</strong></h1><p>为了评估Watchman，主要关注两个方面：</p><ul><li>有效性</li></ul><p>我们回放了2017年1月1日至2019年6月30日期间PyPI上所有库的演变历史；</p><p>为了评估的有效性，我们定义了两个<strong>指标</strong>，解决比例和持续时间。</p><p>表三展示了研究结果。在所有五个子周期中，模式A的DC问题修复率为100%，。预测问题的平均解决率为91.7%。这些数据是非常可观的。这表明Watchman在检测、预测DC问题方面都很有效。</p><ul><li>有用性</li></ul><p>Watchman有用性的评估主要是看2个指标，确认率和修复率。</p><p>自我们于2019年7月1日开始在线监测以来，Watchman共发现并预测了189个DC问题。过滤后报告了剩下的117个DC问题。 如4所示，确认率为53.8%，修复率为60.3%，但这只是2019年7月到8月的数据，由于库的更新以及Watchman的持续检测，可以看到在后期问题的确认率是在上升的。</p><p>除了Watchman报告的DC问题的有用性外，一些开发人员还对Watchman表示了兴趣。比如arxiv的开发者说到“有一个更好的机制来维护PyPI项目之间的依赖约束，这是非常需要的！”“你是由Github社区编写的自动化来帮助解决Python项目的依赖冲突问题吗？如果是这样，那就做一件不错的作品吧！我想说，这是一个很好的方法，一个很好的工具来告知潜在的依赖问题。”</p><p>此外，论文作者还调查了Watchman网站的访问量。可以看到40天内就有467用户进行了1648次操作，共为2590个Python项目生成了诊断报告。</p><p>以上这些反馈表明，监测Py库更新、预测依赖冲突对Python开发人员确实很重要，并且诊断报告确实起了作用。</p><hr><h1 id="Conclusion-and-Future-work"><a href="#Conclusion-and-Future-work" class="headerlink" title="Conclusion and Future work"></a><strong>Conclusion and Future work</strong></h1><p>然而Watchman还存在一些局限和可以改进的地方。</p><h3 id="有效性威胁"><a href="#有效性威胁" class="headerlink" title="有效性威胁"></a>有效性威胁</h3><p>数据收集采用关键字搜索，容易引入不相关的问题，对研究结果的有效性构成了威胁。我们<strong>手动筛选</strong>DC问题时的产生的错误也可能影响我们的研究结果。</p><h3 id="局限性"><a href="#局限性" class="headerlink" title="局限性"></a>局限性</h3><p>我们的工作有三个局限性。</p><ol><li>首先，我们将重点关注导致构建失败的DC问题。然而，在某些情况下，依赖关系冲突可能会导致<strong>语义不一致、运行时错误或Python项目中的其他后果</strong>。</li><li>其次，在预测分析中我们采取的是根据两种依赖气味找到可能引起的DC问题，这并不完整。</li><li>第三，Watchman目前还不能检测到我们在实证研究中观察到的DC问题的所有表现模式。</li></ol><p>在今后的工作中解决这些局限性。</p><hr><p>总的来说，本文对Python项目中的235个真实的依赖冲突问题进行了实证研究，以总结出依赖冲突问题的表现模式和修复策略。随后设计并实现了Watchman，来持续监测PyPI生态系统的依赖冲突。 评估结果表明，Watchman能够有效地检测依赖冲突问题，并提供有用的诊断信息，帮助开发人员解决问题。 在未来，计划进一步提高Watchman的检测能力，比如说探究更完整的表现模式以包括所有DC问题，以及发现更多依赖气味能够有效预测预防DC问题。并将该技术推广到其他Python库生态系统，如Anaconda，使更多的开发人员能够访问它。</p><hr><h1 id="启发与学习到的地方"><a href="#启发与学习到的地方" class="headerlink" title="启发与学习到的地方"></a>启发与学习到的地方</h1><h3 id="对自己的科研有什么启发？"><a href="#对自己的科研有什么启发？" class="headerlink" title="对自己的科研有什么启发？"></a>对自己的科研有什么启发？</h3><ul><li>数据的统计收集工作量较大，学习筛选数据的方式</li><li>形式化方法与算法的建模</li><li>强大的数据收集，总结归纳能力</li></ul><h3 id="这篇论文有什么创新点？"><a href="#这篇论文有什么创新点？" class="headerlink" title="这篇论文有什么创新点？"></a>这篇论文有什么创新点？</h3><ul><li>能够发掘传统工具做不到的，既能持续监测又能预测预防，我觉得是很好的一个点</li><li>能够关注到Python项目中的常见问题并对其进行归纳建模，探究可行的解决方案并提出相应的技术。</li><li>xx点缺乏工具支持 ⇒ 发掘、拓展</li></ul><h3 id="有没有疑惑的地方？"><a href="#有没有疑惑的地方？" class="headerlink" title="有没有疑惑的地方？"></a>有没有疑惑的地方？</h3><ul><li>If adopting Strategy 1 will cause side effects such as security loopholes, developers may solve the conflicts by upgrading or downgrading the direct dependencies of their projects (Strategy 2) or coordinating with upstream projects to adjust conflicting version constraints (Strategy 3).</li><li>这里的安全漏洞指的是什么？采用策略1修复为什么会引起安全漏洞？<ul><li>库本身的安全漏洞</li></ul></li></ul><h3 id="觉得还有什么地方可以进一步拓展-x2F-改进？"><a href="#觉得还有什么地方可以进一步拓展-x2F-改进？" class="headerlink" title="觉得还有什么地方可以进一步拓展&#x2F;改进？"></a>觉得还有什么地方可以进一步拓展&#x2F;改进？</h3><ul><li>数据收集时采用<strong>手动筛选</strong>DC问题，很有可能产生偏差，有没有更好的方式对数据收集这一步骤进行形式化建模，使得能够自动化筛选数据？</li><li>Watchman这个网站在诊断时，响应有些慢，是否能在数据库存储上做进一步的改进优化查询速度？</li><li>探究更多的依赖气味以及依赖冲突的表现模式。</li><li>目前watchman是通过网站的形式在线向开发者反馈诊断报告，开发者需要手动去对项目进行修复。之后可以基于此做成插件，用于<strong>自动化检测依赖冲突并且自动去修改配置脚本中的依赖约束，程序代替人力</strong>。</li></ul><h3 id="Python-依赖管理与Java依赖管理的对比"><a href="#Python-依赖管理与Java依赖管理的对比" class="headerlink" title="Python 依赖管理与Java依赖管理的对比"></a>Python 依赖管理与Java依赖管理的对比</h3><ul><li>Java 有Maven来进行包管理和项目依赖配置，并体现在 pom.xml</li><li>Maven Helper</li><li>Maven Enforcer Plugin<ul><li>Maven提供了Maven-Enforcer-Plugin插件，用来<strong>校验约开发环境</strong>。比如JDK的版本,Maven的版本,开发环境(Linux,Windows等),依赖jar包的版本等等</li></ul></li><li>dependency-mediator-maven-plugin：解决依赖冲突问题；<ul><li>试在编译期诊断组件依赖冲突问题，<em>轻量级兼容性依赖仲裁组件</em></li></ul></li><li>Karaf(ClassLoader)<ul><li>通过自定义类加载器的方法，达到同时加载<strong>不同版本的同名包</strong>的目的。典型的例子就是 OSGI(Open Service Gateway Initiative 开放服务网关协议)：受它自身的类加载器架构影响，Bundle 类加载器之间只有规则，没有固定的委派关系，即不受双亲委派模型影响。</li></ul></li></ul><p>这一方法在找不到类时会直接指出哪个 bundle 加载出现问题，错误提示更为友好；且比起在一长串的 classpath 中查找，它的效率更高；但<strong>涉及的工作过于底层，评估工作量后过大，实现难度较大</strong></p><ul><li>而我们采取的是直接升降依赖版本，比较好理解，虽然该方法<strong>人工操作时较为繁琐</strong>，但各个步骤的可程序化程度极高，若是使用程序代替人力，便能大幅降低使用该方法的成本，提升其可行性</li><li>依赖关系都是多叉树，研究方法都对多种产生依赖冲突的场景进行建模和分析，并提出有效的解决算法。</li><li>直接依赖和传递依赖</li><li>冲突表现形式：<ul><li>Java：显式冲突和隐式冲突<ul><li>不会出现报错极少被察觉，只会在 Maven 依赖图中体现为一条红线，仍能正常运行</li><li>显式冲突：由隐式冲突导致的运行过程中出现的报错问题。NoSuchMethodException、ClassNotFoundException、NoClassDefFoundErro</li></ul></li><li>Python： Pattern A &amp; B 远程依赖引起或本地环境引起</li></ul></li></ul><h3 id="能不能进行方法的迁移？"><a href="#能不能进行方法的迁移？" class="headerlink" title="能不能进行方法的迁移？"></a>能不能进行方法的迁移？</h3><p>注意，这里Java pom.xml通常都会指定依赖的版本，而不是给定范围。</p><p>能否进行依赖气味的预测？——思考</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;我所报告的论文是：《&lt;strong&gt;Watchman: Monitoring Dependency Conflicts for Python Library Ecosystem&lt;/strong&gt;》。我根据自己对这篇论文的理解，将它分成了五个部分，首先是一些背景知识与概念介绍</summary>
      
    
    
    
    <category term="Study" scheme="http://example.com/categories/Study/"/>
    
    <category term="Research" scheme="http://example.com/categories/Study/Research/"/>
    
    
    <category term="Dependency" scheme="http://example.com/tags/Dependency/"/>
    
    <category term="论文汇报" scheme="http://example.com/tags/%E8%AE%BA%E6%96%87%E6%B1%87%E6%8A%A5/"/>
    
  </entry>
  
  <entry>
    <title>软件需求知识点总结</title>
    <link href="http://example.com/2022/06/12/%E8%BD%AF%E4%BB%B6%E9%9C%80%E6%B1%82/"/>
    <id>http://example.com/2022/06/12/%E8%BD%AF%E4%BB%B6%E9%9C%80%E6%B1%82/</id>
    <published>2022-06-12T03:00:38.000Z</published>
    <updated>2023-07-09T16:57:18.301Z</updated>
    
    <content type="html"><![CDATA[<p>2021~2022 第二学期的专业选修课——软件需求。</p><h1 id="Lecture-1-软件需求：课程总览"><a href="#Lecture-1-软件需求：课程总览" class="headerlink" title="Lecture 1 软件需求：课程总览"></a>Lecture 1 软件需求：课程总览</h1><p>Q1: 为什么会有软件工程？</p><p>Q2: 为什么会有需求工程？</p><h2 id="软件需求工程的缘起"><a href="#软件需求工程的缘起" class="headerlink" title="软件需求工程的缘起"></a>软件需求工程的缘起</h2><p>软件开发的目标</p><ol><li>满足给定的时间和成本约束</li><li>实现用户真实期望</li><li>确保软件产品质量</li></ol><h2 id="软件需求的重要性"><a href="#软件需求的重要性" class="headerlink" title="软件需求的重要性"></a>软件需求的重要性</h2><ol><li>是软件系统设计的前期准备</li><li>是软件编码的基础依据</li><li>是软件评测的重要标准</li><li>是软件维护的重要资料</li><li>是整个软件生命周期中所有讨论的基础对象</li></ol><p>未经良好需求分析而直接编码，是大量软件项目失败的根源。</p><img src="/.com//06/12/%E8%BD%AF%E4%BB%B6%E9%9C%80%E6%B1%82/image-20220612160300440.png" class title="image-20220612160300440"><ul><li>需求分析中的错误是最容易出现的错误</li><li>修正需求分析阶段的错误，代价可能是最大的</li></ul><h2 id="什么是“软件需求”？"><a href="#什么是“软件需求”？" class="headerlink" title="什么是“软件需求”？"></a>什么是“软件需求”？</h2><h3 id="IEEE定义"><a href="#IEEE定义" class="headerlink" title="IEEE定义"></a>IEEE定义</h3><ol><li>用户求解问题或实现目标的一组<strong>条件或能力</strong> “人想做什么”</li><li>系统用来满足合同或标准的一组条件或能力 “软件该做什么”</li><li>记录上述条件和能力的<strong>文档</strong> 文档化记录</li></ol><h3 id="关键目标"><a href="#关键目标" class="headerlink" title="关键目标"></a>关键目标</h3><p>需求工程关注系统将要做什么（what to do）</p><ul><li>需求工程目的是定义所需解决的问题</li></ul><p>后续阶段，例如编码是关于如何解决问题即（how to do）</p><h2 id="软件需求工程的组成"><a href="#软件需求工程的组成" class="headerlink" title="软件需求工程的组成"></a>软件需求工程的组成</h2><img src="/.com//06/12/%E8%BD%AF%E4%BB%B6%E9%9C%80%E6%B1%82/image-20220612161905389.png" class title="image-20220612161905389"><h2 id="软件需求的层次"><a href="#软件需求的层次" class="headerlink" title="软件需求的层次"></a>软件需求的层次</h2><img src="/.com//06/12/%E8%BD%AF%E4%BB%B6%E9%9C%80%E6%B1%82/image-20220612162027830.png" class title="image-20220612162027830"><h2 id="软件需求工程活动的初步体验"><a href="#软件需求工程活动的初步体验" class="headerlink" title="软件需求工程活动的初步体验"></a>软件需求工程活动的初步体验</h2><p>根据平时生活经验，写如下产品的需求：地铁列车车载控制软件。</p><img src="/.com//06/12/%E8%BD%AF%E4%BB%B6%E9%9C%80%E6%B1%82/image-20220612162315475.png" class title="image-20220612162315475"><h2 id="软件需求工程为什么这么难"><a href="#软件需求工程为什么这么难" class="headerlink" title="软件需求工程为什么这么难"></a>软件需求工程为什么这么难</h2><p><strong>软件产品的特殊性</strong>带来对软件意图的理解的困难。</p><ul><li>产品是无形的，目标不一定直接对应现实世界的有形事物</li><li>需求是从无到有创造出来</li><li>软件问题往往包含最复杂的难题，且有其现实业务背景，不易描述</li><li>现实世界几乎没有对软件问题施加直接的物理约束和提示</li></ul><p><strong>需求工程是“最关键性的和最易出问题的领域”</strong></p><p><strong>浅层理解</strong>：软件工程是要做出一个系统，其中，<u>需求工程关注系统将要做什么（what），后续阶段关注系统将怎样被实现（how）</u></p><p><strong>深层理解</strong>：软件工程的产品是用来解决问题的。其中，后续阶段是关于如何解决问题，而需求工程的目的是<u>定义所需解决的问题</u></p><p>讨论：做什么（what）和怎样做（how）之间 ，有没有明确的界限？</p><h3 id="工程实践中的现实困难"><a href="#工程实践中的现实困难" class="headerlink" title="工程实践中的现实困难"></a>工程实践中的现实困难</h3><ul><li>软件工程师需要成为<strong>问题领域</strong>的专家</li><li>信息沟通</li><li>输出需要精确</li></ul><h2 id="需求的确认"><a href="#需求的确认" class="headerlink" title="需求的确认"></a>需求的确认</h2><p>通过严格的<u>验证分析</u>和<u>需求确认</u>，确保软件需求<strong>真实、准确、完整</strong>且<strong>无误</strong>地<u>反映了用户期望</u>。</p><p>需求确认：该系统<strong>正是用户所期望的系统</strong>。</p><h1 id="Lecture-2-软件需求工程之最佳实践-初探"><a href="#Lecture-2-软件需求工程之最佳实践-初探" class="headerlink" title="Lecture 2 软件需求工程之最佳实践-初探"></a>Lecture 2 软件需求工程之最佳实践-初探</h1><p>最佳实践”将对如下问题，给出其回答：</p><ol><li>这些需求内容，到底是什么<strong>形态</strong>？</li><li>如何把这些需求，从用户的内心<strong>挖掘</strong>出来？</li><li>如何把需求<strong>形成合理的文档</strong>？</li><li>如何确保需求逻辑正确，与用户<strong>期望一致</strong>？</li><li>如何应对用户的需求<strong>变化</strong>？</li></ol><h2 id="涉众"><a href="#涉众" class="headerlink" title="涉众"></a>涉众</h2><ul><li>Customer-客户</li><li>User-用户</li><li>Analyst-分析人员</li><li>Developer-开发人员</li><li>Tester-测试人员</li><li>Doc. Writer-文档撰写人员</li><li>Project manager-项目经理</li><li>Legal staff-法务人员</li><li>Manufacturer-制品供应方</li><li>Sales-销售人员</li></ul><h2 id="知识储备与人员条件"><a href="#知识储备与人员条件" class="headerlink" title="知识储备与人员条件"></a>知识储备与人员条件</h2><p>需求分析员必须具备足够专业基础能力</p><p>用户和管理团队应具备对软件需求工程的正确认识</p><p>例如：</p><ul><li>Customer地铁运营方（申通地铁）</li><li>User列车操作人员&#x2F;列车维护人员（申通地铁）</li><li>Requirement Analyst列车控制软件开发方（卡斯柯信号）</li><li>Developer开发方团队（卡斯柯信号）</li><li>Others双方的法务、财务等人员</li></ul><h2 id="需求获取"><a href="#需求获取" class="headerlink" title="需求获取"></a>需求获取</h2><ul><li>约定需求研发的过程</li><li>确定软件产品的目标与范围 </li><li>对用户精确分类</li><li>确定需求获取的方式</li></ul><h2 id="需求分析"><a href="#需求分析" class="headerlink" title="需求分析"></a>需求分析</h2><ul><li>可行性分析</li><li>愿景与范围分析</li><li>优先级分析</li><li>图形化模型引导的逻辑分析</li></ul><blockquote><p>方法可行，主次分明，化无为有，深入探究</p></blockquote><h2 id="需求文档化"><a href="#需求文档化" class="headerlink" title="需求文档化"></a>需求文档化</h2><ul><li>选择需求文档模板</li><li>明确需求来源</li><li>精确完整地描述功能与性能</li><li>文档可读可理解</li></ul><blockquote><p>文档有章法，内容要精确，信息要完整，描述要可读</p></blockquote><h2 id="需求确认"><a href="#需求确认" class="headerlink" title="需求确认"></a>需求确认</h2><ul><li>确认需求描述与用户的期望一致</li><li>确认需求描述本身逻辑正确</li></ul><blockquote><p>做正确的事，把事做正确，查错补缺，保障质量 </p></blockquote><h2 id="需求管理"><a href="#需求管理" class="headerlink" title="需求管理"></a>需求管理</h2><ul><li>约定需求变更的处理原则与流程</li><li>分析变更的影响</li><li>需求状态管理</li><li>版本控制</li></ul><blockquote><p>需求可变，文档可改，变有依据，改有章法</p></blockquote><img src="/.com//06/12/%E8%BD%AF%E4%BB%B6%E9%9C%80%E6%B1%82/image-20220612185128923.png" class title="image-20220612185128923"><h2 id="国产列车车载控制软件项目"><a href="#国产列车车载控制软件项目" class="headerlink" title="国产列车车载控制软件项目"></a>国产列车车载控制软件项目</h2><p>业务需求：用户对系统应达到的高层次业务目标</p><ul><li>例：列车控制系统应能承担旅客运输，预计最高发车频次x分钟，完成年客运量y万</li></ul><p>用户需求：使用软件产品的用户需要实现的应用任务</p><ul><li>例:驾驶人员能控制列车速度；维护人员有权限读取列车当日行车运行日志</li></ul><p>系统需求：包含了软件产品的系统的<strong>顶层需求</strong></p><ul><li>例：列车自动保护系统(ATP) ；连锁控制系统(CBI)</li><li><img src="/.com//06/12/%E8%BD%AF%E4%BB%B6%E9%9C%80%E6%B1%82/image-20220612185404591.png" class title="image-20220612185404591"></li></ul><p>功能需求：<strong>为了实现业务需求</strong>而应开发的<strong>软件功能</strong></p><ul><li>例：列车控制软件能根据当前加速度和速度计算停车位置….</li></ul><p>业务规则：<strong>政策、法规、行业标准与规范</strong></p><ul><li>例：地铁B型车辆最高时速不得高于80km&#x2F;h</li></ul><p>质量属性：软件运行的<strong>稳定性</strong>和<strong>安全性</strong>等属性</p><ul><li>例：ATP软件的功能安全等级达到SIL4级要求</li></ul><p>约定条件：系统设计的<strong>限制条件与约定</strong></p><ul><li>例：ATP软件运行存储空间为xxx大小的硬件板卡</li></ul><p>外部接口：软件系统与外部环境的交互通道</p><ul><li>例：列车控制软件将通过XX协议接口与ATS系统通信</li></ul><h3 id="需求文档"><a href="#需求文档" class="headerlink" title="需求文档"></a>需求文档</h3><ul><li>功能编号</li><li>自然语言描述</li><li>形式化语言描述</li></ul><img src="/.com//06/12/%E8%BD%AF%E4%BB%B6%E9%9C%80%E6%B1%82/image-20220612185851462.png" class title="image-20220612185851462"><h3 id="需求分析-1"><a href="#需求分析-1" class="headerlink" title="需求分析"></a>需求分析</h3><p>功能的描述可能存在逻辑错误等缺陷，需要被分析探测</p><img src="/.com//06/12/%E8%BD%AF%E4%BB%B6%E9%9C%80%E6%B1%82/image-20220612190042765.png" class title="image-20220612190042765"><h3 id="需求确认-1"><a href="#需求确认-1" class="headerlink" title="需求确认"></a>需求确认</h3><ul><li>功能逻辑<strong>错误检测</strong></li><li>需求描述与用户预期的软件行为的<strong>一致性分析</strong></li><li><strong>错误结果分析</strong></li></ul><h3 id="需求管理-1"><a href="#需求管理-1" class="headerlink" title="需求管理"></a>需求管理</h3><img src="/.com//06/12/%E8%BD%AF%E4%BB%B6%E9%9C%80%E6%B1%82/image-20220612190221238.png" class title="image-20220612190221238"><img src="/.com//06/12/%E8%BD%AF%E4%BB%B6%E9%9C%80%E6%B1%82/image-20220612190335830.png" class title="image-20220612190335830"><h2 id="最佳实践过程"><a href="#最佳实践过程" class="headerlink" title="最佳实践过程"></a>最佳实践过程</h2><img src="/.com//06/12/%E8%BD%AF%E4%BB%B6%E9%9C%80%E6%B1%82/image-20220612190309021.png" class title="image-20220612190309021"><h1 id="Lecture-3-需求获取：愿景与目标分析"><a href="#Lecture-3-需求获取：愿景与目标分析" class="headerlink" title="Lecture 3 需求获取：愿景与目标分析"></a>Lecture 3 需求获取：愿景与目标分析</h1><p>如何开启需求分析的第一步：确定产品愿景和范围</p><h2 id="系统的愿景与范围"><a href="#系统的愿景与范围" class="headerlink" title="系统的愿景与范围"></a>系统的愿景与范围</h2><p>需求获取的<strong>起步</strong>。</p><blockquote><p>在深入讨论一个“问题”之前，我们需要先界定问题的关注<strong>目标</strong>和<strong>范围</strong></p></blockquote><h3 id="Vision"><a href="#Vision" class="headerlink" title="Vision"></a>Vision</h3><p>What the product is about and what it eventually could become?</p><p>软件产品的目标和愿景。是产品的整体方向。</p><ul><li>我们在讨论什么？</li><li>为什么要做这个产品？</li><li>产品应该有怎么样的目标？</li></ul><h3 id="Scope"><a href="#Scope" class="headerlink" title="Scope"></a>Scope</h3><p>What portion of the ultimate long-term product vision the current project will address?</p><p>当前项目中，软件要解决的问题的边界。当前边界限定。</p><ul><li>哪些问题属于这个项目？</li><li>这款软件产品在怎么样的环境里？</li><li>产品应该完成怎样的任务？</li></ul><h3 id="愿景与范围文档"><a href="#愿景与范围文档" class="headerlink" title="愿景与范围文档"></a>愿景与范围文档</h3><ul><li>业务需求</li><li>总体方案</li><li>范围与约束</li><li>业务环境因素</li></ul><p>谁来撰写？客户，用户，需求分析人员。</p><h3 id="业务需求"><a href="#业务需求" class="headerlink" title="业务需求"></a>业务需求</h3><ul><li>产品背景</li><li>市场机遇</li><li>业务目标</li><li>市场分析</li><li>风险评估</li></ul><blockquote><p>例：解决什么问题，增加多少利润，达到多大规模，市场占有率达到多少，……</p></blockquote><h3 id="愿景与整体方案"><a href="#愿景与整体方案" class="headerlink" title="愿景与整体方案"></a>愿景与整体方案</h3><ul><li>产品特征</li><li>产品成功研制的环境和条件因素</li></ul><p>例：<img src="/.com//06/12/%E8%BD%AF%E4%BB%B6%E9%9C%80%E6%B1%82/image-20220612231700108.png" class title="image-20220612231700108"></p><p>范围与约束</p><ul><li>初始产品的功能与性能范围</li><li>各版本产品的范围</li><li>约束与限制条件</li></ul><img src="/.com//06/12/%E8%BD%AF%E4%BB%B6%E9%9C%80%E6%B1%82/image-20220612231743859.png" class title="image-20220612231743859"><p>愿景与范围文档中，愿景的描述相对直观、易理解问题在于如何有效地把软件的<strong>“边界”</strong>描述出来。</p><p><strong>如何描述或刻画一个实体或问题的边界？</strong>——关联图</p><hr><h3 id="关联图-Context-Diagram"><a href="#关联图-Context-Diagram" class="headerlink" title="关联图 Context Diagram"></a>关联图 Context Diagram</h3><p>刻画系统与外部环境的交互关系，以此体现“边界”。</p><blockquote><p>注意：</p><ul><li><strong>软件产品</strong>被抽象为一个整体，用<strong>椭圆</strong>表示</li><li><strong>外部的交互对象</strong>可以是其他系统或者人，用<strong>矩形</strong>表示</li><li>以<strong>箭头</strong>表示<strong>数据访问</strong>关系</li><li>外部参与者如何运行，是不需要表现出来的</li></ul></blockquote><p>例：列车控制软件的context diagram</p><img src="/.com//06/12/%E8%BD%AF%E4%BB%B6%E9%9C%80%E6%B1%82/image-20220612233401970.png" class title="image-20220612233401970"><hr><h2 id="需求获取（Requirements-Elicitation）"><a href="#需求获取（Requirements-Elicitation）" class="headerlink" title="需求获取（Requirements Elicitation）"></a>需求获取（Requirements Elicitation）</h2><p>The process of identifying the <strong>needs</strong> and <strong>constraints</strong> of the <strong>various stakeholders</strong> for a software system.</p><ul><li>一个工程过程</li><li>识别需求与约束需求与约束</li><li>来自于不同涉众</li></ul><p>它是软件设计的第一阶段，其本质主要是人的活动，涉及软件设计人员如何与客户建立有效的沟通。</p><ul><li>Think</li><li>Clarify</li><li>Communicate</li></ul><p><strong>听取用户需求</strong></p><blockquote><p>注意:  用户需求 ≠ 软件功能</p></blockquote><ol><li>确定用户需求的来源</li><li>划分出软件产品的不同用户类别</li><li>针对每类用户深入沟通</li><li>与每类用户确定需求内容</li></ol><h3 id="需求来源"><a href="#需求来源" class="headerlink" title="需求来源"></a>需求来源</h3><p>产品特征与产品的研制环境</p><img src="/.com//06/12/%E8%BD%AF%E4%BB%B6%E9%9C%80%E6%B1%82/image-20220612233857256.png" class title="image-20220612233857256"><h3 id="用户分类"><a href="#用户分类" class="headerlink" title="用户分类"></a>用户分类</h3><img src="/.com//06/12/%E8%BD%AF%E4%BB%B6%E9%9C%80%E6%B1%82/image-20220612234140462.png" class title="image-20220612234140462"><p>思考：</p><p>每类用户对于需求分析来说都同样重要吗? </p><ul><li>未必。</li></ul><p>每类用户都有特定的需求吗? </p><ul><li>是。</li></ul><p>用户一定是“人”吗?</p><ul><li>未必，也可以是其他系统。</li></ul><h3 id="产品代言人法"><a href="#产品代言人法" class="headerlink" title="产品代言人法"></a>产品代言人法</h3><p>实践中，不可能对每个潜在用户个体进行需求获取，必须从<strong>有代表性的用户</strong>个体那里获得该类用户的需求。</p><p><strong>产品代言人:</strong> 某一类用户群体的代表，负责与需求分析人员沟通</p><blockquote><p>课后思考题：</p><ol><li><p>智能软件的需求分析和描述，会和传统软件一样吗？</p></li><li><p>如果尝试用需求获取的技术入手，AlphaGo的需求能否被分类，关联图有没有可能画出来？</p></li></ol></blockquote><h1 id="Lecture-4-需求获取：需求的分类"><a href="#Lecture-4-需求获取：需求的分类" class="headerlink" title="Lecture 4 需求获取：需求的分类"></a>Lecture 4 需求获取：需求的分类</h1><h2 id="需求获取的关键技术"><a href="#需求获取的关键技术" class="headerlink" title="需求获取的关键技术"></a>需求获取的关键技术</h2><p><strong>个别访谈：“要有效提问”</strong></p><p><strong>讨论会</strong></p><p><strong>分类</strong></p><img src="/.com//06/12/%E8%BD%AF%E4%BB%B6%E9%9C%80%E6%B1%82/image-20220612234423257.png" class title="image-20220612234423257"><h2 id="需求获取的完整性分析技术"><a href="#需求获取的完整性分析技术" class="headerlink" title="需求获取的完整性分析技术"></a>需求获取的完整性分析技术</h2><p>如何判断需求已经充分获取了？</p><h3 id="常规的经验判别方式"><a href="#常规的经验判别方式" class="headerlink" title="常规的经验判别方式"></a>常规的经验判别方式</h3><ul><li>功能分解达到特定层次</li><li>每个用户分类都至少被覆盖</li><li>每个需求类别都被覆盖</li><li>出现了冗余或重复的需求</li></ul><h3 id="CRUD矩阵"><a href="#CRUD矩阵" class="headerlink" title="CRUD矩阵"></a>CRUD矩阵</h3><p>Create, Read, Update, and Delete</p><ul><li>从数据变量的<strong>产生、读取、更新（写）和删除</strong>这几个状态变化来判断需求的<strong>完整性</strong>或<strong>充分性</strong>。</li><li>软件功能本身是变量变化的反映，通过对变量本身的状态观察，一定程度上可以判断功能<u>是否充分描述</u></li></ul><p>例：列车控制软件的部分数据项CRUD分析</p><p><strong>功能</strong>：上电启动、行车加速、行车监控、制动停车、维护检测</p><p><strong>数据项</strong>：速度、加速度、车轮位移</p><img src="/.com//06/12/%E8%BD%AF%E4%BB%B6%E9%9C%80%E6%B1%82/image-20220612234746011.png" class title="image-20220612234746011"><p>需求描述不充分：未定义行车加速</p><h2 id="需求理解的技术"><a href="#需求理解的技术" class="headerlink" title="需求理解的技术"></a>需求理解的技术</h2><p>需求理解的两种技术</p><ul><li>用例</li><li>事件-响应表</li></ul><h3 id="用例"><a href="#用例" class="headerlink" title="用例"></a>用例</h3><p>刻画用户和待开发的软件系统是如何交互的描述机制</p><h4 id="图形化的描述"><a href="#图形化的描述" class="headerlink" title="图形化的描述"></a>图形化的描述</h4><img src="/.com//06/12/%E8%BD%AF%E4%BB%B6%E9%9C%80%E6%B1%82/image-20220613100035638.png" class title="image-20220613100035638"><blockquote><p>注意：use case diagram与context-diagram的区别</p><p>与关联图不同，用例图确实提供了<strong>对系统的一些可见性</strong>。 系统边界框内的每个椭圆代表一个用例。 用例图显示了系统与其用户的交互以及内部系统操作之间的一些联系。</p><p>而关联图强调的是内外交互而非用户使用视角。</p><p>画法、侧重点和差别</p></blockquote><h4 id="文本化的描述"><a href="#文本化的描述" class="headerlink" title="文本化的描述"></a>文本化的描述</h4><ul><li><p>标识符(Use case ID)</p></li><li><p>“verb + object”即动宾结构的名称 (Use case name)</p></li><li><p>整体功能简述(Description)</p><img src="/.com//06/12/%E8%BD%AF%E4%BB%B6%E9%9C%80%E6%B1%82/image-20220613101150321.png" class title="image-20220613101150321"></li><li><p>用例的前置-后置条件(Pre &amp; Post condition)</p><img src="/.com//06/12/%E8%BD%AF%E4%BB%B6%E9%9C%80%E6%B1%82/image-20220613101200869.png" class title="image-20220613101200869"></li><li><p>可观察到的事件执行步骤(Basic Flow&#x2F;Alternative flow)</p><ul><li>Normal course: 基本的场景</li><li>Alternative course: 可选的场景</li><li>Exception: “非法”的场景</li></ul><img src="/.com//06/12/%E8%BD%AF%E4%BB%B6%E9%9C%80%E6%B1%82/image-20220613101227687.png" class title="image-20220613101227687"></li></ul><h3 id="事件-响应表"><a href="#事件-响应表" class="headerlink" title="事件-响应表"></a>事件-响应表</h3><p>有些软件系统，并不一定呈现为显式的“人机信息交互”，而是呈现为<strong>系统对外部信号或事件的响应</strong>。</p><ul><li>事件：用户或环境发生的一个变化或动作，能系统受此刺激而产生一定的反应</li><li>响应：系统对用户或环境变化给出的反应</li></ul><p><strong>事件分类</strong></p><ul><li>用户动作 </li><li>控制信号或中断请求 </li><li>时钟信号</li></ul><p>例：电动汽车控制系统</p><img src="/.com//06/12/%E8%BD%AF%E4%BB%B6%E9%9C%80%E6%B1%82/image-20220613101533486.png" class title="image-20220613101533486"><p>这样的控制软件，需求完整吗？</p><img src="/.com//06/12/%E8%BD%AF%E4%BB%B6%E9%9C%80%E6%B1%82/image-20220613101551630.png" class title="image-20220613101551630"><p>如果我们把<strong>所有事件和响应组合都列出</strong>，则除了前面的组合关系，还可以有如下组合：</p><table><thead><tr><th><strong>Event</strong></th><th><strong>State</strong></th><th><strong>Response</strong></th></tr></thead><tbody><tr><td>press button “Accelerate”</td><td>Parking</td><td>Undefined</td></tr><tr><td>press button “Decelerate”</td><td>Parking</td><td>Undefined</td></tr><tr><td>press button “Stop”</td><td>parking</td><td>Undefined</td></tr><tr><td>press button “Accelerate”</td><td>Reversing</td><td>Undefined</td></tr><tr><td>press button “Decelerate”</td><td>Reversing</td><td>Undefined</td></tr><tr><td>press button “Stop”</td><td>Reversing</td><td>Undefined</td></tr><tr><td>press button “Start”</td><td>Running</td><td>Undefined</td></tr><tr><td>press button “Reverse”</td><td>Running</td><td>Undefined</td></tr></tbody></table><p>通过对事件-响应关系的理解，可以<strong>发现需求的缺失或错误</strong>。</p><h3 id="业务规则的拆解"><a href="#业务规则的拆解" class="headerlink" title="业务规则的拆解"></a>业务规则的拆解</h3><p>规则需要被记录，以便分解为功能</p><img src="/.com//06/12/%E8%BD%AF%E4%BB%B6%E9%9C%80%E6%B1%82/image-20220613112303701.png" class title="image-20220613112303701"><h1 id="Lecture-5-需求文档的撰写"><a href="#Lecture-5-需求文档的撰写" class="headerlink" title="Lecture 5 需求文档的撰写"></a>Lecture 5 需求文档的撰写</h1><ul><li>需求的理解：有要表述的内容需求工程</li><li>专业知识和技能：有需求工程的背景知识和技能</li><li>语文水平：描述得更可读</li></ul><p>一般地，在需求工程这个专业领域，“需求描述文档”被称为<strong>SRS</strong>，即： <em>software requirements specification</em></p><p>需求规格说明书里到底写什么？</p><ul><li>功能信息——软件能做什么</li><li>非功能信息——软件能做多好</li><li>详细——信息充分、精确</li></ul><p>软件需求规格说明的撰写应考虑到如下目标：</p><ul><li>结构化的<strong>可理解</strong>的自然语言描述（well-structured and carefully written natural language）</li><li><strong>直观</strong>的图形化模型描述（intuitive graphical models ）</li><li><strong>精确</strong>的形式化描述（precise formal descriptions）</li></ul><img src="/.com//06/12/%E8%BD%AF%E4%BB%B6%E9%9C%80%E6%B1%82/image-20220613103415119.png" class title="image-20220613103415119"><img src="/.com//06/12/%E8%BD%AF%E4%BB%B6%E9%9C%80%E6%B1%82/image-20220613103439562.png" class title="image-20220613103439562"><img src="/.com//06/12/%E8%BD%AF%E4%BB%B6%E9%9C%80%E6%B1%82/image-20220613103451733.png" class title="image-20220613103451733"><img src="/.com//06/12/%E8%BD%AF%E4%BB%B6%E9%9C%80%E6%B1%82/image-20220613103502776.png" class title="image-20220613103502776"><blockquote><p>注意事项：</p><ul><li>编号与命名规则：数字层次与命名缩写结合</li><li>待处理的条目要显式地标出：TBD </li><li>不描述设计细节：强调做什么，而非怎么做</li></ul></blockquote><p>练习：能否发现需求描述缺陷？</p><img src="/.com//06/12/%E8%BD%AF%E4%BB%B6%E9%9C%80%E6%B1%82/image-20220613103602919.png" class title="image-20220613103602919"><img src="/.com//06/12/%E8%BD%AF%E4%BB%B6%E9%9C%80%E6%B1%82/image-20220613103634451.png" class title="image-20220613103634451"><h2 id="形式化方法"><a href="#形式化方法" class="headerlink" title="形式化方法"></a>形式化方法</h2><p>自然语言描述的软件需求，存在<strong>模糊性</strong>和<strong>不确定性</strong>&#x2F;二义性和<strong>不完整性</strong>。</p><p>需求要精确、充分、正确</p><img src="/.com//06/12/%E8%BD%AF%E4%BB%B6%E9%9C%80%E6%B1%82/image-20220613104337050.png" class title="image-20220613104337050"><p>当我们用数学语言对软件需求进行刻画时，其<strong>模糊性被消除</strong>，且有助于对完整性和一致性的检查。</p><img src="/.com//06/12/%E8%BD%AF%E4%BB%B6%E9%9C%80%E6%B1%82/image-20220613104529642.png" class title="image-20220613104529642"><p>可以消除二义性。</p><p>形式化方法：</p><ul><li>基于<strong>数学</strong>的描述软件系统行为的方法</li><li>软件系统行为的<u>精确描述、开发和验证</u></li></ul><p>特点：</p><ul><li>数学基础</li><li>精确的定义和规则</li><li>自动化处理的优势</li></ul><p><strong>理想的形式化方法引导的软件开发过程</strong></p><img src="/.com//06/12/%E8%BD%AF%E4%BB%B6%E9%9C%80%E6%B1%82/image-20220613104750980.png" class title="image-20220613104750980"><h3 id="形式化方法的技术组成"><a href="#形式化方法的技术组成" class="headerlink" title="形式化方法的技术组成"></a>形式化方法的技术组成</h3><img src="/.com//06/12/%E8%BD%AF%E4%BB%B6%E9%9C%80%E6%B1%82/image-20220613104735536.png" class title="image-20220613104735536"><h3 id="形式化规格说明技术"><a href="#形式化规格说明技术" class="headerlink" title="形式化规格说明技术"></a>形式化规格说明技术</h3><ul><li>以一阶谓词逻辑和集合论为基础的语言符号系统</li><li>开发者可以自行定义语法和语义规则</li></ul><p>Z语言，B方法，Event-B方法，VDM方法，SOFL</p><h4 id="应用实例"><a href="#应用实例" class="headerlink" title="应用实例"></a>应用实例</h4><p>求一个给定变量的平方根</p><img src="/.com//06/12/%E8%BD%AF%E4%BB%B6%E9%9C%80%E6%B1%82/image-20220613111026072.png" class title="image-20220613111026072"><p><strong>精确、抽象、可验证</strong>（可读性不好）</p><p>检查用户账号和密码是否正确</p><img src="/.com//06/12/%E8%BD%AF%E4%BB%B6%E9%9C%80%E6%B1%82/image-20220613111318136.png" class title="image-20220613111318136"><p>针对不同领域的软件需求描述，可以自定义形式化描述语言</p><p>例：针对航空发动机的需求描述语言AEDL</p><h1 id="Lecture-6-软件需求的分析模型数据流图"><a href="#Lecture-6-软件需求的分析模型数据流图" class="headerlink" title="Lecture 6 软件需求的分析模型数据流图"></a>Lecture 6 软件需求的分析模型数据流图</h1><p>软件的分析模型，以<strong>图形形式</strong>从特定的角度直观、精确地刻画软件的<strong>预期功能和行为</strong>等，便于工程人员对需求进行理解与分析。</p><ul><li>abstract (抽象性) </li><li>intuitive (直观性) </li><li>precision (精确性) </li><li>focus on certain perspective (针对性)</li></ul><img src="/.com//06/12/%E8%BD%AF%E4%BB%B6%E9%9C%80%E6%B1%82/image-20220613112828942.png" class title="image-20220613112828942"><p>分析模型的不同视角：</p><ul><li>功能：基本本与功能需求条目对应</li><li>行为：功能或系统的执行方式刻画</li><li>数据：复杂数据的结构化呈现</li></ul><h2 id="数据流图-Data-Flow-Diagram，DFD"><a href="#数据流图-Data-Flow-Diagram，DFD" class="headerlink" title="数据流图 (Data Flow Diagram，DFD)"></a>数据流图 (Data Flow Diagram，DFD)</h2><ul><li>描述<strong>数据如何在软件功能模块之间“流动”</strong></li><li>从<strong>功能之间的数据信息传递关系</strong>层面来刻画系统</li><li>主要描述对象：<ul><li>处理数据的功能(过程) ：<strong>process</strong></li><li>数据资源的集合：<strong>data store</strong></li><li>数据的流动：<strong>data flow</strong></li></ul></li><li>可以对功能进行层次化的组合描述</li></ul><img src="/.com//06/12/%E8%BD%AF%E4%BB%B6%E9%9C%80%E6%B1%82/image-20220613113232482.png" class title="image-20220613113232482"><p>图书馆管理系统的数据流图实例</p><img src="/.com//06/12/%E8%BD%AF%E4%BB%B6%E9%9C%80%E6%B1%82/image-20220613113411493.png" class title="image-20220613113411493"><p>分解黑盒：第一层分解</p><img src="/.com//06/12/%E8%BD%AF%E4%BB%B6%E9%9C%80%E6%B1%82/image-20220613113648094.png" class title="image-20220613113648094"><h3 id="建立数据流图的一般过程"><a href="#建立数据流图的一般过程" class="headerlink" title="建立数据流图的一般过程"></a>建立数据流图的一般过程</h3><ul><li>层次分解</li><li>确定<strong>功能点——process</strong></li><li>确定每个功能点的<strong>输入输出数据流——data flow</strong></li><li>确定<strong>数据资源及读写方向——data store</strong></li><li>层次化组织</li></ul><h2 id="条件数据流图（Condition-Data-Flow-Diagram，CDFD）"><a href="#条件数据流图（Condition-Data-Flow-Diagram，CDFD）" class="headerlink" title="条件数据流图（Condition Data Flow Diagram，CDFD）"></a>条件数据流图（Condition Data Flow Diagram，CDFD）</h2><p>SOFL方法学</p><img src="/.com//06/12/%E8%BD%AF%E4%BB%B6%E9%9C%80%E6%B1%82/image-20220613114417863.png" class title="image-20220613114417863"><p>一个ATM系统：接收操作请求 ；登录校验密码和身份信息； 根据余额判断是否可以取款 ；显示取款后余额</p><img src="/.com//06/12/%E8%BD%AF%E4%BB%B6%E9%9C%80%E6%B1%82/image-20220613114858179.png" class title="image-20220613114858179"><h2 id="数据流图的特点"><a href="#数据流图的特点" class="headerlink" title="数据流图的特点"></a>数据流图的特点</h2><p>优势：</p><ul><li>直观</li><li>易懂</li></ul><p>局限性：</p><ul><li>时序逻辑不清晰</li><li>难以刻画反应式行为</li></ul><p>问题：</p><blockquote><p>DFD是从何而来？有没有可能自动建立？如果可能，其前提条件是什么</p></blockquote><h1 id="Lecture-7-软件需求的分析模型：状态转换图"><a href="#Lecture-7-软件需求的分析模型：状态转换图" class="headerlink" title="Lecture 7 软件需求的分析模型：状态转换图"></a>Lecture 7 软件需求的分析模型：状态转换图</h1><h2 id="状态转换图-State-Transition-Diagram，STD"><a href="#状态转换图-State-Transition-Diagram，STD" class="headerlink" title="状态转换图 (State Transition Diagram，STD)"></a>状态转换图 (State Transition Diagram，STD)</h2><p><strong>主要思想：把软件的行为以“状态转换”呈现出来。</strong></p><p>什么是软件的“状态”？</p><ul><li>软件<strong>变量</strong>与其<strong>赋值</strong>之间关系的集合</li></ul><p>怎样建立状态转换图？</p><ol><li><strong>识别</strong>系统的<strong>状态</strong></li><li><strong>识别驱动状态转换的事件或条件</strong></li><li>逐步<strong>构建迁移关系</strong></li></ol><p>状态转换图**<u>适用于</u>**描述的系统特征：</p><ul><li>嵌入式控制软件</li><li>事件驱动的系统</li></ul><p>例：一部电梯的控制系统</p><img src="/.com//06/12/%E8%BD%AF%E4%BB%B6%E9%9C%80%E6%B1%82/image-20220613115725870.png" class title="image-20220613115725870"><p>扩展问题：如果系统有子系统需要描述，怎么办？</p><p>例：Temperature control system</p><ol><li>系统根据室温，自动调节制冷或制热（温度调节</li><li>系统同时监控房门是否开启，开门过久则停止空调的工作（监控系统</li></ol><img src="/.com//06/12/%E8%BD%AF%E4%BB%B6%E9%9C%80%E6%B1%82/image-20220613115903817.png" class title="image-20220613115903817"><p>通过相应的状态转换图，我们能够：</p><ul><li>理解系统整体行为</li><li>便于对需求进行分析</li></ul><h2 id="需求的分析验证"><a href="#需求的分析验证" class="headerlink" title="需求的分析验证"></a>需求的分析验证</h2><p><strong>可达性分析：</strong></p><p>任意两个模式之间，都应该存在可以到达的路径</p><ul><li>不可达：意味着系统可能“死”在某个状态再也无法运行，或者永远到不了预期的某个模式难点：有箭头未必一定</li><li>可达，关键看条件</li></ul><blockquote><p>当迁移条件十分复杂、状态非常多的时候，人工检测几乎不可能，必须要有工具</p></blockquote><h1 id="Lecture-8-软件需求的分析模型：决策表"><a href="#Lecture-8-软件需求的分析模型：决策表" class="headerlink" title="Lecture 8 软件需求的分析模型：决策表"></a>Lecture 8 软件需求的分析模型：决策表</h1><p>问题：软件需求中，<u>复杂的决策逻辑</u>应如何呈现并分析？</p><h2 id="决策表"><a href="#决策表" class="headerlink" title="决策表"></a>决策表</h2><p>为了能直观而准确地刻画类似复杂逻辑和条件，我们引入了图形化的分析模型决策表</p><ul><li>刻画<strong>系统行为</strong></li><li>刻画不同逻辑条件下系统该如何动作</li></ul><h3 id="决策表的主要构成"><a href="#决策表的主要构成" class="headerlink" title="决策表的主要构成"></a>决策表的主要构成</h3><ul><li><strong>条件因素</strong>与其<strong>取值</strong>(factors and values)</li><li>系统<strong>行为动作</strong></li></ul><h3 id="决策表的建立与分析"><a href="#决策表的建立与分析" class="headerlink" title="决策表的建立与分析"></a>决策表的建立与分析</h3><ul><li>把要分析的条件因素和其对应的取值进行罗列，并在此基础上给出对应的系统动作</li><li>针对条件和取值以及系统动作之间的关系进行分析</li></ul><p>练习示例1：</p><img src="/.com//06/12/%E8%BD%AF%E4%BB%B6%E9%9C%80%E6%B1%82/image-20220613164557818.png" class title="image-20220613164557818"><p>制表：</p><ol><li><p>提取条件（因素）：性别、年龄、学历</p></li><li><p>编号</p><table><thead><tr><th>条件</th><th>取值</th><th>符号</th><th>取值数</th></tr></thead><tbody><tr><td>C1 性别</td><td>男，女</td><td>M,F</td><td>2</td></tr><tr><td>C2 年龄</td><td>&lt;18, 18&lt;&#x3D;age&lt;&#x3D;50, &gt;50</td><td>C,Y,G</td><td>3</td></tr><tr><td>C3 学历</td><td>研究生，大学</td><td>G,U</td><td>2</td></tr></tbody></table></li><li><p>计算所有条件组合数：2*3*2 &#x3D; 12</p></li><li><p>提取结果（行为动作）：课题组长、中层干部、科研人员、行政干部、资料员和考研</p></li><li><p>建立表格</p></li></ol><img src="/.com//06/12/%E8%BD%AF%E4%BB%B6%E9%9C%80%E6%B1%82/image-20220613164914101.png" class title="image-20220613164914101"><h3 id="检查表的完备性"><a href="#检查表的完备性" class="headerlink" title="检查表的完备性"></a>检查表的完备性</h3><ul><li>完备的条件<ol><li><strong>判定列等于条件取值之积</strong></li><li>判定列的<strong>独立性</strong>：<strong>任意两列条件不能完全重复</strong></li></ol></li><li><strong>遗失判定列</strong>：表中实际上缺了2个（有2列没有行为结果）</li><li><strong>矛盾判定列</strong>：相同条件导致不同结果</li><li><strong>冗余判定</strong>：相同条件值并动作结果也重复</li></ul><h3 id="合并与优化"><a href="#合并与优化" class="headerlink" title="合并与优化"></a>合并与优化</h3><p>如果判定表中，有<strong>多列的目标动作一样</strong>，且<strong>条件仅一个不同</strong>，则可以考虑合并。（例如：5与11两列）</p><p>一次优化：</p><img src="/.com//06/12/%E8%BD%AF%E4%BB%B6%E9%9C%80%E6%B1%82/image-20220613165153729.png" class title="image-20220613165153729"><p>二次优化：</p><img src="/.com//06/12/%E8%BD%AF%E4%BB%B6%E9%9C%80%E6%B1%82/image-20220613165232852.png" class title="image-20220613165232852"><p>练习示例2：</p><img src="/.com//06/12/%E8%BD%AF%E4%BB%B6%E9%9C%80%E6%B1%82/image-20220613165301767.png" class title="image-20220613165301767"><h2 id="ER图"><a href="#ER图" class="headerlink" title="ER图"></a>ER图</h2><p>实体关系图：Entity-Relation Diagram</p><ul><li><p>常用于表达系统内的数据关系</p></li><li><p>把数据项视为一种<strong>实体</strong>，刻画其属性和数据项之间的关系，从而表达系统的某些特征</p><ul><li><p>Entity </p></li><li><p>Attribute </p></li><li><p>Relationship </p></li><li><p>Cardinality or degree</p></li></ul></li></ul><h2 id="对话图"><a href="#对话图" class="headerlink" title="对话图"></a>对话图</h2><p>对话图<strong>dialog map</strong>   </p><p>通过描述**<u>界面的转移关系</u>**，间接呈现系统行为以供分析</p><ul><li>抽象表示界面（矩形符号表示单个的界面）</li><li>界面中涉及<strong>迁移</strong>（箭头表示）的要素应该被显式地描述</li><li>迁移条件：<ul><li>用户动作</li><li>数据值的输入</li><li>系统条件</li></ul></li></ul><img src="/.com//06/12/%E8%BD%AF%E4%BB%B6%E9%9C%80%E6%B1%82/image-20220613170507381.png" class title="image-20220613170507381"><ul><li><input checked disabled type="checkbox"> 听网课</li></ul><h1 id="Lecture-9-软件非功能属性的描述"><a href="#Lecture-9-软件非功能属性的描述" class="headerlink" title="Lecture 9 软件非功能属性的描述"></a>Lecture 9 软件非功能属性的描述</h1><p>问题：软件需求中的非功能属性有哪些？该如何描述？</p><p>实践中的难点</p><p>质量属性究竟是哪些指标，并无定论</p><p>用户很难表述出期望的质量属性</p><h2 id="通用的软件质量属性"><a href="#通用的软件质量属性" class="headerlink" title="通用的软件质量属性"></a>通用的软件质量属性</h2><table><thead><tr><th><strong>用户层面</strong></th><th><strong>开发者层面</strong></th></tr></thead><tbody><tr><td>可用性 Availability</td><td>可维护性 Maintainability</td></tr><tr><td>效率 Efficiency</td><td>可移植性 Portability</td></tr><tr><td>扩展性 Flexibility</td><td>可复用性 Reusability</td></tr><tr><td>完整性 Integrity</td><td>可测试性 Testability</td></tr><tr><td>互操作性 Interoperability</td><td></td></tr><tr><td>可靠性 Reliability</td><td></td></tr><tr><td>健壮性 Robustness</td><td></td></tr><tr><td>易用性 Usability</td><td></td></tr></tbody></table><h3 id="可用性"><a href="#可用性" class="headerlink" title="可用性"></a>可用性</h3><p>对系统能正常满足用户需求、进行任务执行的<strong>时间度量</strong>。</p><p>Availability &#x3D; MTTF&#x2F;(MTTF+MTTR) * 100%。</p><p>例：校园网OA系统系统在工作日的6点至24点可用时间达到99.5%；在休息日则达到99%</p><h3 id="效率"><a href="#效率" class="headerlink" title="效率"></a>效率</h3><p>软件系统<strong>对资源的利用能力</strong>。</p><p>资源可能是哪些？</p><p>例：金融机构的交易处理系统软件峰值运行时，确保至少25%的内存保持未被使用状态</p><blockquote><p>注意：</p><p>科学计算和实时控制软件常见此类要求</p><p>“响应时间”、“吞吐能力”等，是工程上常见的描述</p></blockquote><h3 id="扩展性"><a href="#扩展性" class="headerlink" title="扩展性"></a>扩展性</h3><p>软件系统能力<strong>进行扩展（新增功能）的难易程度</strong>。</p><p>近义：伸缩性，延展性</p><p>例：操作系统6个月经验的工程师用1人月即可对系统增加一个打印功能</p><p>扩展性在工程实践中的意义：</p><ol><li>软件系统具备升级能力</li><li>软件产品具备更大的发展空间</li></ol><h3 id="完整性"><a href="#完整性" class="headerlink" title="完整性"></a>完整性</h3><p>常被理解为<strong>安全性</strong></p><ul><li><u>访问控制、防止数据泄露、防止病毒与攻击</u>等都是其组成</li></ul><p>例：金融交易系统只有具备审计权限的用户才能在后台直接浏览普通用户的交易记录</p><h3 id="互操作性"><a href="#互操作性" class="headerlink" title="互操作性"></a>互操作性</h3><p>表征系统与其他系统和服务<strong>交互的便利程度</strong></p><ul><li>系统与其他软件或系统的信息交互能力</li><li>体现了软件系统对外部环境的协同能力</li></ul><p>例： 化学品管理系统应能识别ChemiDraw软件绘制的各种分子结构图</p><p>软件需求分析工具应能导入Word或WPS文档</p><h3 id="可靠性"><a href="#可靠性" class="headerlink" title="可靠性"></a>可靠性</h3><p>系统在特定运行时段内能<strong>不出现错误的概率</strong></p><blockquote><p>注意区别可靠性与可用性</p><p>可靠性是不出现错误的概率</p><p>可用性是可正常运行时间的比例</p></blockquote><h3 id="健壮性"><a href="#健壮性" class="headerlink" title="健壮性"></a>健壮性</h3><ul><li>系统<strong>面对非法或错误输入、意外的环境变化等，仍然能正常运行</strong>的能力</li><li>经得起“破坏”</li></ul><p>例：银行ATM机或网银系统 :当密码输入框内，强行输入特殊符号字符，系统或予以屏蔽，或者弹出提示</p><h3 id="易用性"><a href="#易用性" class="headerlink" title="易用性"></a>易用性</h3><ul><li>软件产品对于用户来说，<strong>使用难易程度</strong>的度量</li><li>即是否“用户友好”</li></ul><hr><p>开发者有另外需要考虑的几个属性：可维护性、可移植性、可测试性、可复用性</p><h3 id="可维护性"><a href="#可维护性" class="headerlink" title="可维护性"></a>可维护性</h3><p>软件修改和缺陷修复的难易程度</p><h3 id="可移植性"><a href="#可移植性" class="headerlink" title="可移植性"></a>可移植性</h3><p>软件从一种运行环境迁移至另一种运行环境的适应程度</p><h3 id="可复用性"><a href="#可复用性" class="headerlink" title="可复用性"></a>可复用性</h3><p>软件从单独的系统转化为另一系统中组件的难易程度</p><h3 id="可测试性"><a href="#可测试性" class="headerlink" title="可测试性"></a>可测试性</h3><p>软件被评测、验证的难易程度</p><blockquote><p>注意：由于属性之间存在一定的冲突，更多时候需要考虑平衡。</p><p>可测试性vs完整性</p><p>完整性vs可移植性</p><p>健壮性vs易用性….</p><p>追求效率会和其他很多属性冲突</p></blockquote><h1 id="Lecture-10-软件需求的确认：软件需求的评审"><a href="#Lecture-10-软件需求的确认：软件需求的评审" class="headerlink" title="Lecture 10 软件需求的确认：软件需求的评审"></a>Lecture 10 软件需求的确认：软件需求的评审</h1><p>问题：软件需求已经描述为文档，如何<strong>确认</strong>用户的需求是被正确且完整描述？</p><blockquote><p>validation vs. verification?</p><ul><li>validation:做正确的事</li><li>verification:内在逻辑的一致性&#x2F;看我要的软件中是否存在逻辑错误</li></ul></blockquote><h2 id="软件需求确认-Validation"><a href="#软件需求确认-Validation" class="headerlink" title="软件需求确认 Validation"></a>软件需求确认 Validation</h2><p>评定需求描述是否真实反映了用户对软件的预期</p><p>checking the conformance of the specification to the user’s intentions</p><p>对于软件开发来说，先确保做正确的事情；做一个“我要的”软件，这是最关心的问题。（Validation）</p><ul><li>表象：确保文档中描述的用户需求是足够充分而且准确的</li><li>本质：文档内容与用户内心期望之间的比较</li></ul><h3 id="常用技术"><a href="#常用技术" class="headerlink" title="常用技术"></a>常用技术</h3><h4 id="Review-评审"><a href="#Review-评审" class="headerlink" title="Review 评审"></a>Review 评审</h4><p><strong>Informal review</strong> approaches include: 非形式化的评审</p><ul><li><strong>walkthrough</strong> 走查，自己再读一遍</li><li><strong>peer deskcheck</strong> 互查，同事交换</li><li><strong>passaround</strong> 审查 多人评审</li></ul><p>The best-established type of <u>formal peer review</u> is called an <strong>Inspection</strong> </p><p>Inspection Roles:</p><ul><li>Author: created the SRS</li><li>Moderator: inspection leader and organizer</li><li>Reader: paraphrases each requirements for checking defects</li><li>Recorder: document and confirm detected issues</li></ul><p>Inspection Stages:</p><img src="/.com//06/12/%E8%BD%AF%E4%BB%B6%E9%9C%80%E6%B1%82/image-20220613205634710.png" class title="image-20220613205634710"><p> 评审会</p><ul><li>文档作者解读每条需求</li><li>文档审查者根据解读和<strong>问题清单</strong>探测缺陷</li><li>记录者记录缺陷和问题</li><li>给出结论</li><li>大规模修改，小规模修改</li><li>接受</li><li>拒绝</li></ul><p><strong>问题清单(Check List)</strong></p><ul><li>引导审查的重要依据</li><li>针对不同需求内容会有差异</li><li>需求工程理论和经验的产物</li></ul><h4 id="Testing-测试"><a href="#Testing-测试" class="headerlink" title="Testing 测试"></a>Testing 测试</h4><p>软件需求的测试方法待测对象：软件需求</p><p>文档难点：测试的依据（靠什么测试？</p><p>测试数据来源：场景、更上层需求或是用户判断</p><p>方法过程</p><ol><li>确定被测试的功能需求描述</li><li><strong>转换为可测试的描述形式</strong>（用例、对话图）</li><li>确定测试数据的来源产生测试数据，<strong>“运行”需求</strong>，记录“运行结果”</li><li>根据3，产生测试预期结果比较“运行结果”和预期结果之间的一致性</li></ol><h4 id="Prototyping-原型法"><a href="#Prototyping-原型法" class="headerlink" title="Prototyping 原型法"></a>Prototyping 原型法</h4><p>详见下节</p><h1 id="Lecture-11-软件需求的确认：软件原型方法"><a href="#Lecture-11-软件需求的确认：软件原型方法" class="headerlink" title="Lecture 11 软件需求的确认：软件原型方法"></a>Lecture 11 软件需求的确认：软件原型方法</h1><p>需求确认的目标</p><h2 id="软件原型"><a href="#软件原型" class="headerlink" title="软件原型"></a>软件原型</h2><ul><li>让需求变得可视化</li><li>让需求变成用户能直接观察和理解的形态</li><li>让需求变成可以“运行”的形式</li><li>激发潜在的未描述的需求</li><li>越早“跑起来”越能减小产品研制的风险</li></ul><h2 id="软件原型的意义"><a href="#软件原型的意义" class="headerlink" title="软件原型的意义"></a>软件原型的意义</h2><p>业务层面：快速研制，快速上市</p><p>需求层面：<strong>尽早发现需求的缺陷</strong></p><p>设计层面：给出了可参考的设计方案</p><p>实现层面：给出了可参考的界面</p><p>验证与测试层面：产品的<strong>可行性体现</strong></p><blockquote><p>软件开发的诸多不确定性，一定程度上可以通过原型来化解。</p></blockquote><h2 id="原型的分类"><a href="#原型的分类" class="headerlink" title="原型的分类"></a>原型的分类</h2><p>按对<strong>需求的描述方式</strong>划分</p><ul><li>水平原型</li><li>垂直原型</li></ul><img src="/.com//06/12/%E8%BD%AF%E4%BB%B6%E9%9C%80%E6%B1%82/image-20220613222742818.png" class title="image-20220613222742818"><p>按<strong>原型的使用目的和方式</strong>划分</p><ul><li>可抛弃原型</li><li>演化式原型</li></ul><img src="/.com//06/12/%E8%BD%AF%E4%BB%B6%E9%9C%80%E6%B1%82/image-20220613222758974.png" class title="image-20220613222758974"><blockquote><p>注意：</p><ul><li>不能简单划等号：水平原型&#x3D;可抛弃，垂直原型&#x3D;演化式</li><li>演化式的原型是需要代码编写的，无捷径可走</li></ul></blockquote><h1 id="Lecture-12-软件需求的管理"><a href="#Lecture-12-软件需求的管理" class="headerlink" title="Lecture 12 软件需求的管理"></a>Lecture 12 软件需求的管理</h1><ul><li>用户常常变更需求</li><li>开发方常常盲目承诺接受需求变更</li><li>意变更需求，最终导致所有人都无法满意，大量的软件项目因此不得不追加成本甚至失败</li></ul><p>基线版本：</p><img src="/.com//06/12/%E8%BD%AF%E4%BB%B6%E9%9C%80%E6%B1%82/image-20220613223442325.png" class title="image-20220613223442325"><p>基线版本&#x3D;&gt;变更处理过程&#x3D;&gt;新版本的需求</p><h2 id="软件需求的变更"><a href="#软件需求的变更" class="headerlink" title="软件需求的变更"></a>软件需求的变更</h2><ul><li>需求变更是不可避免的</li><li>需求变更并非是负面的</li></ul><h3 id="需求变更管理的主要活动"><a href="#需求变更管理的主要活动" class="headerlink" title="需求变更管理的主要活动"></a><strong>需求变更管理的主要活动</strong></h3><ul><li>变更控制: 建议变更,分析影响,决定变更,更新需求文档 变更计划 测量需求的稳定性</li><li>版本控制: 定义版本标识方法 确定需求文档版本,确定单个需求文档版本</li><li>需求跟踪: 定义对其它需求的连接链定义对其它系统元素的连接链</li><li>需求状态跟踪: 定义可能的需求状态, 记录每一个需求状态,记录所有需求的状态分布情况</li></ul><p><strong>不控制需求变更会怎样？</strong></p><p>风险很大:</p><ol><li>在已经被废弃的需求上投入时间和成本</li><li>错误需求持续传递到后续软件工程活动中</li><li>在错误需求基础上修订项目方案 …..</li></ol><ul><li>版本的变化，肯定来自于具体的需求条目的变化</li><li>所以宏观层面上，我们看到的是版本控制，而微观层面上则是需求的变化</li><li>所以，在微观层面肯定要有对需求条目的控制</li></ul><p><strong>以“对象”的视角看待单条需求:</strong></p><ul><li>优先级</li><li>风险等级</li><li>安全等级… …</li></ul><img src="/.com//06/12/%E8%BD%AF%E4%BB%B6%E9%9C%80%E6%B1%82/image-20220613224151878.png" class title="image-20220613224151878"><img src="/.com//06/12/%E8%BD%AF%E4%BB%B6%E9%9C%80%E6%B1%82/image-20220613224601774.png" class title="image-20220613224601774"><h2 id="需求状态变化和版本控制"><a href="#需求状态变化和版本控制" class="headerlink" title="需求状态变化和版本控制"></a>需求状态变化和版本控制</h2><p>版本的控制</p><ul><li>需求的变更记录</li><li>变更的理由</li><li>时间与人员信息</li></ul><p>变更管理的<strong>人员组织</strong>因素</p><img src="/.com//06/12/%E8%BD%AF%E4%BB%B6%E9%9C%80%E6%B1%82/image-20220613224657346.png" class title="image-20220613224657346"><p>变更管理的<strong>过程控制</strong></p><img src="/.com//06/12/%E8%BD%AF%E4%BB%B6%E9%9C%80%E6%B1%82/image-20220613224711945.png" class title="image-20220613224711945"><ul><li>新版本需求文档的产生来源于需求内容的变化</li><li>需求内容的变化本质是需求状态变化</li></ul><img src="/.com//06/12/%E8%BD%AF%E4%BB%B6%E9%9C%80%E6%B1%82/image-20220613224850812.png" class title="image-20220613224850812"><p>影响关系的分析技术</p><h1 id="Lecture-13-工具初探"><a href="#Lecture-13-工具初探" class="headerlink" title="Lecture 13 工具初探"></a>Lecture 13 工具初探</h1><img src="/.com//06/12/%E8%BD%AF%E4%BB%B6%E9%9C%80%E6%B1%82/image-20220614090653146.png" class title="image-20220614090653146"><h1 id="Lecture-14-软件需求与形式化方法"><a href="#Lecture-14-软件需求与形式化方法" class="headerlink" title="Lecture 14 软件需求与形式化方法"></a>Lecture 14 软件需求与形式化方法</h1><h2 id="形式化方法-1"><a href="#形式化方法-1" class="headerlink" title="形式化方法"></a>形式化方法</h2><p>基于数学</p><p>提供框架</p><p>一致性、完整性和正确性</p><h3 id="形式化规格说明技术-1"><a href="#形式化规格说明技术-1" class="headerlink" title="形式化规格说明技术"></a>形式化规格说明技术</h3><p>把需求用形式化语言描述出来</p><p>无矛盾、无死锁、无二义性，….</p><p><strong>形式化描述语言</strong></p><p>以一阶谓词逻辑和集合论为基础的语言符号系统</p><p>开发者可以自行定义语法和语义规则</p><p><strong>常见的形式化语言</strong></p><p>Z语言，B方法，Event-B方法，VDM方法</p><h3 id="形式化验证过程"><a href="#形式化验证过程" class="headerlink" title="形式化验证过程"></a>形式化验证过程</h3><p>需求形式化描述→确定验证目标→选择验证技术→实施严格验证→结果分析评估</p><h2 id="形式化验证"><a href="#形式化验证" class="headerlink" title="形式化验证"></a>形式化验证</h2><p>主要技术包括定理证明和模型检测</p><ul><li>形式化验证</li><li>定理证明</li><li>模型检查</li></ul><h3 id="需求建模过程"><a href="#需求建模过程" class="headerlink" title="需求建模过程"></a>需求建模过程</h3><p>非形式化阶段</p><p>半形式化阶段：数据定义的形式化，只定义单元结构，不定义层次结构</p><p>形式化阶段</p><h3 id="需求建模语言"><a href="#需求建模语言" class="headerlink" title="需求建模语言"></a>需求建模语言</h3><p><strong>SOFL语言（Structured Object-oriented Formal Language）</strong></p><ul><li>一阶谓词逻辑和集合论为基础</li><li>数据类型</li><li>每一个操作定义为“<strong>process</strong>”</li><li>process的层次化组合，构成系统</li></ul><p><strong>CDFD条件数据流图像（Condition Data Flow Diagram）</strong></p><img src="/.com//06/12/%E8%BD%AF%E4%BB%B6%E9%9C%80%E6%B1%82/image-20220614093443462.png" class title="image-20220614093443462"><h1 id="Lecture-15-复习"><a href="#Lecture-15-复习" class="headerlink" title="Lecture 15 复习"></a>Lecture 15 复习</h1><ul><li><input checked disabled type="checkbox"> 什么是”软件需求“？ 一定要有自己的理解和表述，用自己的话表达</li></ul><blockquote><p>IEEE定义：用户求解问题或实现目标的一组条件或能力；系统用来满足合同或标准的一组条件或能力；记录上述条件和能力的文档</p><p>简而言之，软件需求分析的任务就是解决目标系统“做什么”，“人想做什么”的问题，并通过文档化记录下来，但不涉及系统“如何做”的问题。</p></blockquote><img src="/.com//06/12/%E8%BD%AF%E4%BB%B6%E9%9C%80%E6%B1%82/image-20220613174411202.png" class title="image-20220613174411202"><p>软件需求的层次</p><img src="/.com//06/12/%E8%BD%AF%E4%BB%B6%E9%9C%80%E6%B1%82/image-20220613174423284.png" class title="image-20220613174423284"><ul><li><p><input disabled type="checkbox"> 状态转换图、数据流图 一定要好好看</p></li><li><p><input disabled type="checkbox"> 需求确认：什么是validation &amp; verification，有哪些主流的验证确认手段(Review, test, prototyping)</p></li><li><p><input disabled type="checkbox"> 怎样处理变更？变更会带来哪些影响</p></li><li><p><input disabled type="checkbox"> 任何一张图的语法规则、刻画的对象需要了然于心</p></li><li><p><input disabled type="checkbox"> 需求变更：什么是基线？变更带来什么的影响？</p></li></ul><p>关联图</p><p>分析模型：</p><ul><li>状态转换图</li><li>数据流图</li><li>决策表</li></ul><blockquote><p>适用于做哪些分析</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;2021~2022 第二学期的专业选修课——软件需求。&lt;/p&gt;
&lt;h1 id=&quot;Lecture-1-软件需求：课程总览&quot;&gt;&lt;a href=&quot;#Lecture-1-软件需求：课程总览&quot; class=&quot;headerlink&quot; title=&quot;Lecture 1 软件需求：课程总览</summary>
      
    
    
    
    <category term="Study" scheme="http://example.com/categories/Study/"/>
    
    
    <category term="Software Requirements" scheme="http://example.com/tags/Software-Requirements/"/>
    
  </entry>
  
  <entry>
    <title>Review of Computer Networking</title>
    <link href="http://example.com/2022/03/03/Review-of-Computer-Networking/"/>
    <id>http://example.com/2022/03/03/Review-of-Computer-Networking/</id>
    <published>2022-03-03T06:27:39.000Z</published>
    <updated>2023-07-09T18:55:07.462Z</updated>
    
    <content type="html"><![CDATA[<p>&lt;—–更新中—–&gt;</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&amp;lt;—–更新中—–&amp;gt;&lt;/p&gt;
</summary>
      
    
    
    
    
    <category term="408" scheme="http://example.com/tags/408/"/>
    
    <category term="Computer Networking" scheme="http://example.com/tags/Computer-Networking/"/>
    
  </entry>
  
  <entry>
    <title>Review of Data Structure</title>
    <link href="http://example.com/2022/03/03/Data-Structure/"/>
    <id>http://example.com/2022/03/03/Data-Structure/</id>
    <published>2022-03-03T01:38:29.000Z</published>
    <updated>2023-07-09T18:13:48.517Z</updated>
    
    <content type="html"><![CDATA[<p>还没开始T T。</p><h1 id="Chapter-01-Introduction"><a href="#Chapter-01-Introduction" class="headerlink" title="Chapter 01 Introduction"></a>Chapter 01 Introduction</h1><h1 id="Chapter-02-Linear-List"><a href="#Chapter-02-Linear-List" class="headerlink" title="Chapter 02 Linear List"></a>Chapter 02 Linear List</h1><h1 id="Chapter-03-Stack-and-Queue"><a href="#Chapter-03-Stack-and-Queue" class="headerlink" title="Chapter 03 Stack and Queue"></a>Chapter 03 Stack and Queue</h1><h1 id="Chapter-04-String"><a href="#Chapter-04-String" class="headerlink" title="Chapter 04 String"></a>Chapter 04 String</h1><h1 id="Chapter-05-Tree-and-Binary-Tree"><a href="#Chapter-05-Tree-and-Binary-Tree" class="headerlink" title="Chapter 05 Tree and Binary Tree"></a>Chapter 05 Tree and Binary Tree</h1><h1 id="Chapter-06-Graph"><a href="#Chapter-06-Graph" class="headerlink" title="Chapter 06 Graph"></a>Chapter 06 Graph</h1><h1 id="Chapter-07-Search"><a href="#Chapter-07-Search" class="headerlink" title="Chapter 07 Search"></a>Chapter 07 Search</h1><h1 id="Chapter-08-Sort"><a href="#Chapter-08-Sort" class="headerlink" title="Chapter 08 Sort"></a>Chapter 08 Sort</h1>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;还没开始T T。&lt;/p&gt;
&lt;h1 id=&quot;Chapter-01-Introduction&quot;&gt;&lt;a href=&quot;#Chapter-01-Introduction&quot; class=&quot;headerlink&quot; title=&quot;Chapter 01 Introduction&quot;&gt;&lt;/a&gt;C</summary>
      
    
    
    
    <category term="Study" scheme="http://example.com/categories/Study/"/>
    
    
    <category term="408" scheme="http://example.com/tags/408/"/>
    
    <category term="Data Structure" scheme="http://example.com/tags/Data-Structure/"/>
    
  </entry>
  
  <entry>
    <title>Github常见问题与解决方法</title>
    <link href="http://example.com/2022/03/01/Github%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98%E4%B8%8E%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95/"/>
    <id>http://example.com/2022/03/01/Github%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98%E4%B8%8E%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95/</id>
    <published>2022-03-01T02:22:07.000Z</published>
    <updated>2023-07-09T18:13:56.169Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Problem-1-OpenSSL-SSL-read-error"><a href="#Problem-1-OpenSSL-SSL-read-error" class="headerlink" title="Problem 1: OpenSSL SSL_read error"></a>Problem 1: OpenSSL SSL_read error</h1><p>Failed Git Push&#x2F; pull: OpenSSL SSL_read: Connection was reset, errno 10054</p><p>原因：这是服务器的<a href="https://so.csdn.net/so/search?q=SSL&spm=1001.2101.3001.7020">SSL</a>证书没有经过第三方机构的签署，所以报错。造成这个错误很有可能是<strong>网络不稳定</strong>，连接<a href="https://so.csdn.net/so/search?q=%E8%B6%85%E6%97%B6&spm=1001.2101.3001.7020">超时</a>导致的，如果再次尝试后依然报错。</p><p>解决：服务器的SSL证书没有经过第三方机构的签署，所以报错，需要解除SSL认证。为此在Git Bash中输入以下命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git config --global http.sslVerify <span class="string">&quot;false&quot;</span></span><br></pre></td></tr></table></figure><h1 id="Problem-2-Timed-out"><a href="#Problem-2-Timed-out" class="headerlink" title="Problem 2: Timed out"></a>Problem 2: Timed out</h1><p>Failed Git Clone&#x2F; Push: Failed to connect to github.com port 443: Timed out</p><p>原因： 这样的问题往往是由于网络慢访问超时，这时候我们可以在终端选择使用<strong>设置代理</strong>和<strong>取消代理</strong>的命令解决。</p><p>解决：</p><p>设置代理：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">config</span> <span class="comment">--global http.proxy</span></span><br><span class="line">git <span class="built_in">config</span> <span class="comment">--global https.proxy</span></span><br></pre></td></tr></table></figure><p>取消代理：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git config --global --<span class="built_in">unset</span> http.proxy</span><br><span class="line">git config --global --<span class="built_in">unset</span> https.proxy</span><br></pre></td></tr></table></figure><p>我们直接在终端先输入设置代理的命令，再输入取消代理的命令即可解决。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Problem-1-OpenSSL-SSL-read-error&quot;&gt;&lt;a href=&quot;#Problem-1-OpenSSL-SSL-read-error&quot; class=&quot;headerlink&quot; title=&quot;Problem 1: OpenSSL SSL_read </summary>
      
    
    
    
    <category term="Study" scheme="http://example.com/categories/Study/"/>
    
    
    <category term="Git" scheme="http://example.com/tags/Git/"/>
    
  </entry>
  
  <entry>
    <title>Software Test</title>
    <link href="http://example.com/2022/01/09/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95/"/>
    <id>http://example.com/2022/01/09/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95/</id>
    <published>2022-01-09T02:14:12.000Z</published>
    <updated>2023-07-09T18:13:55.978Z</updated>
    
    <content type="html"><![CDATA[<h1 id="软件测试知识点总结"><a href="#软件测试知识点总结" class="headerlink" title="软件测试知识点总结"></a>软件测试知识点总结</h1><p>Not only detect bugs, but also prevent bugs.</p><p>软件测试是贯穿整个软件开发生命周期，对软件产品进验证和确认的活动过程，也是对软件产品质量持续的评估过程，其目的是<strong>尽快尽早地发现软件产品中存在的各种缺陷，尽最大可能揭示软件开发过程中所存在的产品质量风险，实现缺陷预防。</strong></p><p><strong>静态测试</strong>：不执行被测对象</p><p><strong>动态测试</strong>：执行被测对象</p><h2 id="软件缺陷定义"><a href="#软件缺陷定义" class="headerlink" title="软件缺陷定义"></a>软件缺陷定义</h2><p>软件缺陷，通常又被叫做bug或者defect，即为软件或程序中存在的某种破坏正常运行能力的问题、错误，其存在会导致软件产品<strong>在某种程度上不能满足用户的需求</strong>。</p><p>软件缺陷是指存在于软件（程序、数据、文档中的）那些不符合用户需求的问题。</p><span id="more"></span><p>1）软件<strong>未实现产品说明书要求的功能</strong></p><p>2）软件<strong>出现了产品说明书指明不应该出现的错误</strong></p><p>3）软件<strong>实现了产品说明书未提到的功能</strong></p><p>4）软件<strong>未实现产品说明书虽未明确提及但应该实现的目标</strong></p><p>5）软件难以理解、不易使用、运行缓慢或者从测试员的角度看最终用户会认为不好，即为计算机软件或程序中存在的某种破坏正常运行能力的问题、错误，或者隐藏的功能缺陷</p><p>软件缺陷主要分为三种形式：“缺陷”、“故障”、“失效”。</p><h2 id="Defect-Fault-and-Failure"><a href="#Defect-Fault-and-Failure" class="headerlink" title="Defect, Fault and Failure"></a>Defect, Fault and Failure</h2><h3 id="软件缺陷-Software-Defect"><a href="#软件缺陷-Software-Defect" class="headerlink" title="软件缺陷(Software Defect)"></a>软件缺陷(Software Defect)</h3><p><strong>Def.</strong> 存在于软件（文档、数据、程序）之中的<strong>那些不希望或不可接受的偏差</strong>。Bug是口语化的缺陷。</p><p>如少一个逗号、多一语句等。其结果是软件运行于某一特定条件时出现软件故障，这时称 <a href="http://baike.baidu.com/view/107502.htm">软件缺陷</a>被激活。</p><h3 id="软件故障-Fault"><a href="#软件故障-Fault" class="headerlink" title="软件故障 Fault"></a>软件故障 Fault</h3><p>软件运行过程中出现的一种不希望或不可接受的<strong>内部状态</strong></p><p>内部状态：由所有<strong>程序变量的当前值和程序指针</strong>构成</p><h3 id="软件失效-Failure"><a href="#软件失效-Failure" class="headerlink" title="软件失效 Failure"></a>软件失效 Failure</h3><p>软件运行时产生的一种不希望或不可接受的<strong>外部行为结果</strong>。 </p><p>如：<code>系统崩溃，闪退，结果不正确</code>……</p><p>① <strong>外部可见的软件失效</strong>是测试中<strong>推断软件中存在缺陷的基本方法</strong></p><p>② <strong>没有失效并不代表软件中不存在缺陷</strong></p><blockquote><p>软件失效—&gt; 软件缺陷；</p><p>软件缺陷 –&#x2F;–&gt; 软件失效</p></blockquote><p>缺陷具有隐蔽性</p><ul><li>软件中一定存在缺陷</li><li>有缺陷并不一定产生故障；但失效一定能说明有缺陷</li><li>有故障也并不一定会失效</li></ul><h3 id="软件错误-Error"><a href="#软件错误-Error" class="headerlink" title="软件错误 Error"></a>软件错误 Error</h3><ul><li>在软件生存期内的<strong>不希望或者不可接受的人为错误</strong></li><li>软件缺陷本质上是研发人员在软件研发过程中所犯<strong>错误在软件中的可视化结果</strong></li></ul><h2 id="RIP-Model-——缺陷被发现的3个必要条件"><a href="#RIP-Model-——缺陷被发现的3个必要条件" class="headerlink" title="RIP Model ——缺陷被发现的3个必要条件"></a>RIP Model ——缺陷被发现的3个必要条件</h2><ol><li><p>Reachability可达性</p><p>The location or locations in the program that contain the defect must be reached. 执行到包含缺陷的代码</p></li><li><p>Infection感染性</p><p>After executing the location, the state of the program must be incorrect. 在正确和错误代码下运行的内部状态不同</p></li><li><p>Propagation传播性</p><p>The infected state must propagate to cause some output of the program to be incorrect. 输出结果不同</p></li></ol><h1 id="代码单元测试"><a href="#代码单元测试" class="headerlink" title="代码单元测试"></a>代码单元测试</h1><h2 id="逻辑测试"><a href="#逻辑测试" class="headerlink" title="逻辑测试"></a>逻辑测试</h2><p>以代码中逻辑表达式结构为对象的测试，以期发现代码逻辑结构缺陷（不是所有的缺陷类型都可以发现）</p><p>逻辑结构缺陷</p><ol><li>写代码时所犯错误在逻辑表达式上的可视化体现</li><li>逻辑表达式写错了，程序行为不正确</li></ol><h2 id="逻辑覆盖准则"><a href="#逻辑覆盖准则" class="headerlink" title="逻辑覆盖准则"></a>逻辑覆盖准则</h2><ul><li><p><code>逻辑表达式</code>是实现代码特性的核心成份</p></li><li><p>逻辑测试技术：基于逻辑覆盖准则的测试（Logical Coverage Criteria） </p></li><li><p>满足<code>逻辑覆盖准则 ≠ 高质量测试</code></p></li></ul><p><img src="https://img-blog.csdnimg.cn/8d3e29cb557e4ac1a617c8ad052d417f.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBATHVjaWR-RHJlYW0=,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center" alt="在这里插入图片描述"></p><h3 id="语句覆盖（Statement-Coverage）"><a href="#语句覆盖（Statement-Coverage）" class="headerlink" title="语句覆盖（Statement Coverage）"></a>语句覆盖（Statement Coverage）</h3><ul><li>衡量被测代码中的<strong>语句得到执行的程度</strong>。</li><li>如果测试集合能够使得<strong>被测代码中的每条语句至少被执行一次</strong>，那么则说该测试集合<strong>满足了语句覆盖</strong>。</li><li>语句覆盖度 &#x3D; （得到执行的语句数）&#x2F;语句</li></ul><h3 id="判定覆盖（Decision-Coverage）"><a href="#判定覆盖（Decision-Coverage）" class="headerlink" title="判定覆盖（Decision Coverage）"></a>判定覆盖（Decision Coverage）</h3><ul><li>衡量代码中的判定得到执行的程度，期望发现逻辑运算符相关缺陷</li><li>如果测试集合能够使得被测代码中的每个判定至少被执行一次,那么则说该测试集合满足了判定覆盖。</li><li>注意，每个判定被执行一次的含义是指每个判定的所有可能结果都至少出现一次。 </li><li>例 if((num1 &gt;1）&amp;&amp; (num2&#x3D;&#x3D;0))的真假结果都得到执行，才认为该判定被执行。</li><li>判定覆盖度 &#x3D;得到执行的判定数&#x2F;判定总数 ∗ 100%</li></ul><h3 id="条件覆盖（Condition-Coverage）"><a href="#条件覆盖（Condition-Coverage）" class="headerlink" title="条件覆盖（Condition Coverage）"></a>条件覆盖（Condition Coverage）</h3><ul><li>衡量代码中构成判定的各个条件得到执行的程度，期望发现算术运算符相关缺陷</li><li>如果测试集合能够使得被测代码中的每个条件至少被执行一次, 那么则说该测试集合满足了条件覆盖。</li><li>每个条件被执行一次的含义：每个条件的<strong>所有可能结果都至少出现一次</strong></li><li>*注意条件覆盖中会出现 <strong>运算符短路</strong>问题！！！，使得条件覆盖无法达到100% &#x3D;&#x3D;&gt; MC&#x2F;DC准则的产生*)</li></ul><blockquote><p>满足判定不一定满足条件，满足条件不一定满足判定</p></blockquote><h3 id="修正的判定-条件覆盖（Modified-Decision-Condition-Coverage）"><a href="#修正的判定-条件覆盖（Modified-Decision-Condition-Coverage）" class="headerlink" title="修正的判定-条件覆盖（Modified Decision-Condition Coverage）"></a>修正的判定-条件覆盖（Modified Decision-Condition Coverage）</h3><p>判定-条件覆盖存在的问题</p><p>• 对于某些满足判定-条件覆盖的测试集合而言，其揭错能力并不高</p><p>• 短路运算符</p><ul><li><p>期望构成每个判定的每个条件能独立地影响整个判定的结果。</p></li><li><p>在这里独立地影响整个判定的结果是指在其它条件取值不变的情况下，<strong>只改变当前条件的取值就能使得整个判定的结果发生变化。</strong></p></li></ul><p><img src="https://img-blog.csdnimg.cn/c254023b01bb4f538b6fd499925ae5e6.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBATHVjaWR-RHJlYW0=,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center" alt="在这里插入图片描述"></p><h2 id="基于控制流的测试"><a href="#基于控制流的测试" class="headerlink" title="基于控制流的测试"></a>基于控制流的测试</h2><h3 id="Prime-Path-Testing"><a href="#Prime-Path-Testing" class="headerlink" title="Prime Path Testing"></a>Prime Path Testing</h3><ol><li>Constructing Control Flow Graph (CFG)</li><li>Calculating Prime Path set</li><li>Deriving Test Case</li></ol><h3 id="Control-Flow-Graph"><a href="#Control-Flow-Graph" class="headerlink" title="Control Flow Graph"></a>Control Flow Graph</h3><p>A CFG models all executions of a method by describing control structures</p><ul><li><p>Nodes : Statements or sequences of statements (basic blocks)</p><ul><li><strong>Basic Block</strong> : A sequence of statements such that if <u>the first statement is executed, all statements will be</u></li></ul></li><li><p>Edges : Transfers of control</p></li></ul><p><strong>Paths in Graph:</strong> Path is a sequence of nodes(n1, n2, …, nm). A subpath of a path p is a subsequence of p.</p><p><strong>Simple path:</strong> A path from node ni to nj is simple if no node appears more than once, except possibly the first and last nodes are the same. (除起始节点和结束节点可以相同外，路径中每个节点的出现次数有且仅有 1 次。)</p><p><strong>Prime Path:</strong> A simple path that does not appear as a proper subpath of any other simple path. (不是其他简单路径的子路径的简单路径)</p><p><strong>Complete Path:</strong> A path that s<strong>tarts at an initial node</strong> and <strong>ends at a final node</strong></p><h3 id="Calculating-Prime-Path-Set-–-Node-Tree-Method"><a href="#Calculating-Prime-Path-Set-–-Node-Tree-Method" class="headerlink" title="Calculating Prime Path Set – Node Tree Method"></a>Calculating Prime Path Set – Node Tree Method</h3><p><strong>节点树</strong></p><ul><li>以G中的节点为根节点建立的树，且满足<strong>树中除根节点和叶节点可以相同外，从根节点到每个树中节点的路径中，每个节点的出现次数有且仅有 1 次。</strong></li><li>在节点树中，每条从根节点到叶节点的路径即为一条简单路径。</li></ul><p><strong>简单节点树</strong></p><ul><li>若<strong>节点树T不是任何其它节点树的子树</strong>，则称节点树T为简单节点树。</li><li><strong>所有简单节点树的从根节点到叶节点的路径集合为备选的基路径集合</strong>。</li></ul><h2 id="基于数据流的测试"><a href="#基于数据流的测试" class="headerlink" title="基于数据流的测试"></a>基于数据流的测试</h2><h3 id="Def-amp-Use"><a href="#Def-amp-Use" class="headerlink" title="Def &amp; Use"></a>Def &amp; Use</h3><p><strong>c-use (computation-use)</strong></p><ul><li>使用节点USE(v,n)是一个计算使用(记做C-use)，当且仅当语句n是计算语句 （对于计算使用的节点永远有外度&#x3D;1）</li></ul><p><strong>p-use (predicate-use)</strong></p><ul><li>使用节点是一个谓词使用（记做p－use），当且仅当语句n是谓词语句（对于谓词使用的节点永远有外度≥2）</li></ul><p><img src="https://img-blog.csdnimg.cn/48a1d21b8e544d37930d7d6a15d238a9.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBATHVjaWR-RHJlYW0=,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center" alt="在这里插入图片描述"><br>上图的解释为：由于采用的是<strong>值传</strong>（ 值传采用<u>将实参值复制一份给形参的方式传递变量值，并没有将一个值放入与实参关联的内存</u>（指的是右侧的str不是左侧的str））的函数调用形式，因此，有下面的结论：str的定义节点为：12，13；str的使用节点为：13，14，15；p的定义节点为：6，7；使用节点：8 ，其中，对于节点6而言， p是形参，p的存储单元内容是一个地址值，代码会将str（str也是一个指针）的值复制到p的存储单元，因此，是p的定义。<br><img src="https://img-blog.csdnimg.cn/f72830f7af7648d499e1d6773025dbda.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBATHVjaWR-RHJlYW0=,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center" alt="在这里插入图片描述"><br>上图的解释为：由于采用的是<strong>传指针的调用形式</strong>，因此，有下面的结论：str的定义节点为：11，12（虽然没有显示的赋值， 对于<code>传递指针认为实参既有定义又有使用</code>，且是先使用后定义）；str的使用节点为：12，13，14；p的定义节点为：6；使用节点：7； </p><blockquote><p>注：指针传参是<strong>先使用再定义</strong></p></blockquote><h3 id="Du-pair-amp-Du-path"><a href="#Du-pair-amp-Du-path" class="headerlink" title="Du-pair &amp; Du path"></a>Du-pair &amp; Du path</h3><p><strong>定义-使用对（du pair）:</strong> 对于变量 v 而言，若 li是 v 的定义节点，lj是 v 的使用节点，那么由位置 li 和 lj构成的二元组(li, lj)，称为 v 的<strong>定义-使用对。</strong></p><p><strong>定义清除（def-clear）:</strong> 对于 v 的<code>定义-使用对(li, lj)</code>而言（注意一定是定义-使用对，即起始节点一定是定义节点，终点一定是使用节点），如果<code>以 li为起始点，以 li为终止点</code>的路径(li, lk1, lk2 ,lk3,……, lkn,lj)中，<strong>不包含 v 的定义节点</strong>，则称路径(li, lk1, lk2 ,lk3,……, lkn,lj)是定义清除的。(只有起始点为变量v的定义节点)</p><p><strong>定义-使用路径（du-path）：</strong>对于变量 v 而言，从 v 的定义节点到 v 的使用节点的<strong>定义清除的简单路径</strong>称为 v 的定义-使用路径。</p><ul><li>du(ni, nj, v) – 变量v的以ni为开始节点，以nj为结束节点的<strong>定义使用对路径集合</strong>。</li><li>du (ni, <em>v</em>) 表示变量 v 的以ni为定义节点（以ni为起始节点）的所有<strong>定义使用</strong>路径集合</li></ul><p><img src="https://img-blog.csdnimg.cn/999e0fbdbce34ef387ec7ad222b3963f.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBATHVjaWR-RHJlYW0=,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center" alt="在这里插入图片描述"></p><h3 id="Data-Flow-Test-Criteria"><a href="#Data-Flow-Test-Criteria" class="headerlink" title="Data Flow Test Criteria"></a>Data Flow Test Criteria</h3><ol><li>全定义覆盖（All-defs coverage, ADC）: 对于每个变量 v 而言，测试路径需要访问 v 的每一个<strong>定义使用</strong>路径集合 du (ni, v),的某条定义使用路径<ol><li><code>every def reaches a use</code></li></ol></li><li>全使用覆盖（All-uses coverage, AUC）：对于每个变量 v 而言，测试路径需要访问 v 的每一个<strong>定义使用对</strong>路径集合 du (ni, nj, v)的某条定义使用路径<ol><li><code>every def reaches all possible uses</code></li></ol></li><li>全定义-使用覆盖 （All-du-paths coverage, ADUPC）：对于每个变量 v 而言，测试路径需要访问 v 的每一个<strong>定义使用对</strong>路径集合 du (ni, nj, v)的每一条定义使用路径<ol><li><code>cover all the paths between defs and uses</code></li></ol></li></ol><h2 id="变异测试"><a href="#变异测试" class="headerlink" title="变异测试"></a>变异测试</h2><h3 id="变异得分"><a href="#变异得分" class="headerlink" title="变异得分"></a>变异得分</h3><p>MS(T) &#x3D; |D|&#x2F;(|L|+|D|)</p><ul><li>|D|: the number of killed mutants </li><li>|L| : the number of lived mutants</li></ul><p><strong>Mutant</strong></p><ul><li>Live mutant: The mutant that has the same results as that of P against <strong>all test cases</strong> of T, denoted as L 在给定的用例下，变异体与源程序有一样的结果</li><li>Killed mutant : The mutant that has different result to P against at least one test case of T, denoted as D 有一个用例使得变异体与源程序的结果不同</li><li>Equivalent mutant: The mutant that has the same results as that of P against all input domain, denoted as E 特别注意的是等价变异体，在所有输入域下结果都与源程序一样，与源程序等价</li></ul><h3 id="基于变异测试的覆盖"><a href="#基于变异测试的覆盖" class="headerlink" title="基于变异测试的覆盖"></a>基于变异测试的覆盖</h3><ul><li>变异覆盖：所设计的用例能够杀死变异体</li><li>Strongly Killing Mutants: 满足RIP三条原则。</li><li>Weakly Killing Mutants: 满足可达性和可感染性。</li></ul><h1 id="代码接口测试-–-集成测试"><a href="#代码接口测试-–-集成测试" class="headerlink" title="代码接口测试 – 集成测试"></a>代码接口测试 – 集成测试</h1><p><strong>Def.</strong> 将通过单元测试的代码单元逐渐集成在一起直至整个软件系统，以验证<strong>单元之间的接口交互是否满足需求</strong></p><h2 id="集成测试用例生成"><a href="#集成测试用例生成" class="headerlink" title="集成测试用例生成"></a>集成测试用例生成</h2><h3 id="MM-Path-CFG-Based"><a href="#MM-Path-CFG-Based" class="headerlink" title="MM-Path(CFG Based)"></a>MM-Path(CFG Based)</h3><p>定义<strong>单元之间的控制转移路径</strong></p><p>节点：模块执行路径(Module Execution Path, MEP)</p><p>节点之间的关系：基于调用的控制转移</p><p>源节点</p><ul><li>程序执行开始时或重新开始处的语句片断。</li><li>可能是单元中的<strong>第一个可执行语句</strong>或者是<strong>紧接着转移控制到其它单元节点之后的节点</strong>。</li></ul><p>汇节点</p><ul><li>程序执结束处的语句片断。</li><li>可能是单元中的<strong>最后一个可执行语句</strong>或者<strong>转移控制到其它单元的节点</strong>。</li></ul><p>模块执行路径（MEP）：**<code>源节点开始，汇节点结束的语句序列，中间没有汇节点</code>**。通常先找到每个源节点和汇节点，再写出MEP。</p><p><img src="https://img-blog.csdnimg.cn/f87eba6c53c64537b3d773d0d63ec1db.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBATHVjaWR-RHJlYW0=,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center" alt="在这里插入图片描述"><br>消息：一种程序设计语言机制，通过这种机制一个单元将控制</p><p>转移给另一个单元。MM-Path<strong>最低</strong>要求<strong>所有消息均被覆盖至少一次</strong></p><p>MM-Path：</p><ul><li>模块执行路径和消息的序列</li><li>描述包含在单独单元之间控制转移的模块执行路径序列</li></ul><p><img src="https://img-blog.csdnimg.cn/de0037dd6827425daa1abda1b0fec242.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBATHVjaWR-RHJlYW0=,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center" alt="在这里插入图片描述"></p><h3 id="Coupling-du-path-DFG-Based"><a href="#Coupling-du-path-DFG-Based" class="headerlink" title="Coupling du-path(DFG Based)"></a>Coupling du-path(DFG Based)</h3><p><strong>Coupling variable 耦合变量(x,y)：</strong> 形参&#x2F;实参，非局部变量&#x2F;全局变量</p><p><strong>Last def 最后定义节点：</strong>变量x满足-从该定义节点开始存在<strong>经过调用点(callsite&#x2F;return)<strong>到达</strong>另一个代码单元的使用</strong>的<strong>定义清除路径</strong>。</p><p><strong>Use clear 使用清除：</strong> 对于变量 v 而言，一条从节点 ni到 nj的路径 p是使用清除的如果满足路径 p 中不存在 v 的使用节点.</p><p><strong>First use 首次使用节点：</strong>变量使用中–满足<strong>从调用点(entry&#x2F;return)到达该使用节点的路径</strong>是一条<strong>定义清除和使用清除路径</strong>。</p><h4 id="Coupling-du-Pair-耦合定义使用对"><a href="#Coupling-du-Pair-耦合定义使用对" class="headerlink" title="Coupling du Pair 耦合定义使用对"></a>Coupling du Pair 耦合定义使用对</h4><p>For coupling variable (x, y), its coupling du pair is denoted as <code>(A, x, li)-(B, y, lj)</code>,where <code>li the last definition location for variable x in unit A</code> and <code>lj is the first use location in the unit B</code>. </p><p>计算A &amp; B的耦合定义使用对：</p><ol><li>首先找到A &amp; B的耦合变量（对）</li><li>根据DFG找到耦合变量的最后定义 和 首次使用（可以是点、也可以是边）</li><li>耦合的定义使用对</li></ol><h3 id="Coupling-Du-Coverage-Criteria"><a href="#Coupling-Du-Coverage-Criteria" class="headerlink" title="Coupling Du Coverage Criteria"></a>Coupling Du Coverage Criteria</h3><p>A coupling du-path is a simple path from a last-def to a first-use which is consists of </p><ol><li>The def-clear simple path from last-def to callsite&#x2F;return</li><li>The def-clear and use-clear simple path from entry&#x2F; return from to the first-use</li></ol><blockquote><p>耦合定义使用路径中，</p><p>1）对于从caller到callee方向而言，从callee的入口点（entry&#x2F;callsite）到耦合变量第一次使用的路径要求是定义清除且使用清除的；</p><p>2）对于从callee返回caller的方向，在caller接收返回值点（return）到第一次使用的路径是定义清除且使用清除的综合起来，就是enty&#x2F;return</p></blockquote><ol><li>All-Coupling-Def coverage: <strong>every last def</strong> to <strong>at least one first use</strong> 全耦合定义覆盖：对于每个变量 v 而言，测试路径需要访问 v 的<strong>每一个最后定义</strong>和<strong>某个该定义的首次使用</strong>构成的路径。</li><li>All-Coupling-use Coverage: <strong>every last def</strong> to <strong>every first use ** 全耦合使用覆盖：对于每个变量 v 而言，测试路径需要访问 v 的</strong>每一个最后定义<strong>和</strong>所有该定义的首次使用**构成的路径。</li><li>All-Coupling-du-Paths Coverage: <strong>every simple path from every last def to every first use</strong> 全耦合定义使用覆盖：对于每个变量 v 而言，测试路径需要访问 v 的每一个最后定义和所有该定义的首次使用构成的<strong>所有简单路径</strong>。</li></ol><p><strong>系统测试</strong>是测试级别最高的一种测试活动，是将<u>已经集成好的软件系统，作为整个基于计算机系统的一个元素</u>，与计算机硬件、外设、某些支持软件、数据和人员等其它系统元素结合在一起， 在实际运行（使用）环境下，对计算机系统进行一系列的组装测试和确认测试。</p><p>系统测试的对象<strong>不仅包括软件，还包括系统软件所依赖的硬件、外部设备和各类接口</strong>，其目的在于通过与系统的需求定义作比较，发现软件与系统定义不符合或与之矛盾的地方以及系统各个部分是否可以协调工作。</p><p>系统测试分为两大类别</p><ul><li>功能测试</li><li>非功能测试</li></ul><p>这里只对功能测试进行整理。</p><h1 id="系统功能测试"><a href="#系统功能测试" class="headerlink" title="系统功能测试"></a>系统功能测试</h1><h2 id="系统测试用例设计方法"><a href="#系统测试用例设计方法" class="headerlink" title="系统测试用例设计方法"></a>系统测试用例设计方法</h2><h3 id="输入域划分-–-基于等价类思想"><a href="#输入域划分-–-基于等价类思想" class="headerlink" title="输入域划分 – 基于等价类思想"></a>输入域划分 – 基于等价类思想</h3><p><strong>输入域：</strong>待测对象<strong>所有可能输入的集合</strong>，无限性，笛卡尔积，无法穷举。</p><p>Partition Domains: A partition must  satisfy two properties</p><ol><li>Cover the entire domain (completeness,<strong>完备性</strong>) 划分块并集为定义域</li><li>The blocks must not overlap (disjoint,<strong>独特性</strong>) 划分块不相交</li></ol><p><strong>输入域建模：</strong> 划分输入参数的定义域。每个划分只取一个结果。</p><ol><li>Identify parameters(待测因素) under test: inputs,  semantic descriptions </li><li>Find characteristics (待测特征)in the parameters under test : Example Characteristics<ol><li>Input X is null 是否为空</li><li>Order of the input file F (sorted, inverse sorted,arbitrary, …) 文件顺序</li><li>Min separation of two aircraft</li><li>Input device (DVD, CD, VCR, computer, …)</li></ol></li><li>Partition each characteristic (Each partition is usually based on some characteristic C)</li></ol><p>识别<strong>待测因素</strong>（不仅限于输入参数和输出结果）与<strong>待测特征</strong>（待测因素的进一步描述，如业务规则、是否为空、文件规模等）</p><p>Strategies for identifying values :</p><ol><li><p>valid, invalid and special values 有效值、无效值、特殊值</p></li><li><p>Sub-partition some blocks</p></li><li><p>Explore boundaries of domains 边界值</p><p>若输入域是数值区间(a,b): 需要包含介于a, b之间的正常情况，a，b，比a稍微小，比a稍微大一点，比b稍微小一点，比b稍微大一点（7种情况）</p></li></ol><p><strong>输入域（划分块）组合策略：</strong></p><p>组合待测特征、输入域划分结果。</p><h4 id="全组合覆盖-All-Combination-Coverage-ACoC"><a href="#全组合覆盖-All-Combination-Coverage-ACoC" class="headerlink" title="全组合覆盖 All Combination Coverage(ACoC):"></a>全组合覆盖 All Combination Coverage(ACoC):</h4><p>划分块枚举。每个待测特征输入域划分结果的笛卡尔积。</p><p>[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-q6FENFWD-1641542515803)(D:\Grade3-1\非关系型数据库\Screenshots\QQ截图20220105092921.png)]</p><p>Q:待测特征个数  Bi: 第i个待测特征对应的输入域划分集合</p><h4 id="单值覆盖-Each-Choice-Coverage-ECC"><a href="#单值覆盖-Each-Choice-Coverage-ECC" class="headerlink" title="单值覆盖 Each Choice Coverage(ECC)"></a>单值覆盖 Each Choice Coverage(ECC)</h4><p>每个待测特征的每个划分块被测试一次；每个划分块出现一次即可。各个待测特征输入域划分数量的最大值。</p><p><img src="https://img-blog.csdnimg.cn/cf5467e035e34f29b5f5101d160d59f1.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBATHVjaWR-RHJlYW0=,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center" alt="在这里插入图片描述"></p><h4 id="全对偶覆盖-Pair-Wise-Coverage-PWC"><a href="#全对偶覆盖-Pair-Wise-Coverage-PWC" class="headerlink" title="全对偶覆盖 Pair-Wise Coverage(PWC)"></a>全对偶覆盖 Pair-Wise Coverage(PWC)</h4><p>两两不同待测特征输入域元素之间的对关系。是最简单、高效的策略。</p><p><img src="https://img-blog.csdnimg.cn/d3a64a1dab544b33bd2f5830df2bcbc9.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBATHVjaWR-RHJlYW0=,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center" alt="在这里插入图片描述"><br>测试用例数至少为：输入域数量最多的那两个待测特征</p><p>如何计算全对偶覆盖 &amp; 设计用例？</p><p>&#x3D;&#x3D;&gt; 使<strong>每个对偶值</strong>在某个测试用例中至少出现一次</p><ol><li>列数是被测特征个数。在列上标出特征名称，按可能取值的数量降序排列变量。</li><li>行数计算方法如下：如果第一列的可能取值个数是V1，第二列的可能取值个数是V2，表中的行数至少为 V1*V2（也就是说至少有V1 * V2个测试用例)。</li><li>第一列的填写规则：每次重复第一列特征的各个取值V2次。约定第一个特征的相同取值构成一个段。（最好在各个段空出一行，再重复给出下一个取值）</li><li>第二列的填写规则：对于第一个特征的每个段列出第二个特征的所有取值</li><li>增加第三列，使得每个段要包含第三列特征的所有取值并且这些取值的顺序要<strong>使第三列特征和第二列特征也构成全对偶</strong></li><li>依次增加第四列、第五列方法同步骤3，检查各特征之间是否构成全对偶，直至所有特征列完为止</li></ol><h4 id="全T值覆盖-T-Wise-Coverage-TWC"><a href="#全T值覆盖-T-Wise-Coverage-TWC" class="headerlink" title="全T值覆盖 T-Wise Coverage(TWC)"></a>全T值覆盖 T-Wise Coverage(TWC)</h4><p>全对偶覆盖的拓展。需覆盖到t个待测特征之间的关系。</p><h4 id="基本值覆盖-Base-Choice-Coverage-BCC"><a href="#基本值覆盖-Base-Choice-Coverage-BCC" class="headerlink" title="基本值覆盖 Base Choice Coverage(BCC)"></a>基本值覆盖 Base Choice Coverage(BCC)</h4><p>基本值：某个待测特征所有输入域划分取值中，使用频率最高的那个取值。（变量取最常用的正常值）</p><p><img src="https://img-blog.csdnimg.cn/b2b7bd5d4bd84be9a2b9367fa44a239e.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBATHVjaWR-RHJlYW0=,size_17,color_FFFFFF,t_70,g_se,x_16#pic_center" alt="在这里插入图片描述"><br>第一行：所有待测特征取基本值。</p><p>其余行分别对每个待测特征取非基本值(Bi-1)。 因此:<br>$$<br>\sum_{i&#x3D;1}^{Q}(B_i - 1)<br>$$</p><h4 id="多基本值覆盖-Multiple-Base-Choice-Coverage-MBCC"><a href="#多基本值覆盖-Multiple-Base-Choice-Coverage-MBCC" class="headerlink" title="多基本值覆盖 Multiple-Base Choice Coverage(MBCC)"></a>多基本值覆盖 Multiple-Base Choice Coverage(MBCC)</h4><p>如果待测特征有多个基本值（常用值），那么就要覆盖到所有基本值，其余仍然是对每个待测特征取非基本值。</p><h2 id="系统测试用例生成"><a href="#系统测试用例生成" class="headerlink" title="系统测试用例生成"></a>系统测试用例生成</h2><p>测试用例设计的自动化是软件测试发展的必然方向，不管是单元测试、交互测试、系统测试层面，还是安全测试、性能测试层面，都需要测试用例设计的自动化，为了缩短测试周期、降低测试成本、提高测试质量。</p><p><img src="https://img-blog.csdnimg.cn/3cd676a05b9746bba4a9926c2ceccace.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBATHVjaWR-RHJlYW0=,size_10,color_FFFFFF,t_70,g_se,x_16#pic_center" alt="在这里插入图片描述"><br>用自动机建模系统的行为 —— 有限状态自动机 FSM</p><p>W method：用于给定一个FSM作为输入，可以求出能揭错该FSM的所有输入序列.</p><p>W方法意图揭示的4种缺陷：</p><ol><li>Operation error 执行缺陷</li><li>Transfer error 控制错误</li><li>Extra state Error 额外状态错误</li><li>Missing state Error缺失状态错误</li></ol><h3 id="FSM-Definition"><a href="#FSM-Definition" class="headerlink" title="FSM Definition"></a>FSM Definition</h3><p>FSM: (X, Y, Q, q0, g, O)</p><p><img src="https://img-blog.csdnimg.cn/f707021a21b24a97a49b52f4cdc21f9d.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBATHVjaWR-RHJlYW0=,size_19,color_FFFFFF,t_70,g_se,x_16#pic_center" alt="在这里插入图片描述"></p><ul><li>The FSM of the specification is denoted as <em>M</em> </li><li>M is completely <strong>specified, minimal, connected and deterministic</strong></li><li><em>M</em> starts in a fixed initial state</li><li><em>M</em> can be reset accurately to the initial state</li><li>M and IUT (Implementation Under Test 待测代码的输入)have the same input alphabet</li></ul><h4 id="FSM-Properties"><a href="#FSM-Properties" class="headerlink" title="FSM Properties"></a>FSM Properties</h4><p><strong>Completely specified：</strong> 完备性，每个状态对每个输入都要对应的迁移</p><p><strong>Strongly connected：</strong> 连通性，每一对状态(qi,qj)存在输入序列，使得qi —&gt; qj</p><p><strong>Minimal：</strong> 最小性</p><ul><li>k-equivalence: 对长度为k的输入，状态qi(Q1)和状态qj的输出相同</li><li>Machine equivalence: 对M1中任意的状态，在M2中能找到状态与之等价。对M2中任意的状态，在M1中能找到状态与之等价。</li><li>Minimal machine:状态机M的状态数是与之等价的状态机中最小的</li></ul><h3 id="Chow’s-W-Method"><a href="#Chow’s-W-Method" class="headerlink" title="Chow’s W Method"></a>Chow’s W Method</h3><ol><li><p>Estimate the maximum number of states (m) in the correct implementation of the given FSM <em>M</em>. </p><ol><li>This is based on a knowledge of the implementation. In the absence of any such knowledge, let m&#x3D;|Q|.</li></ol></li><li><p>Construct the characterization set <strong>W</strong> for <em>M</em>. 建立缺陷的特征集合W.</p><ol><li>将状态集合Q进行k等价划分(P0–&gt;Pk)</li><li>对Q中每个状态，根据k等价逆序<strong>计算能够区分各个状态的特征输入</strong>（直至到0等价划分算法终止）</li><li>区分每对状态的输入序列 的 并集</li></ol></li><li><p>Construct the testing tree for M. 构造M的测试树（保证可达性和感染性）<br><img src="https://img-blog.csdnimg.cn/63615533abff43f58aec44bb2a1479f2.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBATHVjaWR-RHJlYW0=,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center" alt="在这里插入图片描述"></p></li><li><p>Generate the transition cover set P from the testing tree. 计算迁移覆盖集合P</p><p>A patial path is a path starting from the root of the testing tree and terminating in any node of the tree</p><p>Concatenation of the labels along the edges of a sub-path is a string that belongs to P.  The empty string () also belongs to P</p><p>注：记得加空串</p></li><li><p>Construct set Z from W and m. 计算输入集合Z</p></li></ol><p><img src="https://img-blog.csdnimg.cn/48374445d5fc42dda1e7a9f105b8f907.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBATHVjaWR-RHJlYW0=,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center" alt="在这里插入图片描述"><br>6. Desired test set T&#x3D;P.Z 最后计算测试输入 &#x3D; P.Z（迁移覆盖集合P&amp;输入集合Z笛卡尔积）</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;软件测试知识点总结&quot;&gt;&lt;a href=&quot;#软件测试知识点总结&quot; class=&quot;headerlink&quot; title=&quot;软件测试知识点总结&quot;&gt;&lt;/a&gt;软件测试知识点总结&lt;/h1&gt;&lt;p&gt;Not only detect bugs, but also prevent bugs.&lt;/p&gt;
&lt;p&gt;软件测试是贯穿整个软件开发生命周期，对软件产品进验证和确认的活动过程，也是对软件产品质量持续的评估过程，其目的是&lt;strong&gt;尽快尽早地发现软件产品中存在的各种缺陷，尽最大可能揭示软件开发过程中所存在的产品质量风险，实现缺陷预防。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;静态测试&lt;/strong&gt;：不执行被测对象&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;动态测试&lt;/strong&gt;：执行被测对象&lt;/p&gt;
&lt;h2 id=&quot;软件缺陷定义&quot;&gt;&lt;a href=&quot;#软件缺陷定义&quot; class=&quot;headerlink&quot; title=&quot;软件缺陷定义&quot;&gt;&lt;/a&gt;软件缺陷定义&lt;/h2&gt;&lt;p&gt;软件缺陷，通常又被叫做bug或者defect，即为软件或程序中存在的某种破坏正常运行能力的问题、错误，其存在会导致软件产品&lt;strong&gt;在某种程度上不能满足用户的需求&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;软件缺陷是指存在于软件（程序、数据、文档中的）那些不符合用户需求的问题。&lt;/p&gt;</summary>
    
    
    
    <category term="Study" scheme="http://example.com/categories/Study/"/>
    
    
    <category term="Software Test" scheme="http://example.com/tags/Software-Test/"/>
    
  </entry>
  
  <entry>
    <title>OOAD Summary</title>
    <link href="http://example.com/2022/01/06/OOAD%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/"/>
    <id>http://example.com/2022/01/06/OOAD%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/</id>
    <published>2022-01-06T11:13:04.000Z</published>
    <updated>2023-07-09T18:51:02.871Z</updated>
    
    <content type="html"><![CDATA[<p><em>参考书籍：《Applying UML and Patterns 3rd》</em></p><h1 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h1><p><strong>软件架构</strong>的定义：</p><p>一个程序或计算系统的架构，是该系统的结构，由组件、组件的外部可见的特性、组件之间的关系组成。</p><p>架构是一个软件系统的组织结构，可以递归地分解为多个通过接口相互作用的部件。关系定义接口的连接、约束定义部件的集成。部件包括类、组件、子系统。</p><p>面向对象： 是将系统看作一组相互作用和关联的对象并建模。</p><p>面向对象的特点：系统由相互关联对象组成；通过对象对系统进行描述和建模</p><span id="more"></span><h1 id="Thinking-in-OO"><a href="#Thinking-in-OO" class="headerlink" title="Thinking in OO"></a>Thinking in OO</h1><p><strong>OOA:</strong> 发现并描述问题领域里的<strong>对象或概念</strong>(找出问题领域里的概念类)</p><p><strong>OOD：定义</strong>软件<strong>对象</strong>，以及<strong>它们之间如何协作完成功能的</strong></p><blockquote><p>OOD的输入：包括<u>领域模型&#x2F;概念模型、系统顺序图、用例图、补充规格说明</u>等。<br>OOD输出：Interactions(用例实现–SSD), class diagram(类图),交互图(顺序图、通信图) etc</p></blockquote><p><strong>领域模型&#x2F;概念模型：</strong> 对问题领域的对象或现实事物的可视化表示。</p><p>CRC表示职责：Class + Responsibility + Collaboration</p><p><strong>Unviersal steps of OOD:</strong> </p><ol><li><p>After identifying your requirements and <strong>creating a domain<br>model</strong>,(明确需求 创建领域模型) </p></li><li><p>then <strong>add methods</strong> to the appropriate classes, (为适当的类添加方法)</p></li><li><p>and <strong>define the messaging</strong> between the objects to fulfill the<br>requirements(定义对象之间的消息以实现需求)</p></li></ol><p><strong>OOAD：</strong></p><ol><li>Use Case</li><li>Domain </li><li>Interaction</li><li>Design Class Diagram <ol><li><strong>LRG 低表示差异</strong>，既概念类与软件类差异不大</li></ol></li></ol><p><strong>OOAD最基本过程</strong></p><p><img src="https://img-blog.csdnimg.cn/4cf7645f323a4940b4b92296886ee8ee.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBATHVjaWR-RHJlYW0=,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center" alt="在这里插入图片描述"></p><h1 id="OOAD-Review"><a href="#OOAD-Review" class="headerlink" title="OOAD Review"></a>OOAD Review</h1><p><strong>类和对象关系：</strong> 类是共享相同属性、操作、方法、关系或者行为的一组对象的描述符。</p><p><strong>多态：</strong> 同一类族的不同对象，可以用不同的行为处理同一条消息。比如，父类定义的方法、操作，子类可以重新实现（override）。</p><p><strong>组合与聚合：</strong> 聚合–整体与部分是has-a的关系，部分可以独立于整体存在；组合–整体与部分是part-of的关系，部分无法独立于整体存在，整体没了部分就没了，整体对象控制部分对象的生命周期。</p><blockquote><p>Q:为什么能用组合的地方不用继承？</p><p>A:如果使用继承，父类和子类之间耦合较重，组合相对继承的耦合性更低，组合的可维护性更强。</p></blockquote><p><strong>封装：</strong> 是<strong>隐藏对象的实现细节</strong>的过程。 接口<strong>是唯一访问对象数据的方法</strong>。</p><p><strong>接口：</strong> 为类或者构件设定了一个<strong>外部行为规范</strong>。</p><p><strong>抽象：</strong> 过滤掉对象的一部分特性和操作，直到只剩下你所需要的属性和操作。</p><p>抽象的两个重要指标：内聚性和耦合度</p><ul><li><p>内聚性：如果抽象能够简洁地代表一种清晰的概念，那么抽象是内聚的。</p></li><li><p>耦合度：即与相关联的类的耦合程度。如果耦合度高，那么重用性就低，因为该抽象与系统中的其它模块相关以致于很难单独维护。</p></li></ul><h1 id="UP-Process"><a href="#UP-Process" class="headerlink" title="UP Process"></a>UP Process</h1><p><strong>RUP-Rational Unified Process</strong> 统一开发过程</p><p>RUP最重要的它有三大特点：1）软件开发是一个<strong>迭代</strong>过程，2）软件开发是由<strong>Use Case驱动</strong>的，3）软件开发是<strong>以架构设计（Architectural Design）为中心</strong>的。</p><p><strong>SDP</strong>: Software Development Process 软件开发过程</p><p><strong>SDLC</strong>: Software Development Life Cycle 软件开发生命周期</p><p><strong>瀑布生命周期</strong>(Waterfall Lifecycle)：试图<strong>在编程前详细定义所有或大部分需求</strong>。通常于编程前创建出完整的设计。</p><p><strong>迭代生命周期</strong>(Iterative lifecycle): 在这种生命周期中，开发被组织成一系列<strong>固定的短期小项目</strong>，称为<strong>迭代</strong>；<u>每次迭代都经过测试、集成为可执行的局部系统。每次迭代都有各自的需求分析、设计、实现和测试活动。</u></p><blockquote><p>Q: 为什么迭代开发不是面向对象的？<br>A：迭代开发 是一种<strong>开发过程</strong>，不是<strong>设计方法</strong>，<strong>当然也不是面向对象的</strong>。面向对象是一种<strong>设计方法</strong>。<code>在每一次迭代中都可以用面向对象或其他的设计方法完成设计工作</code>。</p></blockquote><p>理解UP的4个阶段: <code>初始-细化-构建-交付</code></p><p><strong>Inception：</strong> approximate vision, business case, scope, vague estimates.大体上的构想、业务案例、范围和模糊评估。（分析项目的可行性，不是定义所有的需求）</p><ul><li>包括需求分析、关键非功能性需求的确定等。</li><li><strong>10% high risk list:</strong><code>(1)具有重要的架构意义；(2)具有高业务价值；(3)具有高风险</code></li><li><em>初始阶段不是需求阶段，而是<strong>研究可行性</strong>的阶段</em></li></ul><p><strong>Elaboration：</strong> refined vision, iterative implementation of the core architecture, resolution of high risks, identification of most requirements and scope, more realistic estimates. <em>已精华的构想、核心架构的迭代实现、高风险的解决，确定大多数需求</em></p><p><strong>Construction：</strong> iterative implementation of the remaining lower risk and easier elements, and preparation for deployment. <em>对遗留下的风险较低和较简单的元素进行迭代实现，准备部署</em></p><p><strong>Transition：</strong> beta tests, deployment. <em>调试&amp;部署</em></p><p>进化式需求 Evolutionary Requirements</p><ul><li>Functional: behavioral</li><li>Non-functional: others 非功能需求 如安全性，可拓展性等</li></ul><p><strong>SRS ：</strong> System Requirements Specification</p><p> 一个好的SRS应该是： 明确的；完整的； 可证实的；一致的；可修改的；可追溯的。</p><p>FURPS+：Function Use Reliable Performance Support</p><p><strong>SSD</strong>：系统顺序图</p><p>把要开发的<strong>整个系统看作一个黑盒子</strong>，在<strong>系统边界提供接口，研究与参与者的交互</strong>。</p><h1 id="Op-Contract"><a href="#Op-Contract" class="headerlink" title="Op Contract"></a>Op Contract</h1><p>对于一些复杂的系统操作（细粒度软件的系统操作），需要编写操作契约以获得更多分析细节。</p><p><strong>Design by Contract (DbC)</strong></p><ul><li><strong>Software reliability</strong>: requires precise specifications which are honored by both the supplier and  the client. </li><li>DbC uses <strong>assertions</strong> (pre and postconditions,  invariants) as a contract between supplier and client. </li><li>DbC works equally well under inheritance.</li></ul><blockquote><p>细粒度软件类的操作，需要定义“契约”，契约不是针对整个系统的操作（大粒度软件类）</p></blockquote><p><strong>大部分契约在细化阶段进行编写</strong>。只<strong>对最复杂最微妙的系统操作编写契约</strong>(获得分析细节)。</p><p>操作契约使用前置条件和后置条件的形式，<strong>描述领域模型里对象的详细变化</strong>，并作为系统操作的结果。</p><p>格式：</p><ul><li>操作：<strong>操作的名称和参数</strong></li><li>交叉引用：会发生此操作的<strong>用例</strong></li><li>前置条件：执行操作前，对系统或领域模型<strong>对象状态的重要假设</strong>。这些假设比较重要，应该告诉读者</li><li>后置条件：最重要的部分，<strong>完成操作后，领域模型对象的状态</strong>。<code>创建实例，形成关联，修改属性。过去式。</code></li></ul><h1 id="GRASP-——-抽象的设计原则（理念）"><a href="#GRASP-——-抽象的设计原则（理念）" class="headerlink" title="GRASP —— 抽象的设计原则（理念）"></a>GRASP —— 抽象的设计原则（理念）</h1><p>GRASP全称: General Responsibility Assignment Software Patterns 通用的职责分配原则</p><p>GRASP原则将用于<strong>产生可维护、可重用、可理解和易于开发软件</strong>。</p><p>GRASP原则可以帮助设计人员理解面向对象设计的本质，并以一种有条理的、理性的、可解释的方式应用这些设计原则。</p><blockquote><p>OOD的输入：包括<u>领域模型&#x2F;概念模型、系统顺序图、用例图、补充规格说明</u>等。</p><p>OOD输出：Interactions(用例实现–SSD), class diagram(类图),交互图(顺序图、通信图) etc</p></blockquote><p><strong>RDD: 职责驱动设计 Responsibility-Driven Design</strong> —— <strong>设计时考虑对象做什么（行为职责）、或者知道什么（认知职责）</strong></p><p><em>-Doing (行为职责）</em></p><ul><li>Do it yourself: such as creating an object or doing a calculation 自身执行一些行为，如创建对象或计算</li><li>initiating action in other objects 初始化其他对象</li><li>controlling and coordinating activities in other objects 控制&amp;协调其他对象</li></ul><p><em>-Knowing（认知职责）</em></p><ul><li>knowing about private encapsulated data 对私有封装数据的认知</li><li>knowing about related objects 对相关对象的认知</li><li>knowing about things it can derive or calculate 对派生&#x2F;可计算数据的认知</li></ul><p>The translation of responsibilities into classes and methods is influenced by the <code>granularity</code> of the responsibility. （职责的<code>粒度</code>影响到职责到类与方法的转换）</p><p>大粒度职责有数百个类与方法，而小粒度职责可能只有一个方法（一个类）。</p><blockquote><p><strong>职责是一种抽象，而方法实现了职责。</strong></p></blockquote><p>Pattern: Name + Problem + Solution</p><h2 id="Rule1-Creator"><a href="#Rule1-Creator" class="headerlink" title="Rule1: Creator"></a>Rule1: Creator</h2><p><strong>Name</strong>: 创建者</p><p><strong>Problem</strong>: 谁负责创建对象？</p><p><strong>Solution</strong>: Assign class B the responsibility to create an instance of class A if one of these is true (the more the better) :</p><ol><li>B “contains” or compositely aggregates A  B包含A</li><li>B records A  B记录A</li><li>B closely uses A  B频繁使用A</li><li>B has the initializing data for A that will be passed to A when it is created (B is an expert with respect to A)<br>如果有一个以上的选项适用，通常首选 聚集 或包含A的类</li></ol><h2 id="Rule2-Information-Expert"><a href="#Rule2-Information-Expert" class="headerlink" title="Rule2: Information Expert"></a>Rule2: Information Expert</h2><p><strong>Name</strong>: 信息专家</p><p><strong>Problem</strong>: 给对象分配职责的基本原则是什么？</p><p><strong>Solution</strong>: Assign responsibility to the class that has the information necessary to fulfill responsibility（把职责分配给<strong>具有完成该职责所需信息</strong>的那个类）</p><h2 id="Rule3-Low-Coupling"><a href="#Rule3-Low-Coupling" class="headerlink" title="Rule3: Low Coupling"></a>Rule3: Low Coupling</h2><p><strong>Name</strong>: 低耦合</p><p><strong>Problem</strong>: 如何减少因变化产生的影响</p><p><strong>Solution</strong>: 在分配职责时，始终保持低耦合（通常用作我们评估方案的原则）</p><p>下面这些情况会造成类 A、B 之间的耦合：</p><p>a、A 是 B 的属性<br>b、A 调用 B 的实例的方法<br>c、A 的方法中引用的 B，例如 B 是 A 方法的返回值或参数。<br>d、A 是 B 的子类，或者 A 实现 B</p><p>为什么期望 低耦合？</p><p>低耦合往往能够<code>减少修改软件需要的时间、工作量和缺陷</code>。</p><p><code>Note</code>: 为什么信息专家会导致低耦合？<u>因为信息专家在分配职责时，是将职责分给具有该职责信息的类，所以模块自己能把大部分职责完成，不需要关联其他模块。</u></p><p>没有任何耦合也是不行的，这样系统中模块都是离散的。我们的原则是要保证低耦合，但要有一些耦合，系统仍然是多个对象协作的整体。</p><blockquote><p>Q: 什么情况下允许高耦合&#x2F;低内聚?<br>A:与稳定的，得到大众广泛认可的元素&#x2F;模块直接耦合是可以的。比如Java J2EE应用程序可以安全地将自己与Java库直接耦合。便于客户使用。</p></blockquote><h2 id="Rule4-High-Cohesion"><a href="#Rule4-High-Cohesion" class="headerlink" title="Rule4: High Cohesion"></a>Rule4: High Cohesion</h2><p> 在分配职责时，始终保持高内聚</p><p><strong>Goal:</strong> （专注 做少量事情）</p><blockquote><p>内聚：模块内操作之间联系的紧密程度</p><p>耦合：两个子模块之间联系的紧密程度</p><p>为什么内聚要越高越好？一个模块自己就能把职责做完</p></blockquote><h2 id="Rule5-Controller"><a href="#Rule5-Controller" class="headerlink" title="Rule5: Controller"></a>Rule5: Controller</h2><p><strong>Name</strong>: 控制器</p><p><strong>Problem</strong>: 谁负责在UI层之上 首先接收和处理系统操作消息？</p><p><strong>Solution</strong>: Assign the responsibility to a class representing one of the following choices:</p><ol><li><p><code>Facade(外观) Controller</code>: <u>整个系统、根对象</u>等</p><p>represents the overall system, a root object, a device that the object is running within, or a major sub-system（为子系统中的一组接口提供一个一致的界面）</p></li><li><p><code>Use Case or Session Controller</code>: 代表<u>用例或会话</u></p><p>represents a use case scenario within which the system event occurs</p></li></ol><p><strong>Delegation pattern 委派模式</strong>——负责任务的调度和分配任务</p><pre><code>UI层通常收到消息并不自己处理（不包括应用逻辑），而是**委托给其他对象**处理。</code></pre><h2 id="Rule6-Polymorphism"><a href="#Rule6-Polymorphism" class="headerlink" title="Rule6: Polymorphism"></a>Rule6: Polymorphism</h2><p><strong>Name</strong>: 多态</p><p><strong>Problem</strong>: 如何处理基于类型的选择？</p><p><strong>Solution</strong>: 使用多态操作，根据类型变化，动态地分配职责</p><p>GoF相关模式；Adapter, Command, Composite, Strategy</p><blockquote><p>Q：多态与PV之间的关系。</p><p>A：多态是实现PV的方式之一。多态提供一种机制（接口），使系统的局部能适应类型的变化。<strong>只要实现了父类的接口，子类实现的细节可以多种多样</strong>，而实现的改变不会影响使用接口的人，使得我们不用改变现有代码就能基于类型提供不同的行为。</p></blockquote><h2 id="Rule7-Pure-Fabrication"><a href="#Rule7-Pure-Fabrication" class="headerlink" title="Rule7: Pure Fabrication"></a>Rule7: Pure Fabrication</h2><p><strong>Problem</strong>: 既不违反低耦合、高内聚或其他的原则，但<strong>依据信息专家原则获得的解决方案又不合适</strong>的情况下，<strong>如何把职责分配给对象？</strong></p><p><strong>Solution</strong>: 把<strong>高度内聚</strong>的职责<strong>分配给人为虚构出来的一个类</strong>，（强调）<u>这个类在领域模型里没有对应的概念</u>。</p><p>GoF相关模式；Adapter, Command, Strategy</p><h2 id="Rule8-Indirection"><a href="#Rule8-Indirection" class="headerlink" title="Rule8: Indirection"></a>Rule8: Indirection</h2><p><strong>Name</strong>: 间接</p><p><strong>Problem</strong>: 为了避免两个或多个事物之间的直接耦合，应该如何分配职责？</p><p><strong>Solution</strong>: 把职责分配给中介对象（通常是抽象类或接口），以在其他组件或服务之间进行协作，从而使它们不直接耦合。</p><p>GoF Example: Adapter, Facade, Observer</p><blockquote><p>Q：纯虚构与间接的区别？<br>A：出发点不一样：</p><p>纯虚构： 把功能相对集中的、专一的职责分配给一个新定义的<strong>虚拟的类</strong>，而在领域模型中没有这个类对应的物理概念；一般用于将功能过于强大的类再细分，划分出单一功能的类，实现高内聚低耦合。</p><p>间接： 是为了把两个类之间的<strong>直接耦合改为通过一个中间概念</strong>，这个中间概念一般为 接口、或者抽象类。</p></blockquote><h2 id="Rule9-Protected-Variations"><a href="#Rule9-Protected-Variations" class="headerlink" title="Rule9: Protected Variations"></a>Rule9: Protected Variations</h2><p><strong>Name:</strong> 隔离变化</p><p><strong>Problem</strong>: 如何设计 使得内部的变化或不稳定性不会对其他元素产生不良影响？</p><p><strong>Solution</strong>: 使用<strong>一个稳定的接口来封装变更的可以预知点</strong>。如数据封装，多态。接口等。</p><p><em>识别在程序中的那些多变的特征，并且把它们和稳定的特征分离开来。</em></p><h2 id="Object-Design-Examples-with-GRASP"><a href="#Object-Design-Examples-with-GRASP" class="headerlink" title="Object Design Examples with GRASP"></a>Object Design Examples with GRASP</h2><p>使用GRASP进行对象设计</p><p><strong>用例实现</strong>：用<strong>系统顺序图的方式展示用例的功能在设计方案下能否实现</strong>。</p><p>MVC：</p><ul><li><p>M即Model模型是指模型，表示业务规则。</p></li><li><p>V即View视图是指用户看到并与之交互的界面。似我们说的 Panel。</p></li><li><p>C即Controller控制器，接受来自UI的请求，然后进行处理。负责系统的内部的控制、协调。</p></li><li><p>使应用程序的输入、处理和输出分开。</p><blockquote><p>注：MVC是一种架构风格，关注的是软件组织架构，而不是设计模式。</p></blockquote></li></ul><h2 id="Refactor"><a href="#Refactor" class="headerlink" title="Refactor"></a>Refactor</h2><p>可见性 Visibility:</p><p>一个对象看见其他对象或引用其他对象的能力。</p><ul><li>属性——B是A的属性</li><li>参数——B是A中方法的参数</li><li>局部——B是A 中方法的局部对象</li><li>全局——B是具有某种方式的全局可见性</li></ul><p><strong>重构</strong>：<code>重写或重新构建已有代码的结构化和规律性方法。但不改变系统的外部功能。</code><strong>本质上是一小步保留行为的转换</strong>，<u>每次转换都要重新执行单元测试</u>。</p><p>重构是为了得到优秀的代码：</p><ul><li>去除冗余</li><li>改善清晰度</li><li>增强可读性</li><li>提升代码结构</li><li>……</li></ul><p>TDD: Test Driven Development 测试驱动开发——TFD + Refactor</p><p>首先编写测试，并通过不断地重构代码以改进质量。</p><p>Refactor: Name the Condition 引入解释变量，将表达式部分或完整结果置入临时变量中，该变量名能够说明表达式的目的。</p><h2 id="开闭原则（OCP）"><a href="#开闭原则（OCP）" class="headerlink" title="开闭原则（OCP）"></a>开闭原则（OCP）</h2><p><strong>Def.</strong> 模块应该同时开放（可拓展性）和封闭（对影响客户的更改，尽量不改现有的代码）。</p><p>当应用的需求改变时，在<strong>不修改软件实体的源代码</strong>的前提下，可以<strong>扩展模块的功能</strong>，使其满足新的需求。</p><p>可以提高：可拓展性、可复用性、可维护性。</p><h2 id="依赖倒置（DIP）"><a href="#依赖倒置（DIP）" class="headerlink" title="依赖倒置（DIP）"></a>依赖倒置（DIP）</h2><p><strong>Def.</strong> 高层模块不应该依赖低层模块，两者都应该依赖其抽象；抽象不应该依赖细节，细节应该依赖抽象。其核心思想是：<code>要面向接口编程，不要面向实现编程。</code></p><p>依赖倒置原则是<code>实现开闭原则的重要途径之一</code>，它降低了<u>客户与实现模块之间的耦合。</u></p><p><u>相对于面向过程编程的上层依赖下层模块的方式</u>，在面向对象设计时，<strong>上层和下层都依赖抽象</strong>，故称为 “倒置”。<strong>本质就是面向接口编程，而不是面向实现（即底层）编程</strong>。 </p><h2 id="迪米特法则（LoD）"><a href="#迪米特法则（LoD）" class="headerlink" title="迪米特法则（LoD）"></a>迪米特法则（LoD）</h2><p><strong>Def.</strong> 如果两个软件实体无须直接通信，那么就不应当发生直接的相互调用，可以通过第三方转发该调用。其目的是<strong>降低类之间的耦合度，提高模块的相对独立性</strong>。（开闭）</p><p>只与你的直接朋友交谈，不跟“陌生人”说话。</p><p>迪米特法则中的“朋友”是指：<u>当前对象本身、当前对象的成员对象、当前对象所创建的对象、当前对象的方法参数</u>等，这些对象同当前对象存在关联、聚合或组合关系，可以直接访问这些对象的方法。</p><h2 id="里氏替换原则（LSP）"><a href="#里氏替换原则（LSP）" class="headerlink" title="里氏替换原则（LSP）"></a>里氏替换原则（LSP）</h2><p><strong>Def.</strong> 通俗来讲就是：<strong>子类可以扩展父类的功能，但不能改变父类原有的功能。</strong><u>子类继承父类时，除添加新的方法、完成新增功能外，尽量不要重写父类的方法。</u></p><p>对里氏替换原则的定义可以总结如下：</p><ul><li>子类可以实现父类的抽象方法，但不能覆盖父类的非抽象方法</li><li>子类中可以增加自己特有的方法</li><li>当子类的方法重载父类的方法时，方法的前置条件（即方法的输入参数）要比父类的方法更宽松</li><li>当子类的方法实现父类的方法时（重写&#x2F;重载或实现抽象方法），方法的后置条件（即方法的的输出&#x2F;返回值）要比父类的方法更严格或相等</li></ul><h1 id="GoF-——-具体的设计模式（代码）"><a href="#GoF-——-具体的设计模式（代码）" class="headerlink" title="GoF —— 具体的设计模式（代码）"></a>GoF —— 具体的设计模式（代码）</h1><h2 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h2><p><strong>是一套被反复使用、得到大众认可的代码经验的总结。</strong> 它关注系统中类、对象、接口的关系，描述设计过程中经常发生的问题，并提出解决方案。目的是生产可重用、可维护、易于理解（代码可读性）和开发的软件产品。</p><blockquote><p>软件设计模式（Software Design Pattern），又称设计模式，是一套<u>被反复使用、多数人知晓的、经过分类编目的、<strong>代码设计经验的总结</strong></u>。它描述了在软件设计过程中的一些不断重复发生的问题，以及该问题的解决方案。也就是说，它是解决特定问题的一系列套路，是前辈们的代码设计经验的总结，具有一定的普遍性，可以反复使用。**其目的是为了提高代码的可重用性、代码的可读性和代码的可靠性。</p></blockquote><p>主要是为了：</p><ul><li>Reuse Design <u>重用设计</u>    </li><li>Common Vocabulary 为设计<u>提供共同的词汇，便于交流</u></li><li>Easy Documentation <u>编写开发文档更加容易</u></li><li>Easy refactor 应用设计模式可以<u>让重构系统变得容易</u></li></ul><h2 id="SingleTon-单例模式"><a href="#SingleTon-单例模式" class="headerlink" title="SingleTon 单例模式"></a>SingleTon 单例模式</h2><ul><li>名称：单实例类</li><li>问题：希望只有唯一实例的类。对象需要全局可见性和单点访问。</li><li>解决方案：通过静态方法返回单实例</li></ul><p>单例（Singleton）模式的定义：<strong>指一个类只有一个实例，且该类能自行创建这个实例的一种模式。</strong></p><p>SingleTon的三个关键点</p><p>1）私有的： 构造函数(防止被默认地实例化)</p><p>2）私有的：成员变量，记录这个单实例</p><p>3）公有的get函数：<strong>没有实例时创建它</strong>；已有实例则返回该实例。</p><p>相关模式：单实例模式通常运用于工厂对象和外观对象。</p><ul><li>Abstract Factory, Builder, and Prototype can use Singleton in their implementation</li><li>Facade objects are often Singletons because <em>only one Facade object is required</em></li></ul><h2 id="Adapter-适配器"><a href="#Adapter-适配器" class="headerlink" title="Adapter 适配器"></a>Adapter 适配器</h2><p>Problem: 如何解决不相容的接口问题，或者如何为具有不同接口的类似构件提供稳定的接口？</p><p>Solution: 使用 <strong><code>中介</code>适配器对象</strong>，将原有接口转换为其他接口。</p><p>将<strong>一个类的接口转换成客户希望的另外一个接口</strong>。Adapter模式使原本由于接口不兼容而不能一起工作的那些类可以一起工作。</p><p><img src="https://img-blog.csdnimg.cn/20190117145221678.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzMzNjU4Njc3,size_16,color_FFFFFF,t_70" alt="img"><br>相关模式：隐藏外部系统的资源适配器可视作外观对象。</p><h2 id="Facade-外观模式"><a href="#Facade-外观模式" class="headerlink" title="Facade 外观模式"></a>Facade 外观模式</h2><p>Problem: 对<strong>一组完全不同的实现或接口需要公共、统一的接口</strong>。可能会与子系统内部的大量事物产生耦合，或者子系统的实现可能会改变。怎么办？</p><p>Solution: 对子系统定义唯一的接触点——使用外观对象封装子系统。该外观对象提供了唯一和统一的接口，并负责与子系统构建进行协作。</p><p>外观（Facade）模式是一种通过<strong>为多个复杂的子系统提供一个一致的接口</strong>，而使这些子系统更加容易被访问的模式。该模式对外有一个统一接口，外部<strong>应用程序不用关心内部子系统的具体细节</strong>(隔离变化)，这样会大大降低应用程序的复杂度，提高了程序的可维护性。</p><h3 id="适配器与外观模式的区别"><a href="#适配器与外观模式的区别" class="headerlink" title="适配器与外观模式的区别"></a>适配器与外观模式的区别</h3><p>适配器：将一个接口<strong>转换</strong>为客户希望的另外一个接口。<strong>主要是对适配对象进行调整，以便适合客户的需求</strong>。</p><p>外观模式：<strong>定义一个新的</strong>、更简单接口（simpler）来封装多个接口（子系统），以封装子系统实现的变化，减少客户与子系统之间的耦合。</p><p><a href="https://www.cnblogs.com/lzhp/p/3400928.html">适配器模式和外观模式（head first设计模式——6） - haiziguo - 博客园 (cnblogs.com)</a></p><h3 id="外观模式与适配器模式的比较"><a href="#外观模式与适配器模式的比较" class="headerlink" title="外观模式与适配器模式的比较"></a>外观模式与适配器模式的比较</h3><ul><li>外观定义了新的接口，适配器使用旧的接口；</li><li>适配器使得两个不一致的接口协同工作，而不是定义一个新的；</li><li>外观模式的本意是产生一个轻便的接口，适配器的本意是把现有的接口转换一下；</li><li>一个外观接口可能包装了多个现有系统的对象，也可能增加了一些功能，而适配器只是包装了一个对象；</li><li>多数情况下，外观是单实例的。</li></ul><h2 id="GoF-and-GRASP"><a href="#GoF-and-GRASP" class="headerlink" title="GoF and GRASP"></a>GoF and GRASP</h2><p>GRASP是一般性的，基础的原则，比较笼统、抽象。GRASP原则是对其他设计模式的归纳。</p><p>GoF Design  Pattern: <strong>实现GRASP</strong>的精神（更加具体的实现方式）</p><p><code>一句话解释，GRASP是抽象的理念，GoF是具体的代码。</code></p><p>PV is the most fundamental principle!!!<br>Specific GOF patterns are concrete applications of GRASP!!!</p><h2 id="Observer-观察者模式"><a href="#Observer-观察者模式" class="headerlink" title="Observer 观察者模式"></a>Observer 观察者模式</h2><p>Name: 观察者&#x2F;发布-订阅</p><p>Problem: 不同类型的订阅者对象关注于发布者对象的状态变化或事件，并且想要在发布者产生事件时以自己独特的方式作出反应。此外，发布者想要保持与订阅者的低耦合。如何对此进行设计呢？</p><p>Solution: 定义“订阅者”(Subscriber)或“监听器”(Observer)接口。订阅者实现此接口。发布者可以动态注册关注某事件的订阅者，并在事件发生时通知它们。</p><p><img src="https://img-blog.csdnimg.cn/e0b9cc60473e4c5fb4668dd7ec48bc78.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBATHVjaWR-RHJlYW0=,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center" alt="在这里插入图片描述"><br>什么时候使用观察者模式？</p><ul><li>某一个对象的状态发生变化的时候，某些其它的对象需做出相应的改变。</li><li>观察者模式定义了一种<strong>一对多的依赖关系</strong>，让<strong>多个观察者对象同时监听某一个主题对象。</strong></li></ul><h3 id="信息推送的2种形式"><a href="#信息推送的2种形式" class="headerlink" title="信息推送的2种形式"></a>信息推送的2种形式</h3><p><strong>推模式：</strong> 当通知消息来之时，把<u>所有相关信息都<code>通过参数的形式</code>“推给”观察者。</u></p><p>（1）优点</p><ul><li>所有信息通过参数传递过来，直接、简单，观察者可以马上进行处理，高效、实时。</li><li>观察者与被观察者<strong>没有一点联系，两者几乎没有耦合</strong></li></ul><p>（2）缺点</p><ul><li>所有信息都强迫推给观察者，不管有用与否。</li><li>如果想添加一个参数，那就需要修改所有观察者的接口函数。</li></ul><p><strong>拉模式：</strong> 当通知消息来之时，<u>通知的函数不带任何相关的信息</u>，而是要观察者主动去被观察的对象那里去“拉”信息。 (只起通知作用)</p><p>（1）优点</p><ul><li>可以主动去取自己感兴趣的信息。</li><li>如要添加一个参数，无需修改观察者。</li></ul><p>（2）缺点</p><ul><li>观察者与被观察者有一定的联系。（Subject与Observer交互变多）</li></ul><h2 id="Strategy-策略模式"><a href="#Strategy-策略模式" class="headerlink" title="Strategy 策略模式"></a>Strategy 策略模式</h2><p>Problem: 如何设计变化但相关的算法或政策？如何设计才能使这些算法或政策具有可变更的能力？</p><p>Solution: 在单独的类中分别定义每种算法&#x2F;政策&#x2F;策略，并且使其具有共同接口（封装到一系列策略类里面，作为一个抽象类的子类）。</p><p><img src="https://img-blog.csdnimg.cn/img_convert/58b87f51a26b6b6ea8c33717c83f9124.gif" alt="策略模式的结构图"></p><h3 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h3><p>策略模式的主要优点如下。</p><ol><li>多重条件语句不易维护，而使用策略模式可以<strong>避免使用多重条件语句</strong>，如 if…else 语句、switch…case 语句。</li><li>策略模式提供了一系列的可供重用的算法族，恰当使用继承可以把算法族的公共代码转移到父类里面，从而避免重复的代码。</li><li>策略模式可以<strong>提供相同行为的不同实现</strong>（多态），客户可以根据不同时间或空间要求选择不同的。</li><li>策略模式<strong>提供了对开闭原则的完美支持，可以在不修改原代码的情况下，灵活增加新算法</strong>。</li><li>策略模式把<strong>算法的使用</strong>放到环境类中，而<strong>算法的实现</strong>移到具体策略类中，实现了<strong>二者的分离</strong>。</li></ol><p>其主要缺点如下。</p><ol><li><strong>客户端必须理解所有策略算法的区别，以便适时选择恰当的算法类。</strong></li><li>策略模式造成<strong>很多的策略类，增加维护难度</strong>。</li></ol><h2 id="Factory-工厂模式"><a href="#Factory-工厂模式" class="headerlink" title="Factory 工厂模式"></a>Factory 工厂模式</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>工厂方法<strong>定义了一个创建产品对象的工厂接口，将实际创建工作推迟到子类中</strong></p><p><img src="https://img-blog.csdnimg.cn/2872406de51740478ba50214086d33a0.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBATHVjaWR-RHJlYW0=,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center" alt="在这里插入图片描述"></p><h3 id="简单工厂"><a href="#简单工厂" class="headerlink" title="简单工厂"></a>简单工厂</h3><p>将<strong>所有创建对象的逻辑集中到一个核心工厂</strong>中，违背了OCP(新增一个产品，都要修改FactoryMethod)和高内聚职责分配（专注做少量的事）</p><h3 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h3><p>工厂模式是简单工厂的进一步抽象和推广。<strong>核心的工厂类不再负责所有产品的创建，而是将具体创建工作交给子类去做。</strong> 这个<u>核心类仅仅负责给出具体工厂必须实现的接口</u>，而不负责产品类被实例化这种细节，这<u>使得工厂方法模式可以允许系统在不修改工厂角色的情况下引进新产品</u>。（符合OCP和高内聚）</p><h3 id="抽象工厂"><a href="#抽象工厂" class="headerlink" title="抽象工厂"></a>抽象工厂</h3><p>自己看书理解，有点难理解。</p><h3 id="工厂模式的优缺点和适用场景"><a href="#工厂模式的优缺点和适用场景" class="headerlink" title="工厂模式的优缺点和适用场景"></a>工厂模式的优缺点和适用场景</h3><p>优点：</p><ol><li>代码结构清晰，有效封装变化。Client<strong>只关心产品的接口</strong>就可以了，至于具体的实现无需关心。即使变更了具体的实现，对Client来说没有任何影响。</li><li>可扩展性，新产品创建只需要多写一个工厂类（OCP）</li><li>降低耦合度。Client只需要知道产品的抽象类，无须关心其他实现类，解开Client与具体实现的耦合（LoD 迪米特法则）。</li></ol><p>缺点：</p><p>每次增加一个产品时，都需要增加一个具体类和对象实现工厂，使得系统中<strong>类的个数增加</strong>，在一定程度上增加了系统的复杂度，同时也增加了系统具体类的依赖。</p><h2 id="Command-命令模式"><a href="#Command-命令模式" class="headerlink" title="Command 命令模式"></a>Command 命令模式</h2><h3 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h3><p>命令模式将一<strong>个请求封装成一个对象</strong>，将发出请求和执行请求的职责分开。</p><p><img src="https://img-blog.csdnimg.cn/img_convert/099f0378495b26360e1b8c16703490bb.gif" alt="命令模式的结构图"></p><ol><li>抽象命令类（Command）角色：声明执行命令的接口，拥有执行命令的抽象方法 execute()。</li><li>具体命令类（Concrete Command）角色：是抽象命令类的具体实现类，它拥有接收者对象，并通过调用接收者的功能来完成命令要执行的操作。</li><li>实现者&#x2F;接收者（Receiver）角色：执行命令功能的相关操作，是具体命令对象业务的真正实现者。</li><li>调用者&#x2F;请求者（Invoker）角色：是请求的发送者，它通常拥有很多的命令对象，并通过访问命令对象来执行相关请求，它不直接访问接收者。</li></ol><h3 id="优缺点-1"><a href="#优缺点-1" class="headerlink" title="优缺点"></a>优缺点</h3><p>优点：</p><ol><li>通过引入中间件（抽象command接口）降低系统的耦合度。</li><li>扩展性良好，增加或删除命令非常方便。采用命令模式增加与删除命令不会影响其他类，满足OCP。</li><li>可以实现宏命令。命令模式可以与<a href="http://c.biancheng.net/view/1373.html">组合模式</a>结合，将多个命令装配成一个组合命令，即宏命令。</li><li>方便实现 Undo 和 Redo 操作。命令的撤销与恢复。</li><li>可以在现有命令的基础上，增加额外功能。比如日志记录，结合装饰器模式会更加灵活。</li></ol><p>缺点：可能产生<strong>大量具体的命令类</strong>。因为<strong>每一个具体操作都需要设计一个具体命令类</strong>，这会增加系统的复杂性。</p><h2 id="Composite-组合模式"><a href="#Composite-组合模式" class="headerlink" title="Composite 组合模式"></a>Composite 组合模式</h2><p>Problem:  如何能够像处理非组合（原子）对象一样，（多态地）处理一组对象或具有组合结构的对象呢？&#x2F; 如何处理冲突的定价策略？&#x2F; 如何使销售对象（sale）不需要知道是否要处理一个或多个定价策略，而且同时还能够提供一种设计来解决冲突？ </p><p>Solution: 定义原子类和组合类，让它们去实现相同的接口(Component)</p><h3 id="定义-2"><a href="#定义-2" class="headerlink" title="定义"></a>定义</h3><p>部分整体模式，是用于<strong>把一组相似的对象当作一个单一的对象</strong>。组合模式依据<strong>树形结构</strong>来组合对象，用来表示部分以及整体层次。</p><p><img src="https://img-blog.csdnimg.cn/img_convert/b0c8532062e4ff49e3bed35db64d5eca.png" alt="img"></p><p><img src="https://img-blog.csdnimg.cn/img_convert/bacbdb8d3cc7dd25937048f6e5f4b84c.png" alt="img"></p><h3 id="优缺点-2"><a href="#优缺点-2" class="headerlink" title="优缺点"></a>优缺点</h3><p>优点：</p><ol><li>高层模块&#x2F;Client调用简单。可以一致地处理组合对象和单个对象，而不必关心自己处理的是单个对象还是整个组合结构。</li><li>节点自由增加，满足OCP。</li></ol><p>缺点：使用组合模式时，其叶子和树枝的声明都是实现类，而不是接口，违反了依赖倒转原则。违背ICP</p><h2 id="DP-OO-Principle"><a href="#DP-OO-Principle" class="headerlink" title="DP_OO_Principle"></a>DP_OO_Principle</h2><p>僵硬性 Rigidity</p><ul><li>难以更改代码</li><li>从管理的角度，拒绝任何的变化成为一种制度</li></ul><p>易碎性 Fragility</p><ul><li>即使是小小的改动也会导致级联性的后果</li><li>代码在意想不到的地方终止</li></ul><p>固定性 Immobility</p><ul><li>代码纠缠在一起根本不可能重用</li></ul><p>黏滞性 Viscosity</p><ul><li>宁愿重新编写也不愿意修改</li></ul><p>OCP&amp;DIP 回顾</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;em&gt;参考书籍：《Applying UML and Patterns 3rd》&lt;/em&gt;&lt;/p&gt;
&lt;h1 id=&quot;Introduction&quot;&gt;&lt;a href=&quot;#Introduction&quot; class=&quot;headerlink&quot; title=&quot;Introduction&quot;&gt;&lt;/a&gt;Introduction&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;软件架构&lt;/strong&gt;的定义：&lt;/p&gt;
&lt;p&gt;一个程序或计算系统的架构，是该系统的结构，由组件、组件的外部可见的特性、组件之间的关系组成。&lt;/p&gt;
&lt;p&gt;架构是一个软件系统的组织结构，可以递归地分解为多个通过接口相互作用的部件。关系定义接口的连接、约束定义部件的集成。部件包括类、组件、子系统。&lt;/p&gt;
&lt;p&gt;面向对象： 是将系统看作一组相互作用和关联的对象并建模。&lt;/p&gt;
&lt;p&gt;面向对象的特点：系统由相互关联对象组成；通过对象对系统进行描述和建模&lt;/p&gt;</summary>
    
    
    
    <category term="Study" scheme="http://example.com/categories/Study/"/>
    
    
    <category term="Object-oriented Analysis and Design" scheme="http://example.com/tags/Object-oriented-Analysis-and-Design/"/>
    
  </entry>
  
</feed>
