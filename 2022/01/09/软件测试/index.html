<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
    <meta name="keywords" content="Hexo Theme Keep">
    <meta name="description" content="Hexo Theme Keep">
    <meta name="author" content="Hazel Chen">
    
    <title>
        
            Software Test |
        
        Cool Chen&#39;s Blog
    </title>
    
<link rel="stylesheet" href="/css/style.css">

    <link rel="shortcut icon" href="/images/logo.svg">
    
<link rel="stylesheet" href="/css/font-awesome.min.css">

    <script id="hexo-configurations">
    let KEEP = window.KEEP || {};
    KEEP.hexo_config = {"hostname":"example.com","root":"/","language":"zh-CN"};
    KEEP.theme_config = {"toc":{"enable":true,"number":false,"expand_all":false,"init_open":true},"style":{"primary_color":"#0066CC","avatar":"/images/nayeon.jpg","favicon":"/images/logo.svg","article_img_align":"left","left_side_width":"260px","content_max_width":"920px","hover":{"shadow":false,"scale":false},"first_screen":{"enable":true,"background_img":"/images/bg.svg","description":"Welcome to my channel!"},"scroll":{"progress_bar":{"enable":true},"percent":{"enable":true}}},"local_search":{"enable":true,"preload":false},"code_copy":{"enable":true,"style":"default"},"pjax":{"enable":false},"lazyload":{"enable":false},"version":"3.4.5"};
    KEEP.language_ago = {"second":"%s 秒前","minute":"%s 分钟前","hour":"%s 小时前","day":"%s 天前","week":"%s 周前","month":"%s 个月前","year":"%s 年前"};
  </script>
<meta name="generator" content="Hexo 6.3.0"><link rel="alternate" href="/atom.xml" title="Cool Chen's blog" type="application/atom+xml">
</head>


<body>
<div class="progress-bar-container">
    
        <span class="scroll-progress-bar"></span>
    

    
</div>


<main class="page-container">

    

    <div class="page-main-content">

        <div class="page-main-content-top">
            <header class="header-wrapper">

    <div class="header-content">
        <div class="left">
            
            <a class="logo-title" href="/">
                Cool Chen&#39;s Blog
            </a>
        </div>

        <div class="right">
            <div class="pc">
                <ul class="menu-list">
                    
                        <li class="menu-item">
                            <a class=""
                               href="/"
                            >
                                首页
                            </a>
                        </li>
                    
                        <li class="menu-item">
                            <a class=""
                               href="/archives"
                            >
                                归档
                            </a>
                        </li>
                    
                        <li class="menu-item">
                            <a class=""
                               href="/categories"
                            >
                                分类
                            </a>
                        </li>
                    
                        <li class="menu-item">
                            <a class=""
                               href="/tags"
                            >
                                标签
                            </a>
                        </li>
                    
                        <li class="menu-item">
                            <a class=""
                               href="/about"
                            >
                                关于
                            </a>
                        </li>
                    
                    
                        <li class="menu-item search search-popup-trigger">
                            <i class="fas fa-search"></i>
                        </li>
                    
                </ul>
            </div>
            <div class="mobile">
                
                    <div class="icon-item search search-popup-trigger"><i class="fas fa-search"></i></div>
                
                <div class="icon-item menu-bar">
                    <div class="menu-bar-middle"></div>
                </div>
            </div>
        </div>
    </div>

    <div class="header-drawer">
        <ul class="drawer-menu-list">
            
                <li class="drawer-menu-item flex-center">
                    <a class=""
                       href="/">首页</a>
                </li>
            
                <li class="drawer-menu-item flex-center">
                    <a class=""
                       href="/archives">归档</a>
                </li>
            
                <li class="drawer-menu-item flex-center">
                    <a class=""
                       href="/categories">分类</a>
                </li>
            
                <li class="drawer-menu-item flex-center">
                    <a class=""
                       href="/tags">标签</a>
                </li>
            
                <li class="drawer-menu-item flex-center">
                    <a class=""
                       href="/about">关于</a>
                </li>
            
        </ul>
    </div>

    <div class="window-mask"></div>

</header>


        </div>

        <div class="page-main-content-middle">

            <div class="main-content">

                
                    <div class="fade-in-down-animation">
    <div class="article-content-container">

        <div class="article-title">
            <span class="title-hover-animation">Software Test</span>
        </div>

        
            <div class="article-header">
                <div class="avatar">
                    <img src="/images/nayeon.jpg">
                </div>
                <div class="info">
                    <div class="author">
                        <span class="name">Hazel Chen</span>
                        
                            <span class="author-label">Lv3</span>
                        
                    </div>
                    <div class="meta-info">
                        <div class="article-meta-info">
    <span class="article-date article-meta-item">
        <i class="fas fa-edit"></i>&nbsp;
        <span class="pc">2022-01-09 10:14:12</span>
        <span class="mobile">2022-01-09 10:14</span>
    </span>
    
        <span class="article-categories article-meta-item">
            <i class="fas fa-folder"></i>&nbsp;
            <ul>
                
                    <li>
                        <a href="/categories/Study/">Study</a>&nbsp;
                    </li>
                
            </ul>
        </span>
    
    
        <span class="article-tags article-meta-item">
            <i class="fas fa-tags"></i>&nbsp;
            <ul>
                
                    <li>
                        <a href="/tags/Software-Test/">Software Test</a>&nbsp;
                    </li>
                
            </ul>
        </span>
    

    
    
    
        <span class="article-min2read article-meta-item">
            <i class="fas fa-clock"></i>&nbsp;<span>22 分钟</span>
        </span>
    
    
</div>

                    </div>
                </div>
            </div>
        

        <div class="article-content markdown-body">
            <h1 id="软件测试知识点总结"><a href="#软件测试知识点总结" class="headerlink" title="软件测试知识点总结"></a>软件测试知识点总结</h1><p>Not only detect bugs, but also prevent bugs.</p>
<p>软件测试是贯穿整个软件开发生命周期，对软件产品进验证和确认的活动过程，也是对软件产品质量持续的评估过程，其目的是<strong>尽快尽早地发现软件产品中存在的各种缺陷，尽最大可能揭示软件开发过程中所存在的产品质量风险，实现缺陷预防。</strong></p>
<p><strong>静态测试</strong>：不执行被测对象</p>
<p><strong>动态测试</strong>：执行被测对象</p>
<h2 id="软件缺陷定义"><a href="#软件缺陷定义" class="headerlink" title="软件缺陷定义"></a>软件缺陷定义</h2><p>软件缺陷，通常又被叫做bug或者defect，即为软件或程序中存在的某种破坏正常运行能力的问题、错误，其存在会导致软件产品<strong>在某种程度上不能满足用户的需求</strong>。</p>
<p>软件缺陷是指存在于软件（程序、数据、文档中的）那些不符合用户需求的问题。</p>
<span id="more"></span>

<p>1）软件<strong>未实现产品说明书要求的功能</strong></p>
<p>2）软件<strong>出现了产品说明书指明不应该出现的错误</strong></p>
<p>3）软件<strong>实现了产品说明书未提到的功能</strong></p>
<p>4）软件<strong>未实现产品说明书虽未明确提及但应该实现的目标</strong></p>
<p>5）软件难以理解、不易使用、运行缓慢或者从测试员的角度看最终用户会认为不好，即为计算机软件或程序中存在的某种破坏正常运行能力的问题、错误，或者隐藏的功能缺陷</p>
<p>软件缺陷主要分为三种形式：“缺陷”、“故障”、“失效”。</p>
<h2 id="Defect-Fault-and-Failure"><a href="#Defect-Fault-and-Failure" class="headerlink" title="Defect, Fault and Failure"></a>Defect, Fault and Failure</h2><h3 id="软件缺陷-Software-Defect"><a href="#软件缺陷-Software-Defect" class="headerlink" title="软件缺陷(Software Defect)"></a>软件缺陷(Software Defect)</h3><p><strong>Def.</strong> 存在于软件（文档、数据、程序）之中的<strong>那些不希望或不可接受的偏差</strong>。Bug是口语化的缺陷。</p>
<p>如少一个逗号、多一语句等。其结果是软件运行于某一特定条件时出现软件故障，这时称 <a target="_blank" rel="noopener" href="http://baike.baidu.com/view/107502.htm">软件缺陷</a>被激活。</p>
<h3 id="软件故障-Fault"><a href="#软件故障-Fault" class="headerlink" title="软件故障 Fault"></a>软件故障 Fault</h3><p>软件运行过程中出现的一种不希望或不可接受的<strong>内部状态</strong></p>
<p>内部状态：由所有<strong>程序变量的当前值和程序指针</strong>构成</p>
<h3 id="软件失效-Failure"><a href="#软件失效-Failure" class="headerlink" title="软件失效 Failure"></a>软件失效 Failure</h3><p>软件运行时产生的一种不希望或不可接受的<strong>外部行为结果</strong>。 </p>
<p>如：<code>系统崩溃，闪退，结果不正确</code>……</p>
<p>① <strong>外部可见的软件失效</strong>是测试中<strong>推断软件中存在缺陷的基本方法</strong></p>
<p>② <strong>没有失效并不代表软件中不存在缺陷</strong></p>
<blockquote>
<p>软件失效—&gt; 软件缺陷；</p>
<p>软件缺陷 –&#x2F;–&gt; 软件失效</p>
</blockquote>
<p>缺陷具有隐蔽性</p>
<ul>
<li>软件中一定存在缺陷</li>
<li>有缺陷并不一定产生故障；但失效一定能说明有缺陷</li>
<li>有故障也并不一定会失效</li>
</ul>
<h3 id="软件错误-Error"><a href="#软件错误-Error" class="headerlink" title="软件错误 Error"></a>软件错误 Error</h3><ul>
<li>在软件生存期内的<strong>不希望或者不可接受的人为错误</strong></li>
<li>软件缺陷本质上是研发人员在软件研发过程中所犯<strong>错误在软件中的可视化结果</strong></li>
</ul>
<h2 id="RIP-Model-——缺陷被发现的3个必要条件"><a href="#RIP-Model-——缺陷被发现的3个必要条件" class="headerlink" title="RIP Model ——缺陷被发现的3个必要条件"></a>RIP Model ——缺陷被发现的3个必要条件</h2><ol>
<li><p>Reachability可达性</p>
<p>The location or locations in the program that contain the defect must be reached. 执行到包含缺陷的代码</p>
</li>
<li><p>Infection感染性</p>
<p>After executing the location, the state of the program must be incorrect. 在正确和错误代码下运行的内部状态不同</p>
</li>
<li><p>Propagation传播性</p>
<p>The infected state must propagate to cause some output of the program to be incorrect. 输出结果不同</p>
</li>
</ol>
<h1 id="代码单元测试"><a href="#代码单元测试" class="headerlink" title="代码单元测试"></a>代码单元测试</h1><h2 id="逻辑测试"><a href="#逻辑测试" class="headerlink" title="逻辑测试"></a>逻辑测试</h2><p>以代码中逻辑表达式结构为对象的测试，以期发现代码逻辑结构缺陷（不是所有的缺陷类型都可以发现）</p>
<p>逻辑结构缺陷</p>
<ol>
<li>写代码时所犯错误在逻辑表达式上的可视化体现</li>
<li>逻辑表达式写错了，程序行为不正确</li>
</ol>
<h2 id="逻辑覆盖准则"><a href="#逻辑覆盖准则" class="headerlink" title="逻辑覆盖准则"></a>逻辑覆盖准则</h2><ul>
<li><p><code>逻辑表达式</code>是实现代码特性的核心成份</p>
</li>
<li><p>逻辑测试技术：基于逻辑覆盖准则的测试（Logical Coverage Criteria） </p>
</li>
<li><p>满足<code>逻辑覆盖准则 ≠ 高质量测试</code></p>
</li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/8d3e29cb557e4ac1a617c8ad052d417f.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBATHVjaWR-RHJlYW0=,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center" alt="在这里插入图片描述"></p>
<h3 id="语句覆盖（Statement-Coverage）"><a href="#语句覆盖（Statement-Coverage）" class="headerlink" title="语句覆盖（Statement Coverage）"></a>语句覆盖（Statement Coverage）</h3><ul>
<li>衡量被测代码中的<strong>语句得到执行的程度</strong>。</li>
<li>如果测试集合能够使得<strong>被测代码中的每条语句至少被执行一次</strong>，那么则说该测试集合<strong>满足了语句覆盖</strong>。</li>
<li>语句覆盖度 &#x3D; （得到执行的语句数）&#x2F;语句</li>
</ul>
<h3 id="判定覆盖（Decision-Coverage）"><a href="#判定覆盖（Decision-Coverage）" class="headerlink" title="判定覆盖（Decision Coverage）"></a>判定覆盖（Decision Coverage）</h3><ul>
<li>衡量代码中的判定得到执行的程度，期望发现逻辑运算符相关缺陷</li>
<li>如果测试集合能够使得被测代码中的每个判定至少被执行一次,那么则说该测试集合满足了判定覆盖。</li>
<li>注意，每个判定被执行一次的含义是指每个判定的所有可能结果都至少出现一次。 </li>
<li>例 if((num1 &gt;1）&amp;&amp; (num2&#x3D;&#x3D;0))的真假结果都得到执行，才认为该判定被执行。</li>
<li>判定覆盖度 &#x3D;得到执行的判定数&#x2F;判定总数 ∗ 100%</li>
</ul>
<h3 id="条件覆盖（Condition-Coverage）"><a href="#条件覆盖（Condition-Coverage）" class="headerlink" title="条件覆盖（Condition Coverage）"></a>条件覆盖（Condition Coverage）</h3><ul>
<li>衡量代码中构成判定的各个条件得到执行的程度，期望发现算术运算符相关缺陷</li>
<li>如果测试集合能够使得被测代码中的每个条件至少被执行一次, 那么则说该测试集合满足了条件覆盖。</li>
<li>每个条件被执行一次的含义：每个条件的<strong>所有可能结果都至少出现一次</strong></li>
<li>*注意条件覆盖中会出现 <strong>运算符短路</strong>问题！！！，使得条件覆盖无法达到100% &#x3D;&#x3D;&gt; MC&#x2F;DC准则的产生*)</li>
</ul>
<blockquote>
<p>满足判定不一定满足条件，满足条件不一定满足判定</p>
</blockquote>
<h3 id="修正的判定-条件覆盖（Modified-Decision-Condition-Coverage）"><a href="#修正的判定-条件覆盖（Modified-Decision-Condition-Coverage）" class="headerlink" title="修正的判定-条件覆盖（Modified Decision-Condition Coverage）"></a>修正的判定-条件覆盖（Modified Decision-Condition Coverage）</h3><p>判定-条件覆盖存在的问题</p>
<p>• 对于某些满足判定-条件覆盖的测试集合而言，其揭错能力并不高</p>
<p>• 短路运算符</p>
<ul>
<li><p>期望构成每个判定的每个条件能独立地影响整个判定的结果。</p>
</li>
<li><p>在这里独立地影响整个判定的结果是指在其它条件取值不变的情况下，<strong>只改变当前条件的取值就能使得整个判定的结果发生变化。</strong></p>
</li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/c254023b01bb4f538b6fd499925ae5e6.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBATHVjaWR-RHJlYW0=,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center" alt="在这里插入图片描述"></p>
<h2 id="基于控制流的测试"><a href="#基于控制流的测试" class="headerlink" title="基于控制流的测试"></a>基于控制流的测试</h2><h3 id="Prime-Path-Testing"><a href="#Prime-Path-Testing" class="headerlink" title="Prime Path Testing"></a>Prime Path Testing</h3><ol>
<li>Constructing Control Flow Graph (CFG)</li>
<li>Calculating Prime Path set</li>
<li>Deriving Test Case</li>
</ol>
<h3 id="Control-Flow-Graph"><a href="#Control-Flow-Graph" class="headerlink" title="Control Flow Graph"></a>Control Flow Graph</h3><p>A CFG models all executions of a method by describing control structures</p>
<ul>
<li><p>Nodes : Statements or sequences of statements (basic blocks)</p>
<ul>
<li><strong>Basic Block</strong> : A sequence of statements such that if <u>the first statement is executed, all statements will be</u></li>
</ul>
</li>
<li><p>Edges : Transfers of control</p>
</li>
</ul>
<p><strong>Paths in Graph:</strong> Path is a sequence of nodes(n1, n2, …, nm). A subpath of a path p is a subsequence of p.</p>
<p><strong>Simple path:</strong> A path from node ni to nj is simple if no node appears more than once, except possibly the first and last nodes are the same. (除起始节点和结束节点可以相同外，路径中每个节点的出现次数有且仅有 1 次。)</p>
<p><strong>Prime Path:</strong> A simple path that does not appear as a proper subpath of any other simple path. (不是其他简单路径的子路径的简单路径)</p>
<p><strong>Complete Path:</strong> A path that s<strong>tarts at an initial node</strong> and <strong>ends at a final node</strong></p>
<h3 id="Calculating-Prime-Path-Set-–-Node-Tree-Method"><a href="#Calculating-Prime-Path-Set-–-Node-Tree-Method" class="headerlink" title="Calculating Prime Path Set – Node Tree Method"></a>Calculating Prime Path Set – Node Tree Method</h3><p><strong>节点树</strong></p>
<ul>
<li>以G中的节点为根节点建立的树，且满足<strong>树中除根节点和叶节点可以相同外，从根节点到每个树中节点的路径中，每个节点的出现次数有且仅有 1 次。</strong></li>
<li>在节点树中，每条从根节点到叶节点的路径即为一条简单路径。</li>
</ul>
<p><strong>简单节点树</strong></p>
<ul>
<li>若<strong>节点树T不是任何其它节点树的子树</strong>，则称节点树T为简单节点树。</li>
<li><strong>所有简单节点树的从根节点到叶节点的路径集合为备选的基路径集合</strong>。</li>
</ul>
<h2 id="基于数据流的测试"><a href="#基于数据流的测试" class="headerlink" title="基于数据流的测试"></a>基于数据流的测试</h2><h3 id="Def-amp-Use"><a href="#Def-amp-Use" class="headerlink" title="Def &amp; Use"></a>Def &amp; Use</h3><p><strong>c-use (computation-use)</strong></p>
<ul>
<li>使用节点USE(v,n)是一个计算使用(记做C-use)，当且仅当语句n是计算语句 （对于计算使用的节点永远有外度&#x3D;1）</li>
</ul>
<p><strong>p-use (predicate-use)</strong></p>
<ul>
<li>使用节点是一个谓词使用（记做p－use），当且仅当语句n是谓词语句（对于谓词使用的节点永远有外度≥2）</li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/48a1d21b8e544d37930d7d6a15d238a9.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBATHVjaWR-RHJlYW0=,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center" alt="在这里插入图片描述"><br>上图的解释为：由于采用的是<strong>值传</strong>（ 值传采用<u>将实参值复制一份给形参的方式传递变量值，并没有将一个值放入与实参关联的内存</u>（指的是右侧的str不是左侧的str））的函数调用形式，因此，有下面的结论：str的定义节点为：12，13；str的使用节点为：13，14，15；p的定义节点为：6，7；使用节点：8 ，其中，对于节点6而言， p是形参，p的存储单元内容是一个地址值，代码会将str（str也是一个指针）的值复制到p的存储单元，因此，是p的定义。<br><img src="https://img-blog.csdnimg.cn/f72830f7af7648d499e1d6773025dbda.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBATHVjaWR-RHJlYW0=,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center" alt="在这里插入图片描述"><br>上图的解释为：由于采用的是<strong>传指针的调用形式</strong>，因此，有下面的结论：str的定义节点为：11，12（虽然没有显示的赋值， 对于<code>传递指针认为实参既有定义又有使用</code>，且是先使用后定义）；str的使用节点为：12，13，14；p的定义节点为：6；使用节点：7； </p>
<blockquote>
<p>注：指针传参是<strong>先使用再定义</strong></p>
</blockquote>
<h3 id="Du-pair-amp-Du-path"><a href="#Du-pair-amp-Du-path" class="headerlink" title="Du-pair &amp; Du path"></a>Du-pair &amp; Du path</h3><p><strong>定义-使用对（du pair）:</strong> 对于变量 v 而言，若 li是 v 的定义节点，lj是 v 的使用节点，那么由位置 li 和 lj构成的二元组(li, lj)，称为 v 的<strong>定义-使用对。</strong></p>
<p><strong>定义清除（def-clear）:</strong> 对于 v 的<code>定义-使用对(li, lj)</code>而言（注意一定是定义-使用对，即起始节点一定是定义节点，终点一定是使用节点），如果<code>以 li为起始点，以 li为终止点</code>的路径(li, lk1, lk2 ,lk3,……, lkn,lj)中，<strong>不包含 v 的定义节点</strong>，则称路径(li, lk1, lk2 ,lk3,……, lkn,lj)是定义清除的。(只有起始点为变量v的定义节点)</p>
<p><strong>定义-使用路径（du-path）：</strong>对于变量 v 而言，从 v 的定义节点到 v 的使用节点的<strong>定义清除的简单路径</strong>称为 v 的定义-使用路径。</p>
<ul>
<li>du(ni, nj, v) – 变量v的以ni为开始节点，以nj为结束节点的<strong>定义使用对路径集合</strong>。</li>
<li>du (ni, <em>v</em>) 表示变量 v 的以ni为定义节点（以ni为起始节点）的所有<strong>定义使用</strong>路径集合</li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/999e0fbdbce34ef387ec7ad222b3963f.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBATHVjaWR-RHJlYW0=,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center" alt="在这里插入图片描述"></p>
<h3 id="Data-Flow-Test-Criteria"><a href="#Data-Flow-Test-Criteria" class="headerlink" title="Data Flow Test Criteria"></a>Data Flow Test Criteria</h3><ol>
<li>全定义覆盖（All-defs coverage, ADC）: 对于每个变量 v 而言，测试路径需要访问 v 的每一个<strong>定义使用</strong>路径集合 du (ni, v),的某条定义使用路径<ol>
<li><code>every def reaches a use</code></li>
</ol>
</li>
<li>全使用覆盖（All-uses coverage, AUC）：对于每个变量 v 而言，测试路径需要访问 v 的每一个<strong>定义使用对</strong>路径集合 du (ni, nj, v)的某条定义使用路径<ol>
<li><code>every def reaches all possible uses</code></li>
</ol>
</li>
<li>全定义-使用覆盖 （All-du-paths coverage, ADUPC）：对于每个变量 v 而言，测试路径需要访问 v 的每一个<strong>定义使用对</strong>路径集合 du (ni, nj, v)的每一条定义使用路径<ol>
<li><code>cover all the paths between defs and uses</code></li>
</ol>
</li>
</ol>
<h2 id="变异测试"><a href="#变异测试" class="headerlink" title="变异测试"></a>变异测试</h2><h3 id="变异得分"><a href="#变异得分" class="headerlink" title="变异得分"></a>变异得分</h3><p>MS(T) &#x3D; |D|&#x2F;(|L|+|D|)</p>
<ul>
<li>|D|: the number of killed mutants </li>
<li>|L| : the number of lived mutants</li>
</ul>
<p><strong>Mutant</strong></p>
<ul>
<li>Live mutant: The mutant that has the same results as that of P against <strong>all test cases</strong> of T, denoted as L 在给定的用例下，变异体与源程序有一样的结果</li>
<li>Killed mutant : The mutant that has different result to P against at least one test case of T, denoted as D 有一个用例使得变异体与源程序的结果不同</li>
<li>Equivalent mutant: The mutant that has the same results as that of P against all input domain, denoted as E 特别注意的是等价变异体，在所有输入域下结果都与源程序一样，与源程序等价</li>
</ul>
<h3 id="基于变异测试的覆盖"><a href="#基于变异测试的覆盖" class="headerlink" title="基于变异测试的覆盖"></a>基于变异测试的覆盖</h3><ul>
<li>变异覆盖：所设计的用例能够杀死变异体</li>
<li>Strongly Killing Mutants: 满足RIP三条原则。</li>
<li>Weakly Killing Mutants: 满足可达性和可感染性。</li>
</ul>
<h1 id="代码接口测试-–-集成测试"><a href="#代码接口测试-–-集成测试" class="headerlink" title="代码接口测试 – 集成测试"></a>代码接口测试 – 集成测试</h1><p><strong>Def.</strong> 将通过单元测试的代码单元逐渐集成在一起直至整个软件系统，以验证<strong>单元之间的接口交互是否满足需求</strong></p>
<h2 id="集成测试用例生成"><a href="#集成测试用例生成" class="headerlink" title="集成测试用例生成"></a>集成测试用例生成</h2><h3 id="MM-Path-CFG-Based"><a href="#MM-Path-CFG-Based" class="headerlink" title="MM-Path(CFG Based)"></a>MM-Path(CFG Based)</h3><p>定义<strong>单元之间的控制转移路径</strong></p>
<p>节点：模块执行路径(Module Execution Path, MEP)</p>
<p>节点之间的关系：基于调用的控制转移</p>
<p>源节点</p>
<ul>
<li>程序执行开始时或重新开始处的语句片断。</li>
<li>可能是单元中的<strong>第一个可执行语句</strong>或者是<strong>紧接着转移控制到其它单元节点之后的节点</strong>。</li>
</ul>
<p>汇节点</p>
<ul>
<li>程序执结束处的语句片断。</li>
<li>可能是单元中的<strong>最后一个可执行语句</strong>或者<strong>转移控制到其它单元的节点</strong>。</li>
</ul>
<p>模块执行路径（MEP）：**<code>源节点开始，汇节点结束的语句序列，中间没有汇节点</code>**。通常先找到每个源节点和汇节点，再写出MEP。</p>
<p><img src="https://img-blog.csdnimg.cn/f87eba6c53c64537b3d773d0d63ec1db.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBATHVjaWR-RHJlYW0=,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center" alt="在这里插入图片描述"><br>消息：一种程序设计语言机制，通过这种机制一个单元将控制</p>
<p>转移给另一个单元。MM-Path<strong>最低</strong>要求<strong>所有消息均被覆盖至少一次</strong></p>
<p>MM-Path：</p>
<ul>
<li>模块执行路径和消息的序列</li>
<li>描述包含在单独单元之间控制转移的模块执行路径序列</li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/de0037dd6827425daa1abda1b0fec242.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBATHVjaWR-RHJlYW0=,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center" alt="在这里插入图片描述"></p>
<h3 id="Coupling-du-path-DFG-Based"><a href="#Coupling-du-path-DFG-Based" class="headerlink" title="Coupling du-path(DFG Based)"></a>Coupling du-path(DFG Based)</h3><p><strong>Coupling variable 耦合变量(x,y)：</strong> 形参&#x2F;实参，非局部变量&#x2F;全局变量</p>
<p><strong>Last def 最后定义节点：</strong>变量x满足-从该定义节点开始存在<strong>经过调用点(callsite&#x2F;return)<strong>到达</strong>另一个代码单元的使用</strong>的<strong>定义清除路径</strong>。</p>
<p><strong>Use clear 使用清除：</strong> 对于变量 v 而言，一条从节点 ni到 nj的路径 p是使用清除的如果满足路径 p 中不存在 v 的使用节点.</p>
<p><strong>First use 首次使用节点：</strong>变量使用中–满足<strong>从调用点(entry&#x2F;return)到达该使用节点的路径</strong>是一条<strong>定义清除和使用清除路径</strong>。</p>
<h4 id="Coupling-du-Pair-耦合定义使用对"><a href="#Coupling-du-Pair-耦合定义使用对" class="headerlink" title="Coupling du Pair 耦合定义使用对"></a>Coupling du Pair 耦合定义使用对</h4><p>For coupling variable (x, y), its coupling du pair is denoted as <code>(A, x, li)-(B, y, lj)</code>,where <code>li the last definition location for variable x in unit A</code> and <code>lj is the first use location in the unit B</code>. </p>
<p>计算A &amp; B的耦合定义使用对：</p>
<ol>
<li>首先找到A &amp; B的耦合变量（对）</li>
<li>根据DFG找到耦合变量的最后定义 和 首次使用（可以是点、也可以是边）</li>
<li>耦合的定义使用对</li>
</ol>
<h3 id="Coupling-Du-Coverage-Criteria"><a href="#Coupling-Du-Coverage-Criteria" class="headerlink" title="Coupling Du Coverage Criteria"></a>Coupling Du Coverage Criteria</h3><p>A coupling du-path is a simple path from a last-def to a first-use which is consists of </p>
<ol>
<li>The def-clear simple path from last-def to callsite&#x2F;return</li>
<li>The def-clear and use-clear simple path from entry&#x2F; return from to the first-use</li>
</ol>
<blockquote>
<p>耦合定义使用路径中，</p>
<p>1）对于从caller到callee方向而言，从callee的入口点（entry&#x2F;callsite）到耦合变量第一次使用的路径要求是定义清除且使用清除的；</p>
<p>2）对于从callee返回caller的方向，在caller接收返回值点（return）到第一次使用的路径是定义清除且使用清除的综合起来，就是enty&#x2F;return</p>
</blockquote>
<ol>
<li>All-Coupling-Def coverage: <strong>every last def</strong> to <strong>at least one first use</strong> 全耦合定义覆盖：对于每个变量 v 而言，测试路径需要访问 v 的<strong>每一个最后定义</strong>和<strong>某个该定义的首次使用</strong>构成的路径。</li>
<li>All-Coupling-use Coverage: <strong>every last def</strong> to <strong>every first use ** 全耦合使用覆盖：对于每个变量 v 而言，测试路径需要访问 v 的</strong>每一个最后定义<strong>和</strong>所有该定义的首次使用**构成的路径。</li>
<li>All-Coupling-du-Paths Coverage: <strong>every simple path from every last def to every first use</strong> 全耦合定义使用覆盖：对于每个变量 v 而言，测试路径需要访问 v 的每一个最后定义和所有该定义的首次使用构成的<strong>所有简单路径</strong>。</li>
</ol>
<p><strong>系统测试</strong>是测试级别最高的一种测试活动，是将<u>已经集成好的软件系统，作为整个基于计算机系统的一个元素</u>，与计算机硬件、外设、某些支持软件、数据和人员等其它系统元素结合在一起， 在实际运行（使用）环境下，对计算机系统进行一系列的组装测试和确认测试。</p>
<p>系统测试的对象<strong>不仅包括软件，还包括系统软件所依赖的硬件、外部设备和各类接口</strong>，其目的在于通过与系统的需求定义作比较，发现软件与系统定义不符合或与之矛盾的地方以及系统各个部分是否可以协调工作。</p>
<p>系统测试分为两大类别</p>
<ul>
<li>功能测试</li>
<li>非功能测试</li>
</ul>
<p>这里只对功能测试进行整理。</p>
<h1 id="系统功能测试"><a href="#系统功能测试" class="headerlink" title="系统功能测试"></a>系统功能测试</h1><h2 id="系统测试用例设计方法"><a href="#系统测试用例设计方法" class="headerlink" title="系统测试用例设计方法"></a>系统测试用例设计方法</h2><h3 id="输入域划分-–-基于等价类思想"><a href="#输入域划分-–-基于等价类思想" class="headerlink" title="输入域划分 – 基于等价类思想"></a>输入域划分 – 基于等价类思想</h3><p><strong>输入域：</strong>待测对象<strong>所有可能输入的集合</strong>，无限性，笛卡尔积，无法穷举。</p>
<p>Partition Domains: A partition must  satisfy two properties</p>
<ol>
<li>Cover the entire domain (completeness,<strong>完备性</strong>) 划分块并集为定义域</li>
<li>The blocks must not overlap (disjoint,<strong>独特性</strong>) 划分块不相交</li>
</ol>
<p><strong>输入域建模：</strong> 划分输入参数的定义域。每个划分只取一个结果。</p>
<ol>
<li>Identify parameters(待测因素) under test: inputs,  semantic descriptions </li>
<li>Find characteristics (待测特征)in the parameters under test : Example Characteristics<ol>
<li>Input X is null 是否为空</li>
<li>Order of the input file F (sorted, inverse sorted,arbitrary, …) 文件顺序</li>
<li>Min separation of two aircraft</li>
<li>Input device (DVD, CD, VCR, computer, …)</li>
</ol>
</li>
<li>Partition each characteristic (Each partition is usually based on some characteristic C)</li>
</ol>
<p>识别<strong>待测因素</strong>（不仅限于输入参数和输出结果）与<strong>待测特征</strong>（待测因素的进一步描述，如业务规则、是否为空、文件规模等）</p>
<p>Strategies for identifying values :</p>
<ol>
<li><p>valid, invalid and special values 有效值、无效值、特殊值</p>
</li>
<li><p>Sub-partition some blocks</p>
</li>
<li><p>Explore boundaries of domains 边界值</p>
<p>若输入域是数值区间(a,b): 需要包含介于a, b之间的正常情况，a，b，比a稍微小，比a稍微大一点，比b稍微小一点，比b稍微大一点（7种情况）</p>
</li>
</ol>
<p><strong>输入域（划分块）组合策略：</strong></p>
<p>组合待测特征、输入域划分结果。</p>
<h4 id="全组合覆盖-All-Combination-Coverage-ACoC"><a href="#全组合覆盖-All-Combination-Coverage-ACoC" class="headerlink" title="全组合覆盖 All Combination Coverage(ACoC):"></a>全组合覆盖 All Combination Coverage(ACoC):</h4><p>划分块枚举。每个待测特征输入域划分结果的笛卡尔积。</p>
<p>[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-q6FENFWD-1641542515803)(D:\Grade3-1\非关系型数据库\Screenshots\QQ截图20220105092921.png)]</p>
<p>Q:待测特征个数  Bi: 第i个待测特征对应的输入域划分集合</p>
<h4 id="单值覆盖-Each-Choice-Coverage-ECC"><a href="#单值覆盖-Each-Choice-Coverage-ECC" class="headerlink" title="单值覆盖 Each Choice Coverage(ECC)"></a>单值覆盖 Each Choice Coverage(ECC)</h4><p>每个待测特征的每个划分块被测试一次；每个划分块出现一次即可。各个待测特征输入域划分数量的最大值。</p>
<p><img src="https://img-blog.csdnimg.cn/cf5467e035e34f29b5f5101d160d59f1.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBATHVjaWR-RHJlYW0=,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center" alt="在这里插入图片描述"></p>
<h4 id="全对偶覆盖-Pair-Wise-Coverage-PWC"><a href="#全对偶覆盖-Pair-Wise-Coverage-PWC" class="headerlink" title="全对偶覆盖 Pair-Wise Coverage(PWC)"></a>全对偶覆盖 Pair-Wise Coverage(PWC)</h4><p>两两不同待测特征输入域元素之间的对关系。是最简单、高效的策略。</p>
<p><img src="https://img-blog.csdnimg.cn/d3a64a1dab544b33bd2f5830df2bcbc9.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBATHVjaWR-RHJlYW0=,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center" alt="在这里插入图片描述"><br>测试用例数至少为：输入域数量最多的那两个待测特征</p>
<p>如何计算全对偶覆盖 &amp; 设计用例？</p>
<p>&#x3D;&#x3D;&gt; 使<strong>每个对偶值</strong>在某个测试用例中至少出现一次</p>
<ol>
<li>列数是被测特征个数。在列上标出特征名称，按可能取值的数量降序排列变量。</li>
<li>行数计算方法如下：如果第一列的可能取值个数是V1，第二列的可能取值个数是V2，表中的行数至少为 V1*V2（也就是说至少有V1 * V2个测试用例)。</li>
<li>第一列的填写规则：每次重复第一列特征的各个取值V2次。约定第一个特征的相同取值构成一个段。（最好在各个段空出一行，再重复给出下一个取值）</li>
<li>第二列的填写规则：对于第一个特征的每个段列出第二个特征的所有取值</li>
<li>增加第三列，使得每个段要包含第三列特征的所有取值并且这些取值的顺序要<strong>使第三列特征和第二列特征也构成全对偶</strong></li>
<li>依次增加第四列、第五列方法同步骤3，检查各特征之间是否构成全对偶，直至所有特征列完为止</li>
</ol>
<h4 id="全T值覆盖-T-Wise-Coverage-TWC"><a href="#全T值覆盖-T-Wise-Coverage-TWC" class="headerlink" title="全T值覆盖 T-Wise Coverage(TWC)"></a>全T值覆盖 T-Wise Coverage(TWC)</h4><p>全对偶覆盖的拓展。需覆盖到t个待测特征之间的关系。</p>
<h4 id="基本值覆盖-Base-Choice-Coverage-BCC"><a href="#基本值覆盖-Base-Choice-Coverage-BCC" class="headerlink" title="基本值覆盖 Base Choice Coverage(BCC)"></a>基本值覆盖 Base Choice Coverage(BCC)</h4><p>基本值：某个待测特征所有输入域划分取值中，使用频率最高的那个取值。（变量取最常用的正常值）</p>
<p><img src="https://img-blog.csdnimg.cn/b2b7bd5d4bd84be9a2b9367fa44a239e.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBATHVjaWR-RHJlYW0=,size_17,color_FFFFFF,t_70,g_se,x_16#pic_center" alt="在这里插入图片描述"><br>第一行：所有待测特征取基本值。</p>
<p>其余行分别对每个待测特征取非基本值(Bi-1)。 因此:<br>$$<br>\sum_{i&#x3D;1}^{Q}(B_i - 1)<br>$$</p>
<h4 id="多基本值覆盖-Multiple-Base-Choice-Coverage-MBCC"><a href="#多基本值覆盖-Multiple-Base-Choice-Coverage-MBCC" class="headerlink" title="多基本值覆盖 Multiple-Base Choice Coverage(MBCC)"></a>多基本值覆盖 Multiple-Base Choice Coverage(MBCC)</h4><p>如果待测特征有多个基本值（常用值），那么就要覆盖到所有基本值，其余仍然是对每个待测特征取非基本值。</p>
<h2 id="系统测试用例生成"><a href="#系统测试用例生成" class="headerlink" title="系统测试用例生成"></a>系统测试用例生成</h2><p>测试用例设计的自动化是软件测试发展的必然方向，不管是单元测试、交互测试、系统测试层面，还是安全测试、性能测试层面，都需要测试用例设计的自动化，为了缩短测试周期、降低测试成本、提高测试质量。</p>
<p><img src="https://img-blog.csdnimg.cn/3cd676a05b9746bba4a9926c2ceccace.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBATHVjaWR-RHJlYW0=,size_10,color_FFFFFF,t_70,g_se,x_16#pic_center" alt="在这里插入图片描述"><br>用自动机建模系统的行为 —— 有限状态自动机 FSM</p>
<p>W method：用于给定一个FSM作为输入，可以求出能揭错该FSM的所有输入序列.</p>
<p>W方法意图揭示的4种缺陷：</p>
<ol>
<li>Operation error 执行缺陷</li>
<li>Transfer error 控制错误</li>
<li>Extra state Error 额外状态错误</li>
<li>Missing state Error缺失状态错误</li>
</ol>
<h3 id="FSM-Definition"><a href="#FSM-Definition" class="headerlink" title="FSM Definition"></a>FSM Definition</h3><p>FSM: (X, Y, Q, q0, g, O)</p>
<p><img src="https://img-blog.csdnimg.cn/f707021a21b24a97a49b52f4cdc21f9d.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBATHVjaWR-RHJlYW0=,size_19,color_FFFFFF,t_70,g_se,x_16#pic_center" alt="在这里插入图片描述"></p>
<ul>
<li>The FSM of the specification is denoted as <em>M</em> </li>
<li>M is completely <strong>specified, minimal, connected and deterministic</strong></li>
<li><em>M</em> starts in a fixed initial state</li>
<li><em>M</em> can be reset accurately to the initial state</li>
<li>M and IUT (Implementation Under Test 待测代码的输入)have the same input alphabet</li>
</ul>
<h4 id="FSM-Properties"><a href="#FSM-Properties" class="headerlink" title="FSM Properties"></a>FSM Properties</h4><p><strong>Completely specified：</strong> 完备性，每个状态对每个输入都要对应的迁移</p>
<p><strong>Strongly connected：</strong> 连通性，每一对状态(qi,qj)存在输入序列，使得qi —&gt; qj</p>
<p><strong>Minimal：</strong> 最小性</p>
<ul>
<li>k-equivalence: 对长度为k的输入，状态qi(Q1)和状态qj的输出相同</li>
<li>Machine equivalence: 对M1中任意的状态，在M2中能找到状态与之等价。对M2中任意的状态，在M1中能找到状态与之等价。</li>
<li>Minimal machine:状态机M的状态数是与之等价的状态机中最小的</li>
</ul>
<h3 id="Chow’s-W-Method"><a href="#Chow’s-W-Method" class="headerlink" title="Chow’s W Method"></a>Chow’s W Method</h3><ol>
<li><p>Estimate the maximum number of states (m) in the correct implementation of the given FSM <em>M</em>. </p>
<ol>
<li>This is based on a knowledge of the implementation. In the absence of any such knowledge, let m&#x3D;|Q|.</li>
</ol>
</li>
<li><p>Construct the characterization set <strong>W</strong> for <em>M</em>. 建立缺陷的特征集合W.</p>
<ol>
<li>将状态集合Q进行k等价划分(P0–&gt;Pk)</li>
<li>对Q中每个状态，根据k等价逆序<strong>计算能够区分各个状态的特征输入</strong>（直至到0等价划分算法终止）</li>
<li>区分每对状态的输入序列 的 并集</li>
</ol>
</li>
<li><p>Construct the testing tree for M. 构造M的测试树（保证可达性和感染性）<br><img src="https://img-blog.csdnimg.cn/63615533abff43f58aec44bb2a1479f2.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBATHVjaWR-RHJlYW0=,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center" alt="在这里插入图片描述"></p>
</li>
<li><p>Generate the transition cover set P from the testing tree. 计算迁移覆盖集合P</p>
<p>A patial path is a path starting from the root of the testing tree and terminating in any node of the tree</p>
<p>Concatenation of the labels along the edges of a sub-path is a string that belongs to P.  The empty string () also belongs to P</p>
<p>注：记得加空串</p>
</li>
<li><p>Construct set Z from W and m. 计算输入集合Z</p>
</li>
</ol>
<p><img src="https://img-blog.csdnimg.cn/48374445d5fc42dda1e7a9f105b8f907.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBATHVjaWR-RHJlYW0=,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center" alt="在这里插入图片描述"><br>6. Desired test set T&#x3D;P.Z 最后计算测试输入 &#x3D; P.Z（迁移覆盖集合P&amp;输入集合Z笛卡尔积）</p>

        </div>

        

        
            <ul class="post-tags-box">
                
                    <li class="tag-item">
                        <a href="/tags/Software-Test/">#Software Test</a>&nbsp;
                    </li>
                
            </ul>
        

        
            <div class="article-nav">
                
                    <div class="article-prev">
                        <a class="prev"
                           rel="prev"
                           href="/2022/03/01/Github%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98%E4%B8%8E%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95/"
                        >
                            <span class="left arrow-icon flex-center">
                              <i class="fas fa-chevron-left"></i>
                            </span>
                            <span class="title flex-center">
                                <span class="post-nav-title-item">Github常见问题与解决方法</span>
                                <span class="post-nav-item">上一篇</span>
                            </span>
                        </a>
                    </div>
                
                
                    <div class="article-next">
                        <a class="next"
                           rel="next"
                           href="/2022/01/06/OOAD%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/"
                        >
                            <span class="title flex-center">
                                <span class="post-nav-title-item">OOAD Summary</span>
                                <span class="post-nav-item">下一篇</span>
                            </span>
                            <span class="right arrow-icon flex-center">
                              <i class="fas fa-chevron-right"></i>
                            </span>
                        </a>
                    </div>
                
            </div>
        

        
    </div>
</div>


                
            </div>

        </div>

        <div class="page-main-content-bottom">
            <footer class="footer">
    <div class="info-container">
        <div class="copyright-info info-item">
            &copy;
            
              <span>2020</span>
              -
            
            2023&nbsp;<i class="fas fa-heart icon-animate"></i>&nbsp;<a href="/">Hazel Chen</a>
        </div>
        
            <script async  src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
            <div class="website-count info-item">
                
                    <span id="busuanzi_container_site_uv">
                        访问人数&nbsp;<span id="busuanzi_value_site_uv"></span>&ensp;
                    </span>
                
                
                    <span id="busuanzi_container_site_pv">
                        总访问量&nbsp;<span id="busuanzi_value_site_pv"></span>
                    </span>
                
            </div>
        
        <div class="theme-info info-item">
            由 <a target="_blank" href="https://hexo.io">Hexo</a> 驱动&nbsp;|&nbsp;主题&nbsp;<a class="theme-version" target="_blank" href="https://github.com/XPoet/hexo-theme-keep">Keep v3.4.5</a>
        </div>
        
        
    </div>
</footer>

        </div>
    </div>

    
        <div class="post-tools">
            <div class="post-tools-container">
    <ul class="tools-list">
        <!-- TOC aside toggle -->
        
            <li class="tools-item page-aside-toggle">
                <i class="fas fa-outdent"></i>
            </li>
        

        <!-- go comment -->
        
    </ul>
</div>

        </div>
    

    <div class="right-bottom-side-tools">
        <div class="side-tools-container">
    <ul class="side-tools-list">
        <li class="tools-item tool-font-adjust-plus flex-center">
            <i class="fas fa-search-plus"></i>
        </li>

        <li class="tools-item tool-font-adjust-minus flex-center">
            <i class="fas fa-search-minus"></i>
        </li>

        <li class="tools-item tool-expand-width flex-center">
            <i class="fas fa-arrows-alt-h"></i>
        </li>

        <li class="tools-item tool-dark-light-toggle flex-center">
            <i class="fas fa-moon"></i>
        </li>

        <!-- rss -->
        

        

        <li class="tools-item tool-scroll-to-bottom flex-center">
            <i class="fas fa-arrow-down"></i>
        </li>
    </ul>

    <ul class="exposed-tools-list">
        <li class="tools-item tool-toggle-show flex-center">
            <i class="fas fa-cog fa-spin"></i>
        </li>
        
            <li class="tools-item tool-scroll-to-top flex-center">
                <i class="arrow-up fas fa-arrow-up"></i>
                <span class="percent"></span>
            </li>
        
    </ul>
</div>

    </div>

    
        <aside class="page-aside">
            <div class="post-toc-wrap">
    <div class="post-toc">
        <ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93"><span class="nav-text">软件测试知识点总结</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%BD%AF%E4%BB%B6%E7%BC%BA%E9%99%B7%E5%AE%9A%E4%B9%89"><span class="nav-text">软件缺陷定义</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Defect-Fault-and-Failure"><span class="nav-text">Defect, Fault and Failure</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BD%AF%E4%BB%B6%E7%BC%BA%E9%99%B7-Software-Defect"><span class="nav-text">软件缺陷(Software Defect)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BD%AF%E4%BB%B6%E6%95%85%E9%9A%9C-Fault"><span class="nav-text">软件故障 Fault</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BD%AF%E4%BB%B6%E5%A4%B1%E6%95%88-Failure"><span class="nav-text">软件失效 Failure</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BD%AF%E4%BB%B6%E9%94%99%E8%AF%AF-Error"><span class="nav-text">软件错误 Error</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#RIP-Model-%E2%80%94%E2%80%94%E7%BC%BA%E9%99%B7%E8%A2%AB%E5%8F%91%E7%8E%B0%E7%9A%843%E4%B8%AA%E5%BF%85%E8%A6%81%E6%9D%A1%E4%BB%B6"><span class="nav-text">RIP Model ——缺陷被发现的3个必要条件</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%BB%A3%E7%A0%81%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95"><span class="nav-text">代码单元测试</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%80%BB%E8%BE%91%E6%B5%8B%E8%AF%95"><span class="nav-text">逻辑测试</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%80%BB%E8%BE%91%E8%A6%86%E7%9B%96%E5%87%86%E5%88%99"><span class="nav-text">逻辑覆盖准则</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%AF%AD%E5%8F%A5%E8%A6%86%E7%9B%96%EF%BC%88Statement-Coverage%EF%BC%89"><span class="nav-text">语句覆盖（Statement Coverage）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%A4%E5%AE%9A%E8%A6%86%E7%9B%96%EF%BC%88Decision-Coverage%EF%BC%89"><span class="nav-text">判定覆盖（Decision Coverage）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9D%A1%E4%BB%B6%E8%A6%86%E7%9B%96%EF%BC%88Condition-Coverage%EF%BC%89"><span class="nav-text">条件覆盖（Condition Coverage）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BF%AE%E6%AD%A3%E7%9A%84%E5%88%A4%E5%AE%9A-%E6%9D%A1%E4%BB%B6%E8%A6%86%E7%9B%96%EF%BC%88Modified-Decision-Condition-Coverage%EF%BC%89"><span class="nav-text">修正的判定-条件覆盖（Modified Decision-Condition Coverage）</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%9F%BA%E4%BA%8E%E6%8E%A7%E5%88%B6%E6%B5%81%E7%9A%84%E6%B5%8B%E8%AF%95"><span class="nav-text">基于控制流的测试</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Prime-Path-Testing"><span class="nav-text">Prime Path Testing</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Control-Flow-Graph"><span class="nav-text">Control Flow Graph</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Calculating-Prime-Path-Set-%E2%80%93-Node-Tree-Method"><span class="nav-text">Calculating Prime Path Set – Node Tree Method</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%9F%BA%E4%BA%8E%E6%95%B0%E6%8D%AE%E6%B5%81%E7%9A%84%E6%B5%8B%E8%AF%95"><span class="nav-text">基于数据流的测试</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Def-amp-Use"><span class="nav-text">Def &amp; Use</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Du-pair-amp-Du-path"><span class="nav-text">Du-pair &amp; Du path</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Data-Flow-Test-Criteria"><span class="nav-text">Data Flow Test Criteria</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8F%98%E5%BC%82%E6%B5%8B%E8%AF%95"><span class="nav-text">变异测试</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8F%98%E5%BC%82%E5%BE%97%E5%88%86"><span class="nav-text">变异得分</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9F%BA%E4%BA%8E%E5%8F%98%E5%BC%82%E6%B5%8B%E8%AF%95%E7%9A%84%E8%A6%86%E7%9B%96"><span class="nav-text">基于变异测试的覆盖</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%BB%A3%E7%A0%81%E6%8E%A5%E5%8F%A3%E6%B5%8B%E8%AF%95-%E2%80%93-%E9%9B%86%E6%88%90%E6%B5%8B%E8%AF%95"><span class="nav-text">代码接口测试 – 集成测试</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%9B%86%E6%88%90%E6%B5%8B%E8%AF%95%E7%94%A8%E4%BE%8B%E7%94%9F%E6%88%90"><span class="nav-text">集成测试用例生成</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#MM-Path-CFG-Based"><span class="nav-text">MM-Path(CFG Based)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Coupling-du-path-DFG-Based"><span class="nav-text">Coupling du-path(DFG Based)</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Coupling-du-Pair-%E8%80%A6%E5%90%88%E5%AE%9A%E4%B9%89%E4%BD%BF%E7%94%A8%E5%AF%B9"><span class="nav-text">Coupling du Pair 耦合定义使用对</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Coupling-Du-Coverage-Criteria"><span class="nav-text">Coupling Du Coverage Criteria</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%B3%BB%E7%BB%9F%E5%8A%9F%E8%83%BD%E6%B5%8B%E8%AF%95"><span class="nav-text">系统功能测试</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%B3%BB%E7%BB%9F%E6%B5%8B%E8%AF%95%E7%94%A8%E4%BE%8B%E8%AE%BE%E8%AE%A1%E6%96%B9%E6%B3%95"><span class="nav-text">系统测试用例设计方法</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BE%93%E5%85%A5%E5%9F%9F%E5%88%92%E5%88%86-%E2%80%93-%E5%9F%BA%E4%BA%8E%E7%AD%89%E4%BB%B7%E7%B1%BB%E6%80%9D%E6%83%B3"><span class="nav-text">输入域划分 – 基于等价类思想</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%85%A8%E7%BB%84%E5%90%88%E8%A6%86%E7%9B%96-All-Combination-Coverage-ACoC"><span class="nav-text">全组合覆盖 All Combination Coverage(ACoC):</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8D%95%E5%80%BC%E8%A6%86%E7%9B%96-Each-Choice-Coverage-ECC"><span class="nav-text">单值覆盖 Each Choice Coverage(ECC)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%85%A8%E5%AF%B9%E5%81%B6%E8%A6%86%E7%9B%96-Pair-Wise-Coverage-PWC"><span class="nav-text">全对偶覆盖 Pair-Wise Coverage(PWC)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%85%A8T%E5%80%BC%E8%A6%86%E7%9B%96-T-Wise-Coverage-TWC"><span class="nav-text">全T值覆盖 T-Wise Coverage(TWC)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%9F%BA%E6%9C%AC%E5%80%BC%E8%A6%86%E7%9B%96-Base-Choice-Coverage-BCC"><span class="nav-text">基本值覆盖 Base Choice Coverage(BCC)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%A4%9A%E5%9F%BA%E6%9C%AC%E5%80%BC%E8%A6%86%E7%9B%96-Multiple-Base-Choice-Coverage-MBCC"><span class="nav-text">多基本值覆盖 Multiple-Base Choice Coverage(MBCC)</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%B3%BB%E7%BB%9F%E6%B5%8B%E8%AF%95%E7%94%A8%E4%BE%8B%E7%94%9F%E6%88%90"><span class="nav-text">系统测试用例生成</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#FSM-Definition"><span class="nav-text">FSM Definition</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#FSM-Properties"><span class="nav-text">FSM Properties</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Chow%E2%80%99s-W-Method"><span class="nav-text">Chow’s W Method</span></a></li></ol></li></ol></li></ol>
    </div>
</div>
        </aside>
    

    <div class="image-viewer-container">
    <img src="">
</div>


    
        <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
          <span class="search-input-field-pre">
            <i class="fas fa-keyboard"></i>
          </span>
            <div class="search-input-container">
                <input autocomplete="off"
                       autocorrect="off"
                       autocapitalize="off"
                       placeholder="搜索..."
                       spellcheck="false"
                       type="search"
                       class="search-input"
                >
            </div>
            <span class="popup-btn-close">
                <i class="fas fa-times"></i>
            </span>
        </div>
        <div id="search-result">
            <div id="no-result">
                <i class="fas fa-spinner fa-pulse fa-5x fa-fw"></i>
            </div>
        </div>
    </div>
</div>

    

</main>




<script src="/js/utils.js"></script>

<script src="/js/main.js"></script>

<script src="/js/header-shrink.js"></script>

<script src="/js/back2top.js"></script>

<script src="/js/dark-light-toggle.js"></script>



    
<script src="/js/local-search.js"></script>




    
<script src="/js/code-copy.js"></script>





<div class="post-scripts">
    
        
<script src="/js/left-side-toggle.js"></script>

<script src="/js/libs/anime.min.js"></script>

<script src="/js/toc.js"></script>

    
</div>



</body>
</html>
